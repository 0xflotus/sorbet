begin
  class <emptyTree><<constant:<root>>> < ()
    def self.<static-init><<static-init>$12>()
      begin
        self(<singleton class:<constant:<root>>>).require_relative("../../../extn")
        ::Opus::AutogenLoader.init("__FILE__")
        <emptyTree>
      end
    end
  end
  module <emptyTree>::<constant:Opus>::<constant:CIBot>::<constant:Gerald><<constant:Gerald>> < ()
    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>
  end
  class <emptyTree>::<constant:MatchTimeout><<constant:MatchTimeout>> < (::StandardError)
    <emptyTree>

    <emptyTree>

    def rule_token<rule_token>()
      ::Opus::CIBot::Gerald::MatchTimeout#@rule_token
    end

    def initialize<initialize>(message, rule_token)
      begin
        self(<constant:MatchTimeout>).super(message)
        ::Opus::CIBot::Gerald::MatchTimeout#@rule_token = rule_token
      end
    end
  end
  class <emptyTree>::<constant:Matcher><<constant:Matcher>> < (::<todo sym>, ::Opus::CIBot::Gerald::Matcher::Chalk::Log)
    <emptyTree>

    <emptyTree>

    def initialize<initialize>()
      begin
        begin
          <assignTemp$3 = ::Opus::CIBot::Model::GeraldRule.query_by(:"deleted_at_is_nil").load_all({}).partition() do |<block-pass>$2$2|
            <block-pass>$2$2.valid?()
          end
          ::Opus::CIBot::Gerald::Matcher#@rules = <assignTemp$3.[](0)
          invalid_rules = <assignTemp$3.[](1)
          <assignTemp$3
        end
        if invalid_rules.empty?().!()
          begin
            invalid_rule_ids = invalid_rules.map() do |<block-pass>$4$3|
              <block-pass>$4$3.token()
            end.join(",")
            self(<constant:Matcher>).log().warn("Gerald skipping invalid rules: ".+(invalid_rule_ids))
          end
        else
          <emptyTree>
        end
      end
    end

    def match<match>(match_context)
      begin
        if match_context.diff().affected_files().count().>(::Opus::CIBot::Gerald::Matcher#MAX_AFFECTED_FILES)
          begin
            self(<constant:Matcher>).log().warn("Gerald skipping large PR with ".concat(begin
                  match_context.diff().affected_files().count()
                end.to_s()).concat(" affected files".to_s()).to_s())
            return []
          end
        else
          <emptyTree>
        end
        budget = ::Opus::CIBot::Gerald::MatchTimeBudget.new()
        ::Opus::CIBot::Gerald::Matcher#@rules.select() do |r$5|
          budget.time_rule(r$5) do ||
            r$5.matches?(match_context)
          end
        end
      end
    end
  end
  class <emptyTree>::<constant:MatchContext><<constant:MatchContext>> < (::<todo sym>)
    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    def repo<repo>()
      ::Opus::CIBot::Gerald::MatchContext#@repo
    end

    def assignee<assignee>()
      ::Opus::CIBot::Gerald::MatchContext#@assignee
    end

    def gh_user<gh_user>()
      ::Opus::CIBot::Gerald::MatchContext#@gh_user
    end

    def merge_branch<merge_branch>()
      ::Opus::CIBot::Gerald::MatchContext#@merge_branch
    end

    def body<body>()
      ::Opus::CIBot::Gerald::MatchContext#@body
    end

    def title<title>()
      ::Opus::CIBot::Gerald::MatchContext#@title
    end

    def diff<diff>()
      ::Opus::CIBot::Gerald::MatchContext#@diff
    end

    def openapi_diff<openapi_diff>()
      ::Opus::CIBot::Gerald::MatchContext#@openapi_diff
    end

    def initialize<initialize>(repo, assignee, gh_user, merge_branch, body, title, diff, openapi_diff)
      begin
        ::Opus::CIBot::Gerald::MatchContext#@repo = repo
        ::Opus::CIBot::Gerald::MatchContext#@assignee = assignee
        ::Opus::CIBot::Gerald::MatchContext#@gh_user = gh_user
        ::Opus::CIBot::Gerald::MatchContext#@merge_branch = merge_branch
        ::Opus::CIBot::Gerald::MatchContext#@body = body
        ::Opus::CIBot::Gerald::MatchContext#@title = title
        ::Opus::CIBot::Gerald::MatchContext#@diff = diff
        ::Opus::CIBot::Gerald::MatchContext#@openapi_diff = openapi_diff
      end
    end

    def user_stripe_suffix?<user_stripe_suffix?>()
      ::Opus::CIBot::Gerald::MatchContext#@repo.start_with?("stripe-internal/").!()
    end
  end
  class <emptyTree>::<constant:MatchTimeBudget><<constant:MatchTimeBudget>> < (::<todo sym>)
    <emptyTree>

    <emptyTree>

    <emptyTree>

    def initialize<initialize>()
      ::Opus::CIBot::Gerald::MatchTimeBudget#@start = ::Time.now()
    end

    def check!<check!>()
      begin
        dur_ms = begin
          ::Time.now().-(::Opus::CIBot::Gerald::MatchTimeBudget#@start)
        end.*(1000)
        if dur_ms.>(::Opus::CIBot::Gerald::MatchTimeBudget#TOTAL_TIME_MS)
          self(<constant:MatchTimeBudget>).raise(::Opus::CIBot::Gerald::MatchTimeout.new("Gerald match time budged exceeded ".concat(begin
                  ::Opus::CIBot::Gerald::MatchTimeBudget#TOTAL_TIME_MS
                end.to_s()).concat("ms".to_s()).to_s()))
        else
          <emptyTree>
        end
      end
    end

    def time_rule<time_rule>(rule, <blk>)
      begin
        rule_start = ::Time.now()
        res = <blk>.call(<emptyTree>)
        dur_ms = begin
          ::Time.now().-(rule_start)
        end.*(1000)
        if dur_ms.>(::Opus::CIBot::Gerald::MatchTimeBudget#PER_RULE_MS)
          self(<constant:MatchTimeBudget>).raise(::Opus::CIBot::Gerald::MatchTimeout.new("Gerald rule '".concat(begin
                  rule.token()
                end.to_s()).concat("' exceeded per-rule time budget actual=".to_s()).concat(begin
                  dur_ms.to_i()
                end.to_s()).concat("ms budget=".to_s()).concat(begin
                  ::Opus::CIBot::Gerald::MatchTimeBudget#PER_RULE_MS
                end.to_s()).concat("ms".to_s()).to_s(), {:"rule_token" => rule.token()}))
        else
          <emptyTree>
        end
        self(<constant:MatchTimeBudget>).check!()
        res
      end
    end
  end
  class <emptyTree>::<constant:Diff><<constant:Diff>> < (::<todo sym>)
    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    <emptyTree>

    def initialize<initialize>(raw_diff)
      begin
        ::Opus::CIBot::Gerald::Diff#@raw = raw_diff
        ::Opus::CIBot::Gerald::Diff#@parsed = self(<constant:Diff>).parse(raw_diff)
      end
    end

    def affected_files<affected_files>()
      self(<constant:Diff>).added_files().+(self(<constant:Diff>).deleted_files()).+(self(<constant:Diff>).changed_files())
    end

    def added_files<added_files>()
      ::Opus::CIBot::Gerald::Diff#@parsed.select() do |part$4|
        part$4.[](:"a_name").==("/dev/null")
      end.map() do |part$5|
        part$5.[](:"b_name")
      end
    end

    def deleted_files<deleted_files>()
      ::Opus::CIBot::Gerald::Diff#@parsed.select() do |part$7|
        part$7.[](:"b_name").==("/dev/null")
      end.map() do |part$8|
        part$8.[](:"a_name")
      end
    end

    def changed_files<changed_files>()
      ::Opus::CIBot::Gerald::Diff#@parsed.select() do |part$10|
        part$10.[](:"a_name").==(part$10.[](:"b_name"))
      end.map() do |part$11|
        part$11.[](:"b_name")
      end
    end

    def added_lines<added_lines>()
      ::Opus::CIBot::Gerald::Diff#@parsed.map() do |part$13|
        part$13.[](:"added_lines")
      end.flatten()
    end

    def removed_lines<removed_lines>()
      ::Opus::CIBot::Gerald::Diff#@parsed.map() do |part$15|
        part$15.[](:"removed_lines")
      end.flatten()
    end

    def changed_lines<changed_lines>()
      self(<constant:Diff>).added_lines().+(self(<constant:Diff>).removed_lines())
    end

    def changed_openapi?<changed_openapi?>()
      self(<constant:Diff>).changed_files().include?(::Opus::CIBot::Actions::OpenAPI::SPEC_PATH)
    end

    def parse<parse>(diff)
      begin
        parts = diff.split(::Regexp.new("^diff [^\n]*\n", 0.|(4))).[](::Range.new(1, -1))
        if parts
          parts
        else
          parts = []
        end
        parts = T.cast(parts, AppliedType {
          klass = ::Array
          targs = [
            <constant:Elem> = String
          ]
        })
        parts.map() do |part$19|
          begin
            lines$19 = part$19.split("
")
            a_name$19 = b_name$19 = T.cast(nil, String | NilClass)
            added_lines$19 = []
            removed_lines$19 = []
            lines$19.each() do |line$20|
              if line$20.start_with?("index ", "@@", "new file mode")
                next(<emptyTree>)
              else
                if line$20.start_with?("---")
                  begin
                    a_name$19 = line$20.[](::Range.new(4, -1))
                    if if a_name$19
                        a_name$19.start_with?("a/")
                      else
                        a_name$19
                      end
                      a_name$19 = a_name$19.[](::Range.new(2, -1))
                    else
                      <emptyTree>
                    end
                  end
                else
                  if line$20.start_with?("+++")
                    begin
                      b_name$19 = line$20.[](::Range.new(4, -1))
                      if if b_name$19
                          b_name$19.start_with?("b/")
                        else
                          b_name$19
                        end
                        b_name$19 = b_name$19.[](::Range.new(2, -1))
                      else
                        <emptyTree>
                      end
                    end
                  else
                    if line$20.start_with?("+")
                      added_lines$19.<<(line$20.[](::Range.new(1, -1)))
                    else
                      if line$20.start_with?("-")
                        removed_lines$19.<<(line$20.[](::Range.new(1, -1)))
                      else
                        <emptyTree>
                      end
                    end
                  end
                end
              end
            end
            if a_name$19.nil?()
              next(<emptyTree>)
            else
              <emptyTree>
            end
            {:"a_name" => a_name$19, :"b_name" => b_name$19, :"added_lines" => added_lines$19, :"removed_lines" => removed_lines$19}
          end
        end.compact()
      end
    end
  end
  <emptyTree>
end
