digraph "hard_assert.rb" {
subgraph "cluster_::Main#basic" {
    label = "::Main#basic";
    color = blue;
    "bb::Main#basic_0" [shape = invhouse];
    "bb::Main#basic_1" [shape = parallelogram];

    "bb::Main#basic_0" [
        label = "block[id=0]()\l<selfMethodTemp>$3 = self : Main\la = load_arg(<selfMethodTemp>$3#basic, 0) : Integer | String\l<statTemp>$5 = self : Main\l<statTemp>$8 = alias <constant:String> : <Class:String>\l<statTemp>$6 = a.is_a?(<statTemp>$8) : TrueClass | FalseClass\l<statTemp>$4 = <statTemp>$5.hard_assert(<statTemp>$6) : NilClass\l<statTemp>$11 = alias <constant:RubyTyper> : <Class:RubyTyper>\l<statTemp>$12 = alias <constant:String> : <Class:String>\l<statTemp>$10 = <statTemp>$11.keep_for_typechecking(<statTemp>$12) : RubyTyper::Void\l<castTemp>$13 = a : String\l<statTemp>$9 = cast(<castTemp>$13, String); : String\l<returnMethodTemp>$2 = nil : NilClass\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#basic_0" -> "bb::Main#basic_1" [style="bold"];
    "bb::Main#basic_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Main#basic_1" -> "bb::Main#basic_1" [style="bold"];
}

subgraph "cluster_::Main#not" {
    label = "::Main#not";
    color = blue;
    "bb::Main#not_0" [shape = invhouse];
    "bb::Main#not_1" [shape = parallelogram];

    "bb::Main#not_0" [
        label = "block[id=0]()\l<selfMethodTemp>$3 = self : Main\la = load_arg(<selfMethodTemp>$3#not, 0) : String | NilClass\l<statTemp>$5 = self : Main\l<statTemp>$7 = a.nil?() : TrueClass | FalseClass\l<statTemp>$6 = <statTemp>$7.!() : TrueClass | FalseClass\l<statTemp>$4 = <statTemp>$5.hard_assert(<statTemp>$6) : NilClass\l<statTemp>$11 = alias <constant:RubyTyper> : <Class:RubyTyper>\l<statTemp>$12 = alias <constant:String> : <Class:String>\l<statTemp>$10 = <statTemp>$11.keep_for_typechecking(<statTemp>$12) : RubyTyper::Void\l<castTemp>$13 = a : String\l<statTemp>$9 = cast(<castTemp>$13, String); : String\l<returnMethodTemp>$2 = nil : NilClass\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#not_0" -> "bb::Main#not_1" [style="bold"];
    "bb::Main#not_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Main#not_1" -> "bb::Main#not_1" [style="bold"];
}

subgraph "cluster_::Main#with_and" {
    label = "::Main#with_and";
    color = blue;
    "bb::Main#with_and_0" [shape = invhouse];
    "bb::Main#with_and_1" [shape = parallelogram];

    "bb::Main#with_and_0" [
        label = "block[id=0]()\l<selfMethodTemp>$3 = self : Main\la = load_arg(<selfMethodTemp>$3#with_and, 0) : String | NilClass\l<statTemp>$5 = self : Main\l&&$2 = a.nil?() : TrueClass | FalseClass\l&&$2\l"
    ];

    "bb::Main#with_and_0" -> "bb::Main#with_and_2" [style="bold"];
    "bb::Main#with_and_0" -> "bb::Main#with_and_3" [style="tapered"];

    "bb::Main#with_and_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Main#with_and_1" -> "bb::Main#with_and_1" [style="bold"];
    "bb::Main#with_and_2" [
        label = "block[id=2](<statTemp>$5, a)\l<statTemp>$10 = 1 : Integer(1)\l<statTemp>$11 = 1 : Integer(1)\l<statTemp>$6 = <statTemp>$10.==(<statTemp>$11) : TrueClass | FalseClass\l<unconditional>\l"
    ];

    "bb::Main#with_and_2" -> "bb::Main#with_and_4" [style="bold"];
    "bb::Main#with_and_3" [
        label = "block[id=3](<statTemp>$5, a, &&$2)\l<statTemp>$6 = &&$2 : FalseClass\l<unconditional>\l"
    ];

    "bb::Main#with_and_3" -> "bb::Main#with_and_4" [style="bold"];
    "bb::Main#with_and_4" [
        label = "block[id=4](<statTemp>$5, <statTemp>$6, a)\l<statTemp>$4 = <statTemp>$5.hard_assert(<statTemp>$6) : NilClass\l<statTemp>$14 = alias <constant:RubyTyper> : <Class:RubyTyper>\l<statTemp>$15 = alias <constant:NilClass> : <Class:NilClass>\l<statTemp>$13 = <statTemp>$14.keep_for_typechecking(<statTemp>$15) : RubyTyper::Void\l<castTemp>$16 = a : NilClass\l<statTemp>$12 = cast(<castTemp>$16, NilClass); : NilClass\l<returnMethodTemp>$2 = nil : NilClass\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#with_and_4" -> "bb::Main#with_and_1" [style="bold"];
}

subgraph "cluster_::Main#with_storytime" {
    label = "::Main#with_storytime";
    color = blue;
    "bb::Main#with_storytime_0" [shape = invhouse];
    "bb::Main#with_storytime_1" [shape = parallelogram];

    "bb::Main#with_storytime_0" [
        label = "block[id=0]()\l<statTemp>$4 = self : Main\l<statTemp>$5 = false : FalseClass\l<hashTemp>$7 = :\"storytime\" : Symbol(:\"storytime\")\l<hashTemp>$8 = 42 : Integer(42)\l<magic>$9 = alias <constant:<Magic>> : <Magic>\l<statTemp>$6 = <magic>$9.<build-hash>(<hashTemp>$7, <hashTemp>$8) : ShapeType {\l  Symbol(:\"storytime\") => Integer(42)\l}\l<returnMethodTemp>$2 = <statTemp>$4.hard_assert(<statTemp>$5, <statTemp>$6) : NilClass\l<finalReturn> = return <returnMethodTemp>$2\l<unconditional>\l"
    ];

    "bb::Main#with_storytime_0" -> "bb::Main#with_storytime_1" [style="bold"];
    "bb::Main#with_storytime_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Main#with_storytime_1" -> "bb::Main#with_storytime_1" [style="bold"];
}

subgraph "cluster_::Main#<static-init>" {
    label = "::Main#<static-init>";
    color = blue;
    "bb::Main#<static-init>_0" [shape = invhouse];
    "bb::Main#<static-init>_1" [shape = parallelogram];

    "bb::Main#<static-init>_0" [
        label = "block[id=0]()\l<statTemp>$6 = self : <Class:Main>\l<hashTemp>$8 = :\"a\" : Symbol(:\"a\")\l<statTemp>$10 = alias <constant:T> : <Class:T>\l<statTemp>$11 = alias <constant:Integer> : <Class:Integer>\l<statTemp>$12 = alias <constant:String> : <Class:String>\l<hashTemp>$9 = <statTemp>$10.any(<statTemp>$11, <statTemp>$12) : MetaType\l<magic>$13 = alias <constant:<Magic>> : <Magic>\l<statTemp>$7 = <magic>$13.<build-hash>(<hashTemp>$8, <hashTemp>$9) : ShapeType {\l  Symbol(:\"a\") => MetaType\l}\l<statTemp>$5 = <statTemp>$6.sig(<statTemp>$7) : Sorbet::Private::Builder\l<statTemp>$14 = alias <constant:NilClass> : <Class:NilClass>\l<statTemp>$4 = <statTemp>$5.returns(<statTemp>$14) : Sorbet::Private::Builder\l<statTemp>$17 = self : <Class:Main>\l<hashTemp>$19 = :\"a\" : Symbol(:\"a\")\l<statTemp>$21 = alias <constant:T> : <Class:T>\l<statTemp>$22 = alias <constant:String> : <Class:String>\l<statTemp>$23 = alias <constant:NilClass> : <Class:NilClass>\l<hashTemp>$20 = <statTemp>$21.any(<statTemp>$22, <statTemp>$23) : MetaType\l<magic>$24 = alias <constant:<Magic>> : <Magic>\l<statTemp>$18 = <magic>$24.<build-hash>(<hashTemp>$19, <hashTemp>$20) : ShapeType {\l  Symbol(:\"a\") => MetaType\l}\l<statTemp>$16 = <statTemp>$17.sig(<statTemp>$18) : Sorbet::Private::Builder\l<statTemp>$25 = alias <constant:NilClass> : <Class:NilClass>\l<statTemp>$15 = <statTemp>$16.returns(<statTemp>$25) : Sorbet::Private::Builder\l<statTemp>$28 = self : <Class:Main>\l<hashTemp>$30 = :\"a\" : Symbol(:\"a\")\l<statTemp>$32 = alias <constant:T> : <Class:T>\l<statTemp>$33 = alias <constant:String> : <Class:String>\l<statTemp>$34 = alias <constant:NilClass> : <Class:NilClass>\l<hashTemp>$31 = <statTemp>$32.any(<statTemp>$33, <statTemp>$34) : MetaType\l<magic>$35 = alias <constant:<Magic>> : <Magic>\l<statTemp>$29 = <magic>$35.<build-hash>(<hashTemp>$30, <hashTemp>$31) : ShapeType {\l  Symbol(:\"a\") => MetaType\l}\l<statTemp>$27 = <statTemp>$28.sig(<statTemp>$29) : Sorbet::Private::Builder\l<statTemp>$36 = alias <constant:NilClass> : <Class:NilClass>\l<statTemp>$26 = <statTemp>$27.returns(<statTemp>$36) : Sorbet::Private::Builder\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#<static-init>_0" -> "bb::Main#<static-init>_1" [style="bold"];
    "bb::Main#<static-init>_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Main#<static-init>_1" -> "bb::Main#<static-init>_1" [style="bold"];
}

}

