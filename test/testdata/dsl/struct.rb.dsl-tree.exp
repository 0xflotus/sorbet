class <emptyTree><<C <U <root>>>> < ()
  self(<C <U <todo sym>>>).<U require_relative>("../../t")

  module <emptyTree>::<C <U Foo>><<C <U <todo sym>>>> < ()
    class <emptyTree>::<C <U Struct>><<C <U <todo sym>>>> < (::<todo sym>)
      <emptyTree>
    end
  end

  class <emptyTree>::<C <U NotStruct>><<C <U <todo sym>>>> < (::<todo sym>)
    <emptyTree>::<C <U B>> = <emptyTree>::<C <U T>>.<U let>(<emptyTree>::<C <U Foo>>::<C <U Struct>>.<U new>(), <emptyTree>::<C <U Foo>>::<C <U Struct>>)

    <U var> = <emptyTree>::<C <U Struct>>.<U new>(:"foo")
  end

  class <emptyTree>::<C <U RealStruct>><<C <U <todo sym>>>> < (::<todo sym>)
    class <emptyTree>::<C <U A>><<C <U <todo sym>>>> < (::<root>::<C <U Struct>>)
      <emptyTree>::<C <U Elem>> = self(<C <U <todo sym>>>).<U type_member>({:"fixed" => ::T.<U untyped>()})

      def <U foo><<C <U <todo sym>>>>(&<U <blk>>)
        <emptyTree>
      end

      def <U foo=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        <U arg0>
      end

      def <U bar><<C <U <todo sym>>>>(&<U <blk>>)
        <emptyTree>
      end

      def <U bar=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        <U arg0>
      end

      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U params>({:"foo" => ::BasicObject, :"bar" => ::BasicObject}).<U returns>(<emptyTree>::<C <U A>>)
      end

      def self.<U new><<C <U <todo sym>>>>(<U foo> = nil, <U bar> = nil, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U A>>)
      end
    end
  end

  class <emptyTree>::<C <U RealStructDesugar>><<C <U <todo sym>>>> < (::<todo sym>)
    class <emptyTree>::<C <U A>><<C <U <todo sym>>>> < (<emptyTree>::<C <U Struct>>)
      self(<C <U <todo sym>>>).<U extend>(<emptyTree>::<C <U T>>::<C <U Sig>>)

      def <U foo><<C <U <todo sym>>>>(&<U <blk>>)
        <emptyTree>
      end

      def <U bar><<C <U <todo sym>>>>(&<U <blk>>)
        <emptyTree>
      end

      def <U foo=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        <U arg0>
      end

      def <U bar=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        <U arg0>
      end

      self(<C <U <todo sym>>>).<U sig>() do ||
        self(<C <U <todo sym>>>).<U params>({:"foo" => <emptyTree>::<C <U BasicObject>>, :"bar" => <emptyTree>::<C <U BasicObject>>}).<U returns>(<emptyTree>::<C <U A>>)
      end

      def self.<U new><<C <U <todo sym>>>>(<U foo> = nil, <U bar> = nil, &<U <blk>>)
        <emptyTree>::<C <U T>>.<U cast>(nil, <emptyTree>::<C <U A>>)
      end
    end
  end

  class <emptyTree>::<C <U TwoStructs>><<C <U <todo sym>>>> < (::<todo sym>)
    class <emptyTree>::<C <U A>><<C <U <todo sym>>>> < (::<root>::<C <U Struct>>)
      <emptyTree>::<C <U Elem>> = self(<C <U <todo sym>>>).<U type_member>({:"fixed" => ::T.<U untyped>()})

      def <U foo><<C <U <todo sym>>>>(&<U <blk>>)
        <emptyTree>
      end

      def <U foo=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        <U arg0>
      end

      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U params>({:"foo" => ::BasicObject}).<U returns>(<emptyTree>::<C <U A>>)
      end

      def self.<U new><<C <U <todo sym>>>>(<U foo> = nil, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U A>>)
      end
    end

    class <emptyTree>::<C <U B>><<C <U <todo sym>>>> < (::<root>::<C <U Struct>>)
      <emptyTree>::<C <U Elem>> = self(<C <U <todo sym>>>).<U type_member>({:"fixed" => ::T.<U untyped>()})

      def <U foo><<C <U <todo sym>>>>(&<U <blk>>)
        <emptyTree>
      end

      def <U foo=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        <U arg0>
      end

      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U params>({:"foo" => ::BasicObject}).<U returns>(<emptyTree>::<C <U B>>)
      end

      def self.<U new><<C <U <todo sym>>>>(<U foo> = nil, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U B>>)
      end
    end
  end

  class <emptyTree>::<C <U AccidentallyStruct>><<C <U <todo sym>>>> < (::<todo sym>)
    class <emptyTree>::<C <U Struct>><<C <U <todo sym>>>> < (::<todo sym>)
      <emptyTree>
    end

    class <emptyTree>::<C <U A>><<C <U <todo sym>>>> < (::<root>::<C <U Struct>>)
      <emptyTree>::<C <U Elem>> = self(<C <U <todo sym>>>).<U type_member>({:"fixed" => ::T.<U untyped>()})

      def <U foo><<C <U <todo sym>>>>(&<U <blk>>)
        <emptyTree>
      end

      def <U foo=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        <U arg0>
      end

      def <U bar><<C <U <todo sym>>>>(&<U <blk>>)
        <emptyTree>
      end

      def <U bar=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        <U arg0>
      end

      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U params>({:"foo" => ::BasicObject, :"bar" => ::BasicObject}).<U returns>(<emptyTree>::<C <U A>>)
      end

      def self.<U new><<C <U <todo sym>>>>(<U foo> = nil, <U bar> = nil, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U A>>)
      end
    end
  end

  class <emptyTree>::<C <U Main>><<C <U <todo sym>>>> < (::<todo sym>)
    def <U main><<C <U <todo sym>>>>(&<U <blk>>)
      begin
        <U a> = <emptyTree>::<C <U Struct>>.<U new>(:"foo")
        <emptyTree>::<C <U T>>.<U assert_type!>(<U a>, <emptyTree>::<C <U Class>>)
        <emptyTree>::<C <U T>>.<U assert_type!>(<U a>.<U new>(), <emptyTree>::<C <U Struct>>)
        <emptyTree>::<C <U T>>.<U assert_type!>(<U a>.<U new>(2), <emptyTree>::<C <U Struct>>)
        <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U RealStruct>>::<C <U A>>.<U new>(2, 3), <emptyTree>::<C <U RealStruct>>::<C <U A>>)
        <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U RealStruct>>::<C <U A>>.<U new>(2), <emptyTree>::<C <U RealStruct>>::<C <U A>>)
        <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U RealStructDesugar>>::<C <U A>>.<U new>(2, 3), <emptyTree>::<C <U RealStructDesugar>>::<C <U A>>)
      end
    end
  end

  self(<C <U <todo sym>>>).<U puts>(<emptyTree>::<C <U Main>>.<U new>().<U main>())
end
