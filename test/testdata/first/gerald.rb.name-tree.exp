begin
  self(<singleton class:<constant:<root>>>).require_relative("../../../extn")
  ::<constant:Opus>::<constant:AutogenLoader>.init("__FILE__")
  module <emptyTree>::<constant:Opus>::<constant:CIBot>::<constant:Gerald><<constant:Gerald>> < ()
    class <emptyTree>::<constant:MatchTimeout><<constant:MatchTimeout>> < (::<constant:StandardError>)
      self(<singleton class:<constant:MatchTimeout>>).attr_reader(:rule_token)

      def initialize<initialize>(message, rule_token)
        begin
          self(<constant:MatchTimeout>).super(message)
          ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchTimeout>#@rule_token = rule_token
        end

    end

    class <emptyTree>::<constant:Matcher><<constant:Matcher>> < (::<constant:<todo sym>>, ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:Chalk>::<constant:Log>)
      ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:Matcher>#<constant:MAX_AFFECTED_FILES> = 100

      def initialize<initialize>()
        begin
          begin
            assignTemp$10000 = ::<constant:Opus>::<constant:CIBot>::<constant:Model>::<constant:GeraldRule>.query_by(:deleted_at_is_nil).load_all({}).partition(<Not Supported (BlockPass)>)
            ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:Matcher>#@rules = assignTemp$10000.[](0)
            invalid_rules = assignTemp$10000.[](1)
            assignTemp$10000
          end
          if invalid_rules.empty?().!()
            begin
              invalid_rule_ids = invalid_rules.map(<Not Supported (BlockPass)>).join(",")
              self(<constant:Matcher>).log().warn("Gerald skipping invalid rules: ".+(invalid_rule_ids))
            end
          else
            <emptyTree>
          end
        end

      def match<match>(match_context)
        begin
          if match_context.diff().affected_files().count().>(::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:Matcher>#<constant:MAX_AFFECTED_FILES>)
            begin
              self(<constant:Matcher>).log().warn("Gerald skipping large PR with ".concat(begin
                    match_context.diff().affected_files().count()
                  end.to_s()).concat(" affected files").to_s())
              return []
            end
          else
            <emptyTree>
          end
          budget = ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchTimeBudget>.new()
          ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:Matcher>#@rules.select() do |<block-nested: r>|
            budget.time_rule(<block-nested: r>) do ||
              <block-nested: r>.matches?(match_context)
            end
          end
        end

    end

    class <emptyTree>::<constant:MatchContext><<constant:MatchContext>> < (::<constant:<todo sym>>)
      self(<singleton class:<constant:MatchContext>>).attr_reader(:repo)

      self(<singleton class:<constant:MatchContext>>).attr_reader(:assignee)

      self(<singleton class:<constant:MatchContext>>).attr_reader(:gh_user)

      self(<singleton class:<constant:MatchContext>>).attr_reader(:merge_branch)

      self(<singleton class:<constant:MatchContext>>).attr_reader(:body)

      self(<singleton class:<constant:MatchContext>>).attr_reader(:title)

      self(<singleton class:<constant:MatchContext>>).attr_reader(:diff)

      self(<singleton class:<constant:MatchContext>>).attr_reader(:openapi_diff)

      def initialize<initialize>(repo, assignee, gh_user, merge_branch, body, title, diff, openapi_diff)
        begin
          ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchContext>#@repo = repo
          ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchContext>#@assignee = assignee
          ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchContext>#@gh_user = gh_user
          ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchContext>#@merge_branch = merge_branch
          ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchContext>#@body = body
          ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchContext>#@title = title
          ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchContext>#@diff = diff
          ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchContext>#@openapi_diff = openapi_diff
        end

      def user_stripe_suffix?<user_stripe_suffix?>()
        ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchContext>#@repo.start_with?("stripe-internal/").!()

    end

    class <emptyTree>::<constant:MatchTimeBudget><<constant:MatchTimeBudget>> < (::<constant:<todo sym>>)
      ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchTimeBudget>#<constant:TOTAL_TIME_MS> = 10000

      ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchTimeBudget>#<constant:PER_RULE_MS> = 2000

      def initialize<initialize>()
        ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchTimeBudget>#@start = ::<constant:Time>.now()

      def check!<check!>()
        begin
          dur_ms = begin
            ::<constant:Time>.now().-(::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchTimeBudget>#@start)
          end.*(1000)
          if dur_ms.>(::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchTimeBudget>#<constant:TOTAL_TIME_MS>)
            self(<constant:MatchTimeBudget>).raise(::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchTimeout>.new("Gerald match time budged exceeded ".concat(begin
                    ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchTimeBudget>#<constant:TOTAL_TIME_MS>
                  end.to_s()).concat("ms").to_s()))
          else
            <emptyTree>
          end
        end

      def time_rule<time_rule>(rule)
        begin
          rule_start = ::<constant:Time>.now()
          res = yield(<emptyTree>)
          dur_ms = begin
            ::<constant:Time>.now().-(rule_start)
          end.*(1000)
          if dur_ms.>(::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchTimeBudget>#<constant:PER_RULE_MS>)
            self(<constant:MatchTimeBudget>).raise(::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchTimeout>.new("Gerald rule '".concat(begin
                    rule.token()
                  end.to_s()).concat("' exceeded per-rule time budget actual=").concat(begin
                    dur_ms.to_i()
                  end.to_s()).concat("ms budget=").concat(begin
                    ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:MatchTimeBudget>#<constant:PER_RULE_MS>
                  end.to_s()).concat("ms").to_s(), {:rule_token => rule.token()}))
          else
            <emptyTree>
          end
          self(<constant:MatchTimeBudget>).check!()
          res
        end

    end

    class <emptyTree>::<constant:Diff><<constant:Diff>> < (::<constant:<todo sym>>)
      def initialize<initialize>(raw_diff)
        begin
          ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:Diff>#@raw = raw_diff
          ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:Diff>#@parsed = self(<constant:Diff>).parse(raw_diff)
        end

      def affected_files<affected_files>()
        self(<constant:Diff>).added_files().+(self(<constant:Diff>).deleted_files()).+(self(<constant:Diff>).changed_files())

      def added_files<added_files>()
        ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:Diff>#@parsed.select() do |<block-nested: part>|
          <block-nested: part>.[](:a_name).==("/dev/null")
        end.map() do |<block-nested: part>|
          <block-nested: part>.[](:b_name)
        end

      def deleted_files<deleted_files>()
        ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:Diff>#@parsed.select() do |<block-nested: part>|
          <block-nested: part>.[](:b_name).==("/dev/null")
        end.map() do |<block-nested: part>|
          <block-nested: part>.[](:a_name)
        end

      def changed_files<changed_files>()
        ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:Diff>#@parsed.select() do |<block-nested: part>|
          <block-nested: part>.[](:a_name).==(<block-nested: part>.[](:b_name))
        end.map() do |<block-nested: part>|
          <block-nested: part>.[](:b_name)
        end

      def added_lines<added_lines>()
        ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:Diff>#@parsed.map() do |<block-nested: part>|
          <block-nested: part>.[](:added_lines)
        end.flatten()

      def removed_lines<removed_lines>()
        ::<constant:Opus>::<constant:CIBot>::<constant:Gerald>::<constant:Diff>#@parsed.map() do |<block-nested: part>|
          <block-nested: part>.[](:removed_lines)
        end.flatten()

      def changed_lines<changed_lines>()
        self(<constant:Diff>).added_lines().+(self(<constant:Diff>).removed_lines())

      def changed_openapi?<changed_openapi?>()
        self(<constant:Diff>).changed_files().include?(::<constant:Opus>::<constant:CIBot>::<constant:Actions>::<constant:OpenAPI>::<constant:SPEC_PATH>)

      self(<singleton class:<constant:Diff>>).private(def parse<parse>(diff)
          begin
            parts = diff.split(<Not Supported (Regexp)>).[](::<constant:Range>.new(1, -1))
            if parts
              parts
            else
              parts = []
            end
            parts.map() do |<block-nested: part>|
              begin
                <block-nested: lines> = <block-nested: part>.split("
")
                <block-nested: a_name> = <block-nested: b_name> = nil
                <block-nested: added_lines> = []
                <block-nested: removed_lines> = []
                <block-nested: lines>.each() do |<block-nested: line>|
                  if <block-nested: line>.start_with?("index ", "@@", "new file mode")
                    next(<emptyTree>)
                  else
                    if <block-nested: line>.start_with?("---")
                      begin
                        <block-nested: a_name> = <block-nested: line>.[](::<constant:Range>.new(4, -1))
                        if if <block-nested: a_name>
                            <block-nested: a_name>.start_with?("a/")
                          else
                            <block-nested: a_name>
                          end
                          <block-nested: a_name> = <block-nested: a_name>.[](::<constant:Range>.new(2, -1))
                        else
                          <emptyTree>
                        end
                      end
                    else
                      if <block-nested: line>.start_with?("+++")
                        begin
                          <block-nested: b_name> = <block-nested: line>.[](::<constant:Range>.new(4, -1))
                          if if <block-nested: b_name>
                              <block-nested: b_name>.start_with?("b/")
                            else
                              <block-nested: b_name>
                            end
                            <block-nested: b_name> = <block-nested: b_name>.[](::<constant:Range>.new(2, -1))
                          else
                            <emptyTree>
                          end
                        end
                      else
                        if <block-nested: line>.start_with?("+")
                          <block-nested: added_lines>.<<(<block-nested: line>.[](::<constant:Range>.new(1, -1)))
                        else
                          if <block-nested: line>.start_with?("-")
                            <block-nested: removed_lines>.<<(<block-nested: line>.[](::<constant:Range>.new(1, -1)))
                          else
                            <emptyTree>
                          end
                        end
                      end
                    end
                  end
                end
                if <block-nested: a_name>.nil?()
                  next(<emptyTree>)
                else
                  <emptyTree>
                end
                {:a_name => <block-nested: a_name>, :b_name => <block-nested: b_name>, :added_lines => <block-nested: added_lines>, :removed_lines => <block-nested: removed_lines>}
              end
            end.compact()
          end)

    end

  end
  class <emptyTree>::<constant:Range><<constant:Range>> < (::<constant:<todo sym>>)
    def initialize<initialize>(begin_, end_, exclude_end)
      <emptyTree>

  end
end
