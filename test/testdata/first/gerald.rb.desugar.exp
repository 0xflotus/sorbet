begin
  <emtpyTree>.require_relative("../../../extn".to_s())
  <emtpyTree>::Opus::AutogenLoader.init(<Not Supported (FileLiteral)>)
  module <emtpyTree>::Opus::CIBot::Gerald<<todo sym>>
    class <emtpyTree>::MatchTimeout<<todo sym>>
      <emtpyTree>.attr_reader(:rule_token)

      def initialize<<todo sym>>(message<todo lvar sym>, <Not Supported (Kwoptarg)>)
        begin
          super(message<todo lvar sym>)
          @rule_token<todo ivar sym> = rule_token<todo lvar sym>
        end

    end

    class <emtpyTree>::Matcher<<todo sym>>
      <emtpyTree>.include(<emtpyTree>::Chalk::Log)

      <emtpyTree>::MAX_AFFECTED_FILES = 100

      def initialize<<todo sym>>()
        begin
          <Not Supported (Masgn)>
          if invalid_rules<todo lvar sym>.empty?().!()
            begin
              invalid_rule_ids<todo lvar sym> = invalid_rules<todo lvar sym>.map(<Not Supported (BlockPass)>).join(",".to_s())
              <emtpyTree>.log().warn("Gerald skipping invalid rules: ".to_s().+(invalid_rule_ids<todo lvar sym>))
            end
          else 
            <emtpyTree>
          end
        end

      def match<<todo sym>>(match_context<todo lvar sym>)
        begin
          if match_context<todo lvar sym>.diff().affected_files().count().>(<emtpyTree>::MAX_AFFECTED_FILES)
            begin
              <emtpyTree>.log().warn("Gerald skipping large PR with ".to_s().concat(begin
                    match_context<todo lvar sym>.diff().affected_files().count()
                  end.to_s()).concat(" affected files".to_s()).to_s())
              return []
            end
          else 
            <emtpyTree>
          end
          budget<todo lvar sym> = <emtpyTree>::MatchTimeBudget.new()
          @rules<todo ivar sym>.select() do |r<todo lvar sym>|
            budget<todo lvar sym>.time_rule(r<todo lvar sym>) do ||
              r<todo lvar sym>.matches?(match_context<todo lvar sym>)
            end
          end
        end

    end

    class <emtpyTree>::MatchContext<<todo sym>>
      <emtpyTree>.attr_reader(:repo)

      <emtpyTree>.attr_reader(:assignee)

      <emtpyTree>.attr_reader(:gh_user)

      <emtpyTree>.attr_reader(:merge_branch)

      <emtpyTree>.attr_reader(:body)

      <emtpyTree>.attr_reader(:title)

      <emtpyTree>.attr_reader(:diff)

      <emtpyTree>.attr_reader(:openapi_diff)

      def initialize<<todo sym>>(repo<todo lvar sym>, assignee<todo lvar sym>, gh_user<todo lvar sym>, merge_branch<todo lvar sym>, body<todo lvar sym>, title<todo lvar sym>, diff<todo lvar sym>, openapi_diff<todo lvar sym>)
        begin
          @repo<todo ivar sym> = repo<todo lvar sym>
          @assignee<todo ivar sym> = assignee<todo lvar sym>
          @gh_user<todo ivar sym> = gh_user<todo lvar sym>
          @merge_branch<todo ivar sym> = merge_branch<todo lvar sym>
          @body<todo ivar sym> = body<todo lvar sym>
          @title<todo ivar sym> = title<todo lvar sym>
          @diff<todo ivar sym> = diff<todo lvar sym>
          @openapi_diff<todo ivar sym> = openapi_diff<todo lvar sym>
        end

      def user_stripe_suffix?<<todo sym>>()
        @repo<todo ivar sym>.start_with?("stripe-internal/".to_s()).!()

    end

    class <emtpyTree>::MatchTimeBudget<<todo sym>>
      <emtpyTree>::TOTAL_TIME_MS = 10000

      <emtpyTree>::PER_RULE_MS = 2000

      def initialize<<todo sym>>()
        @start<todo ivar sym> = <emtpyTree>::Time.now()

      def check!<<todo sym>>()
        begin
          dur_ms<todo lvar sym> = begin
            <emtpyTree>::Time.now().-(@start<todo ivar sym>)
          end.*(1000)
          if dur_ms<todo lvar sym>.>(<emtpyTree>::TOTAL_TIME_MS)
            <emtpyTree>.raise(<emtpyTree>::MatchTimeout.new("Gerald match time budged exceeded ".to_s().concat(begin
                    <emtpyTree>::TOTAL_TIME_MS
                  end.to_s()).concat("ms".to_s()).to_s()))
          else 
            <emtpyTree>
          end
        end

      def time_rule<<todo sym>>(rule<todo lvar sym>)
        begin
          rule_start<todo lvar sym> = <emtpyTree>::Time.now()
          res<todo lvar sym> = <Not Supported (Yield)>
          dur_ms<todo lvar sym> = begin
            <emtpyTree>::Time.now().-(rule_start<todo lvar sym>)
          end.*(1000)
          if dur_ms<todo lvar sym>.>(<emtpyTree>::PER_RULE_MS)
            <emtpyTree>.raise(<emtpyTree>::MatchTimeout.new("Gerald rule '".to_s().concat(begin
                    rule<todo lvar sym>.token()
                  end.to_s()).concat("' exceeded per-rule time budget actual=".to_s()).concat(begin
                    dur_ms<todo lvar sym>.to_i()
                  end.to_s()).concat("ms budget=".to_s()).concat(begin
                    <emtpyTree>::PER_RULE_MS
                  end.to_s()).concat("ms".to_s()).to_s(), <Not Supported (Hash)>))
          else 
            <emtpyTree>
          end
          <emtpyTree>.check!()
          res<todo lvar sym>
        end

    end

    class <emtpyTree>::Diff<<todo sym>>
      def initialize<<todo sym>>(raw_diff<todo lvar sym>)
        begin
          @raw<todo ivar sym> = raw_diff<todo lvar sym>
          @parsed<todo ivar sym> = <emtpyTree>.parse(raw_diff<todo lvar sym>)
        end

      def affected_files<<todo sym>>()
        <emtpyTree>.added_files().+(<emtpyTree>.deleted_files()).+(<emtpyTree>.changed_files())

      def added_files<<todo sym>>()
        @parsed<todo ivar sym>.select() do |part<todo lvar sym>|
          part<todo lvar sym>.[](:a_name).==("/dev/null".to_s())
        end.map() do |part<todo lvar sym>|
          part<todo lvar sym>.[](:b_name)
        end

      def deleted_files<<todo sym>>()
        @parsed<todo ivar sym>.select() do |part<todo lvar sym>|
          part<todo lvar sym>.[](:b_name).==("/dev/null".to_s())
        end.map() do |part<todo lvar sym>|
          part<todo lvar sym>.[](:a_name)
        end

      def changed_files<<todo sym>>()
        @parsed<todo ivar sym>.select() do |part<todo lvar sym>|
          part<todo lvar sym>.[](:a_name).==(part<todo lvar sym>.[](:b_name))
        end.map() do |part<todo lvar sym>|
          part<todo lvar sym>.[](:b_name)
        end

      def added_lines<<todo sym>>()
        @parsed<todo ivar sym>.map() do |part<todo lvar sym>|
          part<todo lvar sym>.[](:added_lines)
        end.flatten()

      def removed_lines<<todo sym>>()
        @parsed<todo ivar sym>.map() do |part<todo lvar sym>|
          part<todo lvar sym>.[](:removed_lines)
        end.flatten()

      def changed_lines<<todo sym>>()
        <emtpyTree>.added_lines().+(<emtpyTree>.removed_lines())

      def changed_openapi?<<todo sym>>()
        <emtpyTree>.changed_files().include?(<emtpyTree>::Opus::CIBot::Actions::OpenAPI::SPEC_PATH)

      <emtpyTree>.private(def parse<<todo sym>>(diff<todo lvar sym>)
          begin
            parts<todo lvar sym> = diff<todo lvar sym>.split(<Not Supported (Regexp)>).[](<Not Supported (IRange)>)
            if parts<todo lvar sym>
              parts<todo lvar sym>
            else 
              parts<todo lvar sym> = []
            end
            parts<todo lvar sym>.map() do |part<todo lvar sym>|
              begin
                lines<todo lvar sym> = part<todo lvar sym>.split("
".to_s())
                a_name<todo lvar sym> = b_name<todo lvar sym> = <Not Supported (Nil)>
                added_lines<todo lvar sym> = []
                removed_lines<todo lvar sym> = []
                lines<todo lvar sym>.each() do |line<todo lvar sym>|
                  if line<todo lvar sym>.start_with?("index ".to_s(), "@@".to_s(), "new file mode".to_s())
                    <Not Supported (Next)>
                  else 
                    if line<todo lvar sym>.start_with?("---".to_s())
                      begin
                        a_name<todo lvar sym> = line<todo lvar sym>.[](<Not Supported (IRange)>)
                        if <emtpyTree>.&&(<emtpyTree>)
                          a_name<todo lvar sym> = a_name<todo lvar sym>.[](<Not Supported (IRange)>)
                        else 
                          <emtpyTree>
                        end
                      end
                    else 
                      if line<todo lvar sym>.start_with?("+++".to_s())
                        begin
                          b_name<todo lvar sym> = line<todo lvar sym>.[](<Not Supported (IRange)>)
                          if <emtpyTree>.&&(<emtpyTree>)
                            b_name<todo lvar sym> = b_name<todo lvar sym>.[](<Not Supported (IRange)>)
                          else 
                            <emtpyTree>
                          end
                        end
                      else 
                        if line<todo lvar sym>.start_with?("+".to_s())
                          added_lines<todo lvar sym>.<<(line<todo lvar sym>.[](<Not Supported (IRange)>))
                        else 
                          if line<todo lvar sym>.start_with?("-".to_s())
                            removed_lines<todo lvar sym>.<<(line<todo lvar sym>.[](<Not Supported (IRange)>))
                          else 
                            <emtpyTree>
                          end
                        end
                      end
                    end
                  end
                end
                if a_name<todo lvar sym>.nil?()
                  <Not Supported (Next)>
                else 
                  <emtpyTree>
                end
                <Not Supported (Hash)>
              end
            end.compact()
          end)

    end

  end
end
