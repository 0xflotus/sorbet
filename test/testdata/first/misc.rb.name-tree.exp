begin
  <Not Supported (Alias)>
  ::<singleton class:<root>>#@iv = 1
  #@@cv = 1
  #$gv = 1
  begin
    assignTmp$2 = [nil, nil]
    self(<singleton class:<root>>).x().var=(assignTmp$2.[](0))
    y = assignTmp$2.[](1)
    assignTmp$2
  end
  begin
    assignTmp$3 = self(<singleton class:<root>>).zaaaz()
    baaaar = assignTmp$3.[](0)
    naaar = assignTmp$3.[](1)
    assignTmp$3
  end
  xaaaaz = [self(<singleton class:<root>>).yayayaya(), self(<singleton class:<root>>).tutututu()]
  <emptyTree>
  begin
    nil
  end
  begin
    self(<singleton class:<root>>).a()
    self(<singleton class:<root>>).b()
  end
  def foo<foo>(x)
    <emptyTree>
  self(<singleton class:<root>>).lambda() do ||
    <emptyTree>
  end
  <Not Supported (Case)>
  "x"
  1.+(<Not Supported (Complex)>)
  <Not Supported (Float)>
  <Not Supported (Complex)>
  def self.classmeth<classmeth>()
    <emptyTree>
  <Not Supported (SClass)>
  begin
    ||$4 = true
    if ||$4
      ||$4
    else
      false
    end
  end
  <Not Supported (For)>
  while 0.!=(1)
    <emptyTree>
  end
  x.[]=(0)
  break(<emptyTree>)
  break(1)
  break([1, 2])
  next(<emptyTree>)
  next(1)
  next([1, 2])
  <Not Supported (Defined)>
  <Not Supported (ZSuper)>
  def foo<foo>(x, y, z)
    <emptyTree>
  x
  <Not Supported (LineLiteral)>
  while true
    nil
  end
  while true
    nil
  end
  while true.!()
    nil
  end
  while true.!()
    nil
  end
  begin
    assignTmp$5 = 1
    a = assignTmp$5.[](0)
    <Not Supported (Mlhs)>
    assignTmp$5
  end
  <Not Supported (NthRef)>
  def foo<foo>(x, y)
    <emptyTree>
  {x => y, <Not Supported (DSymbol)> => 1}
  <Not Supported (Preexe)>
  <Not Supported (Postexe)>
  <Not Supported (Rational)>
  <Not Supported (Complex)>
  begin
    <Not Supported (Rescue)>
  end
  begin
    assignTmp$6 = [<Not Supported (Splat)>]
    <Not Supported (SplatLhs)>
    assignTmp$6
  end
  <Not Supported (DSymbol)>
  [:sym]
  if x
    1
  else
    7
  end
  <Not Supported (Undef)>
  ["a", "b"]
  ["a", "b"]
  <Not Supported (XString)>
  self(<singleton class:<root>>).proc() do |<block-nested: x$11>|
    <emptyTree>
  end
  break(self(<todo sym>).foo(1) do ||
      <emptyTree>
    end)
  def foo<foo>(*$0)
    <emptyTree>
  def foo<foo>(**$1)
    <emptyTree>
end
