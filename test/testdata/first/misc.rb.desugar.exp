begin
  <Not Supported (Alias)>
  @iv<todo ivar sym> = 1
  @@cv<todo cvar sym> = 1
  $gv<todo gvar sym> = 1
  <Not Supported (Masgn)>
  <Not Supported (Kwbegin)>
  <Not Supported (Kwbegin)>
  <Not Supported (Kwbegin)>
  def foo<<todo sym>>(<Not Supported (Blockarg)>)
    <emtpyTree>
  <emtpyTree>.lambda() do ||
    <emtpyTree>
  end
  <Not Supported (Case)>
  "x".to_s()
  1.+(<Not Supported (Complex)>)
  <Not Supported (Float)>
  <Not Supported (Complex)>
  <Not Supported (DefS)>
  <Not Supported (SClass)>
  begin
    ||$2 = true
    if ||$2
      ||$2
    else 
      false
    end
  end
  <Not Supported (For)>
  while 0.!=(1)
    <emtpyTree>
  end
  x<todo lvar sym>.[]=(0)
  break(<emtpyTree>)
  break(1)
  break([1, 2])
  next(<emtpyTree>)
  next(1)
  next([1, 2])
  <Not Supported (Defined)>
  <Not Supported (ZSuper)>
  def foo<<todo sym>>(<Not Supported (Kwarg)>, <Not Supported (Kwoptarg)>, <Not Supported (Kwrestarg)>)
    <emtpyTree>
  <Not Supported (Hash)>
  <Not Supported (LineLiteral)>
  while true
    nil
  end
  while true
    nil
  end
  while true.!()
    nil
  end
  while true.!()
    nil
  end
  <Not Supported (Masgn)>
  <Not Supported (NthRef)>
  def foo<<todo sym>>(<Not Supported (Optarg)>, <Not Supported (Restarg)>)
    <emtpyTree>
  <Not Supported (Hash)>
  <Not Supported (Preexe)>
  <Not Supported (Postexe)>
  <Not Supported (Rational)>
  <Not Supported (Complex)>
  <Not Supported (Kwbegin)>
  <Not Supported (Masgn)>
  <Not Supported (DSymbol)>
  [:sym]
  if x<todo lvar sym>
    1
  else 
    7
  end
  <Not Supported (Undef)>
  ["a", "b"]
  ["a".to_s(), "b".to_s()]
  <Not Supported (XString)>
  <emtpyTree>.proc() do |<Not Supported (Shadowarg)>|
    <emtpyTree>
  end
  break(<emtpyTree>.foo(1) do ||
      <emtpyTree>
    end)
  def foo<<todo sym>>(<Not Supported (Restarg)>)
    <emtpyTree>
  def foo<<todo sym>>(<Not Supported (Kwrestarg)>)
    <emtpyTree>
end
