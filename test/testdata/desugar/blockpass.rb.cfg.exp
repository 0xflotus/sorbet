digraph "blockpass.rb" {
subgraph "cluster_::Object#returns_lambda" {
    label = "::Object#returns_lambda";
    color = blue;
    "bb::Object#returns_lambda_0" [shape = invhouse];
    "bb::Object#returns_lambda_1" [shape = parallelogram];

    "bb::Object#returns_lambda_0" [
        label = "block[id=0]()\l<statTemp>$4: Object = self\l<block-pre-call-temp>$5: Proc1[T.untyped, T.untyped] = <statTemp>$4: Object.lambda()\l<unconditional>\l"
    ];

    "bb::Object#returns_lambda_0" -> "bb::Object#returns_lambda_2" [style="bold"];
    "bb::Object#returns_lambda_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Object#returns_lambda_1" -> "bb::Object#returns_lambda_1" [style="bold"];
    "bb::Object#returns_lambda_2" [
        label = "block[id=2]()\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#returns_lambda_2" -> "bb::Object#returns_lambda_4" [style="bold"];
    "bb::Object#returns_lambda_2" -> "bb::Object#returns_lambda_3" [style="tapered"];

    "bb::Object#returns_lambda_3" [
        label = "block[id=3]()\l<returnMethodTemp>$2: Proc1[T.untyped, T.untyped] = Solve<::Object#returns_lambda#<block>>\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: Proc1[T.untyped, T.untyped]\l<unconditional>\l"
    ];

    "bb::Object#returns_lambda_3" -> "bb::Object#returns_lambda_1" [style="bold"];
    "bb::Object#returns_lambda_4" [
        label = "block[id=4]()\louterLoops: 1\l<blk>$6: T.untyped = load_yield_params(::Object#returns_lambda#<block>, Object#returns_lambda#<block>)\l<blk>$7: Integer(0) = 0\lx$3: T.untyped = <blk>$6: T.untyped.[](<blk>$7: Integer(0))\l<blockReturnTemp>$8: String(\"returns_lambda\") = \"returns_lambda\"\l<blockReturnTemp>$9: T.noreturn = blockreturn<::Object#returns_lambda#<block>> <blockReturnTemp>$8: String(\"returns_lambda\")\l<unconditional>\l"
    ];

    "bb::Object#returns_lambda_4" -> "bb::Object#returns_lambda_2" [style="bold"];
}

subgraph "cluster_::Object#calls_arg_with_object" {
    label = "::Object#calls_arg_with_object";
    color = blue;
    "bb::Object#calls_arg_with_object_0" [shape = invhouse];
    "bb::Object#calls_arg_with_object_1" [shape = parallelogram];

    "bb::Object#calls_arg_with_object_0" [
        label = "block[id=0]()\l<selfMethodTemp>$3: Object = self\larg: T.untyped = load_arg(<selfMethodTemp>$3, Object#calls_arg_with_object#arg)\lblk: T.untyped = load_arg(<selfMethodTemp>$3, Object#calls_arg_with_object#blk)\l<returnMethodTemp>$2: T.untyped = blk: T.untyped.call(arg: T.untyped)\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#calls_arg_with_object_0" -> "bb::Object#calls_arg_with_object_1" [style="bold"];
    "bb::Object#calls_arg_with_object_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Object#calls_arg_with_object_1" -> "bb::Object#calls_arg_with_object_1" [style="bold"];
}

subgraph "cluster_::Object#calls_with_object" {
    label = "::Object#calls_with_object";
    color = blue;
    "bb::Object#calls_with_object_0" [shape = invhouse];
    "bb::Object#calls_with_object_1" [shape = parallelogram];

    "bb::Object#calls_with_object_0" [
        label = "block[id=0]()\l<selfMethodTemp>$3: Object = self\lblk: T.untyped = load_arg(<selfMethodTemp>$3, Object#calls_with_object#blk)\l<statTemp>$4: Object = self\l<statTemp>$6: T.class_of(HasMeth) = alias <constant:HasMeth>\l<statTemp>$5: HasMeth = <statTemp>$6: T.class_of(HasMeth).new()\l<block-pre-call-temp>$7: T.untyped = <statTemp>$4: Object.calls_arg_with_object(<statTemp>$5: HasMeth)\l<unconditional>\l"
    ];

    "bb::Object#calls_with_object_0" -> "bb::Object#calls_with_object_2" [style="bold"];
    "bb::Object#calls_with_object_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Object#calls_with_object_1" -> "bb::Object#calls_with_object_1" [style="bold"];
    "bb::Object#calls_with_object_2" [
        label = "block[id=2](blk: T.untyped)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#calls_with_object_2" -> "bb::Object#calls_with_object_4" [style="bold"];
    "bb::Object#calls_with_object_2" -> "bb::Object#calls_with_object_3" [style="tapered"];

    "bb::Object#calls_with_object_3" [
        label = "block[id=3]()\l<returnMethodTemp>$2: T.untyped = Solve<::Object#calls_with_object#<block>>\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#calls_with_object_3" -> "bb::Object#calls_with_object_1" [style="bold"];
    "bb::Object#calls_with_object_4" [
        label = "block[id=4](blk: T.untyped)\louterLoops: 1\l<blk>$8: T.untyped = load_yield_params(::Object#calls_with_object#<block>, Object#calls_with_object#<block>)\l<statTemp>$11: <Magic> = alias <constant:<Magic>>\l<statTemp>$12: T.untyped = blk: T.untyped.to_proc()\l<statTemp>$14: Symbol(:\"call\") = :\"call\"\l<blockReturnTemp>$10: T.untyped = <statTemp>$11: <Magic>.<call-with-splat>(<statTemp>$12: T.untyped, <statTemp>$14: Symbol(:\"call\"), <blk>$8: T.untyped)\l<blockReturnTemp>$16: T.noreturn = blockreturn<::Object#calls_with_object#<block>> <blockReturnTemp>$10: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#calls_with_object_4" -> "bb::Object#calls_with_object_2" [style="bold"];
}

subgraph "cluster_::Object#foo" {
    label = "::Object#foo";
    color = blue;
    "bb::Object#foo_0" [shape = invhouse];
    "bb::Object#foo_1" [shape = parallelogram];

    "bb::Object#foo_0" [
        label = "block[id=0]()\l<selfMethodTemp>$3: Object = self\lblk: T.untyped = load_arg(<selfMethodTemp>$3, Object#foo#blk)\l<statTemp>$5: Object = self\l<block-pre-call-temp>$6: T.untyped = <statTemp>$5: Object.calls_with_object()\l<unconditional>\l"
    ];

    "bb::Object#foo_0" -> "bb::Object#foo_2" [style="bold"];
    "bb::Object#foo_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Object#foo_1" -> "bb::Object#foo_1" [style="bold"];
    "bb::Object#foo_2" [
        label = "block[id=2](blk: T.untyped)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#foo_2" -> "bb::Object#foo_4" [style="bold"];
    "bb::Object#foo_2" -> "bb::Object#foo_3" [style="tapered"];

    "bb::Object#foo_3" [
        label = "block[id=3](blk: T.untyped)\l<statTemp>$4: T.untyped = Solve<::Object#foo#<block>>\l<statTemp>$13: Object = self\l<block-pre-call-temp>$14: T.untyped = <statTemp>$13: Object.calls_with_object()\l<unconditional>\l"
    ];

    "bb::Object#foo_3" -> "bb::Object#foo_5" [style="bold"];
    "bb::Object#foo_4" [
        label = "block[id=4](blk: T.untyped)\louterLoops: 1\l<blk>$7: T.untyped = load_yield_params(::Object#foo#<block>, Object#foo#<block>)\l<blk>$8: Integer(0) = 0\l<block-pass>$2$4: T.untyped = <blk>$7: T.untyped.[](<blk>$8: Integer(0))\l<blockReturnTemp>$9: T.untyped = <block-pass>$2$4: T.untyped.meth()\l<blockReturnTemp>$11: T.noreturn = blockreturn<::Object#foo#<block>> <blockReturnTemp>$9: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_4" -> "bb::Object#foo_2" [style="bold"];
    "bb::Object#foo_5" [
        label = "block[id=5](blk: T.untyped)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#foo_5" -> "bb::Object#foo_7" [style="bold"];
    "bb::Object#foo_5" -> "bb::Object#foo_6" [style="tapered"];

    "bb::Object#foo_6" [
        label = "block[id=6](blk: T.untyped)\l<statTemp>$12: T.untyped = Solve<::Object#foo#<block>>\l<statTemp>$26: Object = self\l<block-pre-call-temp>$27: T.untyped = <statTemp>$26: Object.calls_with_object()\l<unconditional>\l"
    ];

    "bb::Object#foo_6" -> "bb::Object#foo_8" [style="bold"];
    "bb::Object#foo_7" [
        label = "block[id=7](blk: T.untyped)\louterLoops: 1\l<blk>$15: T.untyped = load_yield_params(::Object#foo#<block>, Object#foo#<block>)\largs$5: T.untyped = <blk>$15\l<statTemp>$18: <Magic> = alias <constant:<Magic>>\l<statTemp>$20: Symbol(:\"meth\") = :\"meth\"\l<statTemp>$19: Proc = <statTemp>$20: Symbol(:\"meth\").to_proc()\l<statTemp>$21: Symbol(:\"call\") = :\"call\"\l<statTemp>$22: T.untyped = args$5: T.untyped.to_a()\l<blockReturnTemp>$17: T.untyped = <statTemp>$18: <Magic>.<call-with-splat>(<statTemp>$19: Proc, <statTemp>$21: Symbol(:\"call\"), <statTemp>$22: T.untyped)\l<blockReturnTemp>$24: T.noreturn = blockreturn<::Object#foo#<block>> <blockReturnTemp>$17: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_7" -> "bb::Object#foo_5" [style="bold"];
    "bb::Object#foo_8" [
        label = "block[id=8](blk: T.untyped)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#foo_8" -> "bb::Object#foo_10" [style="bold"];
    "bb::Object#foo_8" -> "bb::Object#foo_9" [style="tapered"];

    "bb::Object#foo_9" [
        label = "block[id=9](blk: T.untyped)\l<statTemp>$25: T.untyped = Solve<::Object#foo#<block>>\l<statTemp>$36: Object = self\l<block-pre-call-temp>$37: T.untyped = <statTemp>$36: Object.calls_with_object()\l<unconditional>\l"
    ];

    "bb::Object#foo_9" -> "bb::Object#foo_11" [style="bold"];
    "bb::Object#foo_10" [
        label = "block[id=10](blk: T.untyped)\louterLoops: 1\l<blk>$28: T.untyped = load_yield_params(::Object#foo#<block>, Object#foo#<block>)\l<blk>$29: Integer(0) = 0\lx$6: T.untyped = <blk>$28: T.untyped.[](<blk>$29: Integer(0))\l<statTemp>$32: Symbol(:\"meth\") = :\"meth\"\l<statTemp>$31: Proc = <statTemp>$32: Symbol(:\"meth\").to_proc()\l<blockReturnTemp>$30: T.untyped = <statTemp>$31: Proc.call(x$6: T.untyped)\l<blockReturnTemp>$34: T.noreturn = blockreturn<::Object#foo#<block>> <blockReturnTemp>$30: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_10" -> "bb::Object#foo_8" [style="bold"];
    "bb::Object#foo_11" [
        label = "block[id=11](blk: T.untyped)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#foo_11" -> "bb::Object#foo_13" [style="bold"];
    "bb::Object#foo_11" -> "bb::Object#foo_12" [style="tapered"];

    "bb::Object#foo_12" [
        label = "block[id=12](blk: T.untyped)\l<statTemp>$35: T.untyped = Solve<::Object#foo#<block>>\l<statTemp>$44: Object = self\l<block-pre-call-temp>$45: T.untyped = <statTemp>$44: Object.calls_with_object()\l<unconditional>\l"
    ];

    "bb::Object#foo_12" -> "bb::Object#foo_14" [style="bold"];
    "bb::Object#foo_13" [
        label = "block[id=13](blk: T.untyped)\louterLoops: 1\l<blk>$38: T.untyped = load_yield_params(::Object#foo#<block>, Object#foo#<block>)\l<blk>$39: Integer(0) = 0\lx$7: T.untyped = <blk>$38: T.untyped.[](<blk>$39: Integer(0))\l<blockReturnTemp>$40: T.untyped = x$7: T.untyped.meth()\l<blockReturnTemp>$42: T.noreturn = blockreturn<::Object#foo#<block>> <blockReturnTemp>$40: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_13" -> "bb::Object#foo_11" [style="bold"];
    "bb::Object#foo_14" [
        label = "block[id=14](blk: T.untyped)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#foo_14" -> "bb::Object#foo_16" [style="bold"];
    "bb::Object#foo_14" -> "bb::Object#foo_15" [style="tapered"];

    "bb::Object#foo_15" [
        label = "block[id=15]()\l<statTemp>$43: T.untyped = Solve<::Object#foo#<block>>\l<statTemp>$56: Object = self\l<block-pre-call-temp>$57: T.untyped = <statTemp>$56: Object.calls_with_object()\l<unconditional>\l"
    ];

    "bb::Object#foo_15" -> "bb::Object#foo_17" [style="bold"];
    "bb::Object#foo_16" [
        label = "block[id=16](blk: T.untyped)\louterLoops: 1\l<blk>$46: T.untyped = load_yield_params(::Object#foo#<block>, Object#foo#<block>)\l<statTemp>$49: <Magic> = alias <constant:<Magic>>\l<statTemp>$50: T.untyped = blk: T.untyped.to_proc()\l<statTemp>$52: Symbol(:\"call\") = :\"call\"\l<blockReturnTemp>$48: T.untyped = <statTemp>$49: <Magic>.<call-with-splat>(<statTemp>$50: T.untyped, <statTemp>$52: Symbol(:\"call\"), <blk>$46: T.untyped)\l<blockReturnTemp>$54: T.noreturn = blockreturn<::Object#foo#<block>> <blockReturnTemp>$48: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_16" -> "bb::Object#foo_14" [style="bold"];
    "bb::Object#foo_17" [
        label = "block[id=17]()\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#foo_17" -> "bb::Object#foo_19" [style="bold"];
    "bb::Object#foo_17" -> "bb::Object#foo_18" [style="tapered"];

    "bb::Object#foo_18" [
        label = "block[id=18]()\l<statTemp>$55: T.untyped = Solve<::Object#foo#<block>>\l<statTemp>$69: Object = self\l<block-pre-call-temp>$70: T.untyped = <statTemp>$69: Object.calls_with_object()\l<unconditional>\l"
    ];

    "bb::Object#foo_18" -> "bb::Object#foo_20" [style="bold"];
    "bb::Object#foo_19" [
        label = "block[id=19]()\louterLoops: 1\l<blk>$58: T.untyped = load_yield_params(::Object#foo#<block>, Object#foo#<block>)\l<statTemp>$61: <Magic> = alias <constant:<Magic>>\l<statTemp>$64: Object = self\l<statTemp>$63: T.untyped = <statTemp>$64: Object.returns_lambda()\l<statTemp>$62: T.untyped = <statTemp>$63: T.untyped.to_proc()\l<statTemp>$65: Symbol(:\"call\") = :\"call\"\l<blockReturnTemp>$60: T.untyped = <statTemp>$61: <Magic>.<call-with-splat>(<statTemp>$62: T.untyped, <statTemp>$65: Symbol(:\"call\"), <blk>$58: T.untyped)\l<blockReturnTemp>$67: T.noreturn = blockreturn<::Object#foo#<block>> <blockReturnTemp>$60: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_19" -> "bb::Object#foo_17" [style="bold"];
    "bb::Object#foo_20" [
        label = "block[id=20]()\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#foo_20" -> "bb::Object#foo_22" [style="bold"];
    "bb::Object#foo_20" -> "bb::Object#foo_21" [style="tapered"];

    "bb::Object#foo_21" [
        label = "block[id=21]()\l<statTemp>$68: T.untyped = Solve<::Object#foo#<block>>\l<statTemp>$82: Object = self\l<block-pre-call-temp>$83: T.untyped = <statTemp>$82: Object.calls_with_object()\l<unconditional>\l"
    ];

    "bb::Object#foo_21" -> "bb::Object#foo_23" [style="bold"];
    "bb::Object#foo_22" [
        label = "block[id=22]()\louterLoops: 1\l<blk>$71: T.untyped = load_yield_params(::Object#foo#<block>, Object#foo#<block>)\l<statTemp>$74: <Magic> = alias <constant:<Magic>>\l<statTemp>$77: T.class_of(HasToProc) = alias <constant:HasToProc>\l<statTemp>$76: HasToProc = <statTemp>$77: T.class_of(HasToProc).new()\l<statTemp>$75: T.untyped = <statTemp>$76: HasToProc.to_proc()\l<statTemp>$78: Symbol(:\"call\") = :\"call\"\l<blockReturnTemp>$73: T.untyped = <statTemp>$74: <Magic>.<call-with-splat>(<statTemp>$75: T.untyped, <statTemp>$78: Symbol(:\"call\"), <blk>$71: T.untyped)\l<blockReturnTemp>$80: T.noreturn = blockreturn<::Object#foo#<block>> <blockReturnTemp>$73: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_22" -> "bb::Object#foo_20" [style="bold"];
    "bb::Object#foo_23" [
        label = "block[id=23]()\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#foo_23" -> "bb::Object#foo_25" [style="bold"];
    "bb::Object#foo_23" -> "bb::Object#foo_24" [style="tapered"];

    "bb::Object#foo_24" [
        label = "block[id=24]()\l<statTemp>$81: T.untyped = Solve<::Object#foo#<block>>\l<statTemp>$96: T.class_of(CallsWithObject) = alias <constant:CallsWithObject>\l<block-pre-call-temp>$97: T.untyped = <statTemp>$96: T.class_of(CallsWithObject).calls_with_object()\l<unconditional>\l"
    ];

    "bb::Object#foo_24" -> "bb::Object#foo_26" [style="bold"];
    "bb::Object#foo_25" [
        label = "block[id=25]()\louterLoops: 1\l<blk>$84: T.untyped = load_yield_params(::Object#foo#<block>, Object#foo#<block>)\largs$11: T.untyped = <blk>$84\l<statTemp>$87: <Magic> = alias <constant:<Magic>>\l<statTemp>$90: T.class_of(HasToProc) = alias <constant:HasToProc>\l<statTemp>$89: HasToProc = <statTemp>$90: T.class_of(HasToProc).new()\l<statTemp>$88: T.untyped = <statTemp>$89: HasToProc.to_proc()\l<statTemp>$91: Symbol(:\"call\") = :\"call\"\l<statTemp>$92: T.untyped = args$11: T.untyped.to_a()\l<blockReturnTemp>$86: T.untyped = <statTemp>$87: <Magic>.<call-with-splat>(<statTemp>$88: T.untyped, <statTemp>$91: Symbol(:\"call\"), <statTemp>$92: T.untyped)\l<blockReturnTemp>$94: T.noreturn = blockreturn<::Object#foo#<block>> <blockReturnTemp>$86: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_25" -> "bb::Object#foo_23" [style="bold"];
    "bb::Object#foo_26" [
        label = "block[id=26]()\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#foo_26" -> "bb::Object#foo_28" [style="bold"];
    "bb::Object#foo_26" -> "bb::Object#foo_27" [style="tapered"];

    "bb::Object#foo_27" [
        label = "block[id=27]()\l<statTemp>$95: T.untyped = Solve<::Object#foo#<block>>\l<assignTemp>$7: T.class_of(CallsWithObject) = alias <constant:CallsWithObject>\l<ifTemp>$105: T.any(TrueClass, FalseClass) = <assignTemp>$7: T.class_of(CallsWithObject).nil?()\l<ifTemp>$105: T.any(TrueClass, FalseClass)\l"
    ];

    "bb::Object#foo_27" -> "bb::Object#foo_34" [style="bold"];
    "bb::Object#foo_27" -> "bb::Object#foo_30" [style="tapered"];

    "bb::Object#foo_28" [
        label = "block[id=28]()\louterLoops: 1\l<blk>$98: T.untyped = load_yield_params(::Object#foo#<block>, Object#foo#<block>)\l<blk>$99: Integer(0) = 0\l<block-pass>$6$12: T.untyped = <blk>$98: T.untyped.[](<blk>$99: Integer(0))\l<blockReturnTemp>$100: T.untyped = <block-pass>$6$12: T.untyped.meth()\l<blockReturnTemp>$102: T.noreturn = blockreturn<::Object#foo#<block>> <blockReturnTemp>$100: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_28" -> "bb::Object#foo_26" [style="bold"];
    "bb::Object#foo_30" [
        label = "block[id=30](<assignTemp>$7: T.class_of(CallsWithObject))\l<block-pre-call-temp>$108: T.untyped = <assignTemp>$7: T.class_of(CallsWithObject).calls_with_object()\l<unconditional>\l"
    ];

    "bb::Object#foo_30" -> "bb::Object#foo_31" [style="bold"];
    "bb::Object#foo_31" [
        label = "block[id=31]()\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#foo_31" -> "bb::Object#foo_33" [style="bold"];
    "bb::Object#foo_31" -> "bb::Object#foo_32" [style="tapered"];

    "bb::Object#foo_32" [
        label = "block[id=32]()\l<statTemp>$103: T.untyped = Solve<::Object#foo#<block>>\l<unconditional>\l"
    ];

    "bb::Object#foo_32" -> "bb::Object#foo_34" [style="bold"];
    "bb::Object#foo_33" [
        label = "block[id=33]()\louterLoops: 1\l<blk>$109: T.untyped = load_yield_params(::Object#foo#<block>, Object#foo#<block>)\l<blk>$110: Integer(0) = 0\l<block-pass>$8$13: T.untyped = <blk>$109: T.untyped.[](<blk>$110: Integer(0))\l<blockReturnTemp>$111: T.untyped = <block-pass>$8$13: T.untyped.meth()\l<blockReturnTemp>$113: T.noreturn = blockreturn<::Object#foo#<block>> <blockReturnTemp>$111: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_33" -> "bb::Object#foo_31" [style="bold"];
    "bb::Object#foo_34" [
        label = "block[id=34]()\l<statTemp>$115: T.class_of(CallsWithObjectChild) = alias <constant:CallsWithObjectChild>\l<block-pre-call-temp>$116: T.untyped = <statTemp>$115: T.class_of(CallsWithObjectChild).calls_with_object()\l<unconditional>\l"
    ];

    "bb::Object#foo_34" -> "bb::Object#foo_35" [style="bold"];
    "bb::Object#foo_35" [
        label = "block[id=35]()\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#foo_35" -> "bb::Object#foo_37" [style="bold"];
    "bb::Object#foo_35" -> "bb::Object#foo_36" [style="tapered"];

    "bb::Object#foo_36" [
        label = "block[id=36]()\l<statTemp>$114: T.untyped = Solve<::Object#foo#<block>>\l<statTemp>$123: Object = self\l<statTemp>$125: T.class_of(HasMeth) = alias <constant:HasMeth>\l<statTemp>$124: HasMeth = <statTemp>$125: T.class_of(HasMeth).new()\l<block-pre-call-temp>$126: T.untyped = <statTemp>$123: Object.calls_arg_with_object(<statTemp>$124: HasMeth)\l<unconditional>\l"
    ];

    "bb::Object#foo_36" -> "bb::Object#foo_38" [style="bold"];
    "bb::Object#foo_37" [
        label = "block[id=37]()\louterLoops: 1\l<blk>$117: T.untyped = load_yield_params(::Object#foo#<block>, Object#foo#<block>)\l<blk>$118: Integer(0) = 0\l<block-pass>$9$14: T.untyped = <blk>$117: T.untyped.[](<blk>$118: Integer(0))\l<blockReturnTemp>$119: T.untyped = <block-pass>$9$14: T.untyped.meth()\l<blockReturnTemp>$121: T.noreturn = blockreturn<::Object#foo#<block>> <blockReturnTemp>$119: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_37" -> "bb::Object#foo_35" [style="bold"];
    "bb::Object#foo_38" [
        label = "block[id=38]()\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#foo_38" -> "bb::Object#foo_40" [style="bold"];
    "bb::Object#foo_38" -> "bb::Object#foo_39" [style="tapered"];

    "bb::Object#foo_39" [
        label = "block[id=39]()\l<statTemp>$122: T.untyped = Solve<::Object#foo#<block>>\l<statTemp>$132: Object = self\l<statTemp>$134: T.class_of(HasMeth) = alias <constant:HasMeth>\l<statTemp>$133: HasMeth = <statTemp>$134: T.class_of(HasMeth).new()\l<block-pre-call-temp>$135: T.untyped = <statTemp>$132: Object.calls_arg_with_object(<statTemp>$133: HasMeth)\l<unconditional>\l"
    ];

    "bb::Object#foo_39" -> "bb::Object#foo_41" [style="bold"];
    "bb::Object#foo_40" [
        label = "block[id=40]()\louterLoops: 1\l<blk>$127: T.untyped = load_yield_params(::Object#foo#<block>, Object#foo#<block>)\l<blk>$128: Integer(0) = 0\l<block-pass>$10$15: T.untyped = <blk>$127: T.untyped.[](<blk>$128: Integer(0))\l<blockReturnTemp>$129: T.untyped = <block-pass>$10$15: T.untyped.meth()\l<blockReturnTemp>$131: T.noreturn = blockreturn<::Object#foo#<block>> <blockReturnTemp>$129: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_40" -> "bb::Object#foo_38" [style="bold"];
    "bb::Object#foo_41" [
        label = "block[id=41]()\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::Object#foo_41" -> "bb::Object#foo_43" [style="bold"];
    "bb::Object#foo_41" -> "bb::Object#foo_42" [style="tapered"];

    "bb::Object#foo_42" [
        label = "block[id=42]()\l<returnMethodTemp>$2: T.untyped = Solve<::Object#foo#<block>>\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_42" -> "bb::Object#foo_1" [style="bold"];
    "bb::Object#foo_43" [
        label = "block[id=43]()\louterLoops: 1\l<blk>$136: T.untyped = load_yield_params(::Object#foo#<block>, Object#foo#<block>)\l<blk>$137: Integer(0) = 0\lx$16: T.untyped = <blk>$136: T.untyped.[](<blk>$137: Integer(0))\l<blockReturnTemp>$138: T.untyped = x$16: T.untyped.meth()\l<blockReturnTemp>$140: T.noreturn = blockreturn<::Object#foo#<block>> <blockReturnTemp>$138: T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_43" -> "bb::Object#foo_41" [style="bold"];
}

subgraph "cluster_#<static-init>" {
    label = "#<static-init>";
    color = blue;
    "bb#<static-init>_0" [shape = invhouse];
    "bb#<static-init>_1" [shape = parallelogram];

    "bb#<static-init>_0" [
        label = "block[id=0]()\l<statTemp>$6: T.class_of(RubyTyper) = alias <constant:RubyTyper>\l<statTemp>$7: T.class_of(HasMeth) = alias <constant:HasMeth>\l<statTemp>$5: RubyTyper::Void = <statTemp>$6: T.class_of(RubyTyper).keep_for_ide(<statTemp>$7: T.class_of(HasMeth))\l<statTemp>$10: T.class_of(RubyTyper) = alias <constant:RubyTyper>\l<statTemp>$11: T.class_of(HasToProc) = alias <constant:HasToProc>\l<statTemp>$9: RubyTyper::Void = <statTemp>$10: T.class_of(RubyTyper).keep_for_ide(<statTemp>$11: T.class_of(HasToProc))\l<statTemp>$14: T.class_of(RubyTyper) = alias <constant:RubyTyper>\l<statTemp>$15: T.class_of(CallsWithObject) = alias <constant:CallsWithObject>\l<statTemp>$13: RubyTyper::Void = <statTemp>$14: T.class_of(RubyTyper).keep_for_ide(<statTemp>$15: T.class_of(CallsWithObject))\l<statTemp>$18: T.class_of(RubyTyper) = alias <constant:RubyTyper>\l<statTemp>$19: T.class_of(CallsWithObjectChild) = alias <constant:CallsWithObjectChild>\l<statTemp>$17: RubyTyper::Void = <statTemp>$18: T.class_of(RubyTyper).keep_for_ide(<statTemp>$19: T.class_of(CallsWithObjectChild))\l<statTemp>$21: T.class_of(RubyTyper) = alias <constant:RubyTyper>\l<statTemp>$22: T.class_of(CallsWithObject) = alias <constant:CallsWithObject>\l<statTemp>$20: RubyTyper::Void = <statTemp>$21: T.class_of(RubyTyper).keep_for_ide(<statTemp>$22: T.class_of(CallsWithObject))\l<statTemp>$24: T.class_of(<root>) = self\l<block-pre-call-temp>$25: T.untyped = <statTemp>$24: T.class_of(<root>).foo()\l<unconditional>\l"
    ];

    "bb#<static-init>_0" -> "bb#<static-init>_2" [style="bold"];
    "bb#<static-init>_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb#<static-init>_1" -> "bb#<static-init>_1" [style="bold"];
    "bb#<static-init>_2" [
        label = "block[id=2]()\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb#<static-init>_2" -> "bb#<static-init>_4" [style="bold"];
    "bb#<static-init>_2" -> "bb#<static-init>_3" [style="tapered"];

    "bb#<static-init>_3" [
        label = "block[id=3]()\l<statTemp>$23: T.untyped = Solve<#<static-init>#<block>>\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb#<static-init>_3" -> "bb#<static-init>_1" [style="bold"];
    "bb#<static-init>_4" [
        label = "block[id=4]()\louterLoops: 1\l<blk>$26: T.untyped = load_yield_params(#<static-init>#<block>, <static-init>#<block>)\l<blk>$27: Integer(0) = 0\lx$17: T.untyped = <blk>$26: T.untyped.[](<blk>$27: Integer(0))\l<blockReturnTemp>$28: String(\"foo\") = \"foo\"\l<blockReturnTemp>$29: T.noreturn = blockreturn<#<static-init>#<block>> <blockReturnTemp>$28: String(\"foo\")\l<unconditional>\l"
    ];

    "bb#<static-init>_4" -> "bb#<static-init>_2" [style="bold"];
}

subgraph "cluster_::HasMeth#meth" {
    label = "::HasMeth#meth";
    color = blue;
    "bb::HasMeth#meth_0" [shape = invhouse];
    "bb::HasMeth#meth_1" [shape = parallelogram];

    "bb::HasMeth#meth_0" [
        label = "block[id=0]()\l<returnMethodTemp>$2: String(\"meth\") = \"meth\"\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: String(\"meth\")\l<unconditional>\l"
    ];

    "bb::HasMeth#meth_0" -> "bb::HasMeth#meth_1" [style="bold"];
    "bb::HasMeth#meth_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::HasMeth#meth_1" -> "bb::HasMeth#meth_1" [style="bold"];
}

subgraph "cluster_::HasToProc#to_proc" {
    label = "::HasToProc#to_proc";
    color = blue;
    "bb::HasToProc#to_proc_0" [shape = invhouse];
    "bb::HasToProc#to_proc_1" [shape = parallelogram];

    "bb::HasToProc#to_proc_0" [
        label = "block[id=0]()\l<statTemp>$4: HasToProc = self\l<returnMethodTemp>$2: T.untyped = <statTemp>$4: HasToProc.returns_lambda()\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::HasToProc#to_proc_0" -> "bb::HasToProc#to_proc_1" [style="bold"];
    "bb::HasToProc#to_proc_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::HasToProc#to_proc_1" -> "bb::HasToProc#to_proc_1" [style="bold"];
}

subgraph "cluster_::<Class:CallsWithObject>#calls_with_object" {
    label = "::<Class:CallsWithObject>#calls_with_object";
    color = blue;
    "bb::<Class:CallsWithObject>#calls_with_object_0" [shape = invhouse];
    "bb::<Class:CallsWithObject>#calls_with_object_1" [shape = parallelogram];

    "bb::<Class:CallsWithObject>#calls_with_object_0" [
        label = "block[id=0]()\l<selfMethodTemp>$3: T.class_of(CallsWithObject) = self\lblk: T.untyped = load_arg(<selfMethodTemp>$3, CallsWithObject.calls_with_object#blk)\l<statTemp>$6: T.class_of(HasMeth) = alias <constant:HasMeth>\l<statTemp>$5: HasMeth = <statTemp>$6: T.class_of(HasMeth).new()\l<returnMethodTemp>$2: T.untyped = blk: T.untyped.call(<statTemp>$5: HasMeth)\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:CallsWithObject>#calls_with_object_0" -> "bb::<Class:CallsWithObject>#calls_with_object_1" [style="bold"];
    "bb::<Class:CallsWithObject>#calls_with_object_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:CallsWithObject>#calls_with_object_1" -> "bb::<Class:CallsWithObject>#calls_with_object_1" [style="bold"];
}

subgraph "cluster_::<Class:CallsWithObjectChild>#calls_with_object" {
    label = "::<Class:CallsWithObjectChild>#calls_with_object";
    color = blue;
    "bb::<Class:CallsWithObjectChild>#calls_with_object_0" [shape = invhouse];
    "bb::<Class:CallsWithObjectChild>#calls_with_object_1" [shape = parallelogram];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_0" [
        label = "block[id=0]()\l<selfMethodTemp>$3: T.class_of(CallsWithObjectChild) = self\lblk: T.untyped = load_arg(<selfMethodTemp>$3, CallsWithObjectChild.calls_with_object#blk)\l<statTemp>$4: T.class_of(CallsWithObjectChild) = self\l<block-pre-call-temp>$5: T.untyped = <statTemp>$4: T.class_of(CallsWithObjectChild).super()\l<unconditional>\l"
    ];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_0" -> "bb::<Class:CallsWithObjectChild>#calls_with_object_2" [style="bold"];
    "bb::<Class:CallsWithObjectChild>#calls_with_object_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_1" -> "bb::<Class:CallsWithObjectChild>#calls_with_object_1" [style="bold"];
    "bb::<Class:CallsWithObjectChild>#calls_with_object_2" [
        label = "block[id=2](blk: T.untyped)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_2" -> "bb::<Class:CallsWithObjectChild>#calls_with_object_4" [style="bold"];
    "bb::<Class:CallsWithObjectChild>#calls_with_object_2" -> "bb::<Class:CallsWithObjectChild>#calls_with_object_3" [style="tapered"];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_3" [
        label = "block[id=3]()\l<returnMethodTemp>$2: T.untyped = Solve<::<Class:CallsWithObjectChild>#calls_with_object#<block>>\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_3" -> "bb::<Class:CallsWithObjectChild>#calls_with_object_1" [style="bold"];
    "bb::<Class:CallsWithObjectChild>#calls_with_object_4" [
        label = "block[id=4](blk: T.untyped)\louterLoops: 1\l<blk>$6: T.untyped = load_yield_params(::<Class:CallsWithObjectChild>#calls_with_object#<block>, CallsWithObjectChild.calls_with_object#<block>)\l<statTemp>$9: <Magic> = alias <constant:<Magic>>\l<statTemp>$10: T.untyped = blk: T.untyped.to_proc()\l<statTemp>$12: Symbol(:\"call\") = :\"call\"\l<blockReturnTemp>$8: T.untyped = <statTemp>$9: <Magic>.<call-with-splat>(<statTemp>$10: T.untyped, <statTemp>$12: Symbol(:\"call\"), <blk>$6: T.untyped)\l<blockReturnTemp>$14: T.noreturn = blockreturn<::<Class:CallsWithObjectChild>#calls_with_object#<block>> <blockReturnTemp>$8: T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_4" -> "bb::<Class:CallsWithObjectChild>#calls_with_object_2" [style="bold"];
}

}

