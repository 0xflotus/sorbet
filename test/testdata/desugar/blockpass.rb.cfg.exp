digraph "blockpass.rb" {
subgraph "cluster_::Object#returns_lambda" {
    label = "::Object#returns_lambda";
    color = blue;
    "bb::Object#returns_lambda_0" [shape = invhouse];
    "bb::Object#returns_lambda_1" [shape = parallelogram];

    "bb::Object#returns_lambda_0" [
        label = "block[id=0]()\l<statTemp>$4 = self : Object\l<block-pre-call-temp>$5 = <statTemp>$4.lambda() : Proc\l<unconditional>\l"
    ];

    "bb::Object#returns_lambda_0" -> "bb::Object#returns_lambda_2" [style="bold"];
    "bb::Object#returns_lambda_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Object#returns_lambda_1" -> "bb::Object#returns_lambda_1" [style="bold"];
    "bb::Object#returns_lambda_2" [
        label = "block[id=2]()\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#returns_lambda_2" -> "bb::Object#returns_lambda_4" [style="bold"];
    "bb::Object#returns_lambda_2" -> "bb::Object#returns_lambda_3" [style="tapered"];

    "bb::Object#returns_lambda_3" [
        label = "block[id=3]()\l<returnMethodTemp>$2 = Solve<::Object#returns_lambda#<block>> : Proc\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#returns_lambda_3" -> "bb::Object#returns_lambda_1" [style="bold"];
    "bb::Object#returns_lambda_4" [
        label = "block[id=4]()\louterLoops: 1\l<blk>$6 = load_yield_params(::Object#returns_lambda#<block>, Object#returns_lambda#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$7 = 0 : Integer(0)\lx$3 = <blk>$6.[](<blk>$7) : T.untyped\l<blockReturnTemp>$8 = \"returns_lambda\" : String(\"returns_lambda\")\l<blockReturnTemp>$9 = blockreturn<::Object#returns_lambda#<block>> <blockReturnTemp>$8 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#returns_lambda_4" -> "bb::Object#returns_lambda_2" [style="bold"];
}

subgraph "cluster_::Object#calls_arg_with_object" {
    label = "::Object#calls_arg_with_object";
    color = blue;
    "bb::Object#calls_arg_with_object_0" [shape = invhouse];
    "bb::Object#calls_arg_with_object_1" [shape = parallelogram];

    "bb::Object#calls_arg_with_object_0" [
        label = "block[id=0]()\l<selfMethodTemp>$3 = self : Object\larg = load_arg(<selfMethodTemp>$3#calls_arg_with_object, 0) : T.untyped\lblk = load_arg(<selfMethodTemp>$3#calls_arg_with_object, 1) : T.untyped\l<returnMethodTemp>$2 = blk.call(arg) : T.untyped\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#calls_arg_with_object_0" -> "bb::Object#calls_arg_with_object_1" [style="bold"];
    "bb::Object#calls_arg_with_object_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Object#calls_arg_with_object_1" -> "bb::Object#calls_arg_with_object_1" [style="bold"];
}

subgraph "cluster_::Object#calls_with_object" {
    label = "::Object#calls_with_object";
    color = blue;
    "bb::Object#calls_with_object_0" [shape = invhouse];
    "bb::Object#calls_with_object_1" [shape = parallelogram];

    "bb::Object#calls_with_object_0" [
        label = "block[id=0]()\l<constant:<Magic>>$16 = alias <constant:<Magic>> : <Magic>\l<constant:HasMeth>$7 = alias <constant:HasMeth> : <Class:HasMeth>\l<selfMethodTemp>$3 = self : Object\lblk = load_arg(<selfMethodTemp>$3#calls_with_object, 0) : T.untyped\l<statTemp>$4 = self : Object\l<statTemp>$5 = <constant:HasMeth>$7.new() : HasMeth\l<block-pre-call-temp>$8 = <statTemp>$4.calls_arg_with_object(<statTemp>$5) : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#calls_with_object_0" -> "bb::Object#calls_with_object_2" [style="bold"];
    "bb::Object#calls_with_object_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Object#calls_with_object_1" -> "bb::Object#calls_with_object_1" [style="bold"];
    "bb::Object#calls_with_object_2" [
        label = "block[id=2](<constant:<Magic>>$16, blk)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#calls_with_object_2" -> "bb::Object#calls_with_object_4" [style="bold"];
    "bb::Object#calls_with_object_2" -> "bb::Object#calls_with_object_3" [style="tapered"];

    "bb::Object#calls_with_object_3" [
        label = "block[id=3]()\l<returnMethodTemp>$2 = Solve<::Object#calls_with_object#<block>> : T.untyped\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#calls_with_object_3" -> "bb::Object#calls_with_object_1" [style="bold"];
    "bb::Object#calls_with_object_4" [
        label = "block[id=4](<constant:<Magic>>$16, blk)\louterLoops: 1\l<blk>$9 = load_yield_params(::Object#calls_with_object#<block>, Object#calls_with_object#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$10 = 0 : Integer(0)\l<block-pass>$2$4 = <blk>$9.[](<blk>$10) : T.untyped\l<statTemp>$12 = blk.to_proc() : T.untyped\l<statTemp>$17 = <block-pass>$2$4.to_a() : T.untyped\l<statTemp>$14 = <constant:<Magic>>$16.<splat>(<statTemp>$17) : T.untyped\l<blockReturnTemp>$11 = <statTemp>$12.call(<statTemp>$14) : T.untyped\l<blockReturnTemp>$19 = blockreturn<::Object#calls_with_object#<block>> <blockReturnTemp>$11 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#calls_with_object_4" -> "bb::Object#calls_with_object_2" [style="bold"];
}

subgraph "cluster_::Object#foo" {
    label = "::Object#foo";
    color = blue;
    "bb::Object#foo_0" [shape = invhouse];
    "bb::Object#foo_1" [shape = parallelogram];

    "bb::Object#foo_0" [
        label = "block[id=0]()\l<constant:<Magic>>$22 = alias <constant:<Magic>> : <Magic>\l<constant:HasMeth>$133 = alias <constant:HasMeth> : <Class:HasMeth>\l<constant:HasToProc>$80 = alias <constant:HasToProc> : <Class:HasToProc>\l<constant:CallsWithObject>$102 = alias <constant:CallsWithObject> : <Class:CallsWithObject>\l<constant:CallsWithObjectChild>$122 = alias <constant:CallsWithObjectChild> : <Class:CallsWithObjectChild>\l<selfMethodTemp>$3 = self : Object\lblk = load_arg(<selfMethodTemp>$3#foo, 0) : T.untyped\l<statTemp>$5 = self : Object\l<block-pre-call-temp>$6 = <statTemp>$5.calls_with_object() : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_0" -> "bb::Object#foo_2" [style="bold"];
    "bb::Object#foo_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Object#foo_1" -> "bb::Object#foo_1" [style="bold"];
    "bb::Object#foo_2" [
        label = "block[id=2](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#foo_2" -> "bb::Object#foo_4" [style="bold"];
    "bb::Object#foo_2" -> "bb::Object#foo_3" [style="tapered"];

    "bb::Object#foo_3" [
        label = "block[id=3](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\l<statTemp>$4 = Solve<::Object#foo#<block>> : T.untyped\l<statTemp>$13 = self : Object\l<block-pre-call-temp>$14 = <statTemp>$13.calls_with_object() : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_3" -> "bb::Object#foo_5" [style="bold"];
    "bb::Object#foo_4" [
        label = "block[id=4](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<blk>$7 = load_yield_params(::Object#foo#<block>, Object#foo#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$8 = 0 : Integer(0)\l<block-pass>$2$4 = <blk>$7.[](<blk>$8) : T.untyped\l<blockReturnTemp>$9 = <block-pass>$2$4.meth() : T.untyped\l<blockReturnTemp>$11 = blockreturn<::Object#foo#<block>> <blockReturnTemp>$9 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_4" -> "bb::Object#foo_2" [style="bold"];
    "bb::Object#foo_5" [
        label = "block[id=5](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#foo_5" -> "bb::Object#foo_7" [style="bold"];
    "bb::Object#foo_5" -> "bb::Object#foo_6" [style="tapered"];

    "bb::Object#foo_6" [
        label = "block[id=6](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\l<statTemp>$12 = Solve<::Object#foo#<block>> : T.untyped\l<statTemp>$27 = self : Object\l<block-pre-call-temp>$28 = <statTemp>$27.calls_with_object() : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_6" -> "bb::Object#foo_8" [style="bold"];
    "bb::Object#foo_7" [
        label = "block[id=7](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<blk>$15 = load_yield_params(::Object#foo#<block>, Object#foo#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$16 = 0 : Integer(0)\largs$5 = <blk>$15.[](<blk>$16) : T.untyped\l<statTemp>$19 = :\"meth\" : Symbol(:\"meth\")\l<statTemp>$18 = <statTemp>$19.to_proc() : Proc\l<statTemp>$23 = args$5.to_a() : T.untyped\l<statTemp>$20 = <constant:<Magic>>$22.<splat>(<statTemp>$23) : T.untyped\l<blockReturnTemp>$17 = <statTemp>$18.call(<statTemp>$20) : T.untyped\l<blockReturnTemp>$25 = blockreturn<::Object#foo#<block>> <blockReturnTemp>$17 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_7" -> "bb::Object#foo_5" [style="bold"];
    "bb::Object#foo_8" [
        label = "block[id=8](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#foo_8" -> "bb::Object#foo_10" [style="bold"];
    "bb::Object#foo_8" -> "bb::Object#foo_9" [style="tapered"];

    "bb::Object#foo_9" [
        label = "block[id=9](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\l<statTemp>$26 = Solve<::Object#foo#<block>> : T.untyped\l<statTemp>$37 = self : Object\l<block-pre-call-temp>$38 = <statTemp>$37.calls_with_object() : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_9" -> "bb::Object#foo_11" [style="bold"];
    "bb::Object#foo_10" [
        label = "block[id=10](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<blk>$29 = load_yield_params(::Object#foo#<block>, Object#foo#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$30 = 0 : Integer(0)\lx$6 = <blk>$29.[](<blk>$30) : T.untyped\l<statTemp>$33 = :\"meth\" : Symbol(:\"meth\")\l<statTemp>$32 = <statTemp>$33.to_proc() : Proc\l<blockReturnTemp>$31 = <statTemp>$32.call(x$6) : T.untyped\l<blockReturnTemp>$35 = blockreturn<::Object#foo#<block>> <blockReturnTemp>$31 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_10" -> "bb::Object#foo_8" [style="bold"];
    "bb::Object#foo_11" [
        label = "block[id=11](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#foo_11" -> "bb::Object#foo_13" [style="bold"];
    "bb::Object#foo_11" -> "bb::Object#foo_12" [style="tapered"];

    "bb::Object#foo_12" [
        label = "block[id=12](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\l<statTemp>$36 = Solve<::Object#foo#<block>> : T.untyped\l<statTemp>$45 = self : Object\l<block-pre-call-temp>$46 = <statTemp>$45.calls_with_object() : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_12" -> "bb::Object#foo_14" [style="bold"];
    "bb::Object#foo_13" [
        label = "block[id=13](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<blk>$39 = load_yield_params(::Object#foo#<block>, Object#foo#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$40 = 0 : Integer(0)\lx$7 = <blk>$39.[](<blk>$40) : T.untyped\l<blockReturnTemp>$41 = x$7.meth() : T.untyped\l<blockReturnTemp>$43 = blockreturn<::Object#foo#<block>> <blockReturnTemp>$41 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_13" -> "bb::Object#foo_11" [style="bold"];
    "bb::Object#foo_14" [
        label = "block[id=14](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#foo_14" -> "bb::Object#foo_16" [style="bold"];
    "bb::Object#foo_14" -> "bb::Object#foo_15" [style="tapered"];

    "bb::Object#foo_15" [
        label = "block[id=15](<constant:<Magic>>$22, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\l<statTemp>$44 = Solve<::Object#foo#<block>> : T.untyped\l<statTemp>$58 = self : Object\l<block-pre-call-temp>$59 = <statTemp>$58.calls_with_object() : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_15" -> "bb::Object#foo_17" [style="bold"];
    "bb::Object#foo_16" [
        label = "block[id=16](<constant:<Magic>>$22, blk, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<blk>$47 = load_yield_params(::Object#foo#<block>, Object#foo#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$48 = 0 : Integer(0)\l<block-pass>$3$8 = <blk>$47.[](<blk>$48) : T.untyped\l<statTemp>$50 = blk.to_proc() : T.untyped\l<statTemp>$54 = <block-pass>$3$8.to_a() : T.untyped\l<statTemp>$52 = <constant:<Magic>>$22.<splat>(<statTemp>$54) : T.untyped\l<blockReturnTemp>$49 = <statTemp>$50.call(<statTemp>$52) : T.untyped\l<blockReturnTemp>$56 = blockreturn<::Object#foo#<block>> <blockReturnTemp>$49 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_16" -> "bb::Object#foo_14" [style="bold"];
    "bb::Object#foo_17" [
        label = "block[id=17](<constant:<Magic>>$22, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#foo_17" -> "bb::Object#foo_19" [style="bold"];
    "bb::Object#foo_17" -> "bb::Object#foo_18" [style="tapered"];

    "bb::Object#foo_18" [
        label = "block[id=18](<constant:<Magic>>$22, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\l<statTemp>$57 = Solve<::Object#foo#<block>> : T.untyped\l<statTemp>$72 = self : Object\l<block-pre-call-temp>$73 = <statTemp>$72.calls_with_object() : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_18" -> "bb::Object#foo_20" [style="bold"];
    "bb::Object#foo_19" [
        label = "block[id=19](<constant:<Magic>>$22, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<blk>$60 = load_yield_params(::Object#foo#<block>, Object#foo#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$61 = 0 : Integer(0)\l<block-pass>$4$9 = <blk>$60.[](<blk>$61) : T.untyped\l<statTemp>$65 = self : Object\l<statTemp>$64 = <statTemp>$65.returns_lambda() : T.untyped\l<statTemp>$63 = <statTemp>$64.to_proc() : T.untyped\l<statTemp>$68 = <block-pass>$4$9.to_a() : T.untyped\l<statTemp>$66 = <constant:<Magic>>$22.<splat>(<statTemp>$68) : T.untyped\l<blockReturnTemp>$62 = <statTemp>$63.call(<statTemp>$66) : T.untyped\l<blockReturnTemp>$70 = blockreturn<::Object#foo#<block>> <blockReturnTemp>$62 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_19" -> "bb::Object#foo_17" [style="bold"];
    "bb::Object#foo_20" [
        label = "block[id=20](<constant:<Magic>>$22, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#foo_20" -> "bb::Object#foo_22" [style="bold"];
    "bb::Object#foo_20" -> "bb::Object#foo_21" [style="tapered"];

    "bb::Object#foo_21" [
        label = "block[id=21](<constant:<Magic>>$22, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\l<statTemp>$71 = Solve<::Object#foo#<block>> : T.untyped\l<statTemp>$87 = self : Object\l<block-pre-call-temp>$88 = <statTemp>$87.calls_with_object() : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_21" -> "bb::Object#foo_23" [style="bold"];
    "bb::Object#foo_22" [
        label = "block[id=22](<constant:<Magic>>$22, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<blk>$74 = load_yield_params(::Object#foo#<block>, Object#foo#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$75 = 0 : Integer(0)\l<block-pass>$5$10 = <blk>$74.[](<blk>$75) : T.untyped\l<statTemp>$78 = <constant:HasToProc>$80.new() : HasToProc\l<statTemp>$77 = <statTemp>$78.to_proc() : T.untyped\l<statTemp>$83 = <block-pass>$5$10.to_a() : T.untyped\l<statTemp>$81 = <constant:<Magic>>$22.<splat>(<statTemp>$83) : T.untyped\l<blockReturnTemp>$76 = <statTemp>$77.call(<statTemp>$81) : T.untyped\l<blockReturnTemp>$85 = blockreturn<::Object#foo#<block>> <blockReturnTemp>$76 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_22" -> "bb::Object#foo_20" [style="bold"];
    "bb::Object#foo_23" [
        label = "block[id=23](<constant:<Magic>>$22, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#foo_23" -> "bb::Object#foo_25" [style="bold"];
    "bb::Object#foo_23" -> "bb::Object#foo_24" [style="tapered"];

    "bb::Object#foo_24" [
        label = "block[id=24](<constant:HasMeth>$133, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\l<statTemp>$86 = Solve<::Object#foo#<block>> : T.untyped\l<block-pre-call-temp>$103 = <constant:CallsWithObject>$102.calls_with_object() : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_24" -> "bb::Object#foo_26" [style="bold"];
    "bb::Object#foo_25" [
        label = "block[id=25](<constant:<Magic>>$22, <constant:HasMeth>$133, <constant:HasToProc>$80, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<blk>$89 = load_yield_params(::Object#foo#<block>, Object#foo#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$90 = 0 : Integer(0)\largs$11 = <blk>$89.[](<blk>$90) : T.untyped\l<statTemp>$93 = <constant:HasToProc>$80.new() : HasToProc\l<statTemp>$92 = <statTemp>$93.to_proc() : T.untyped\l<statTemp>$97 = args$11.to_a() : T.untyped\l<statTemp>$95 = <constant:<Magic>>$22.<splat>(<statTemp>$97) : T.untyped\l<blockReturnTemp>$91 = <statTemp>$92.call(<statTemp>$95) : T.untyped\l<blockReturnTemp>$99 = blockreturn<::Object#foo#<block>> <blockReturnTemp>$91 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_25" -> "bb::Object#foo_23" [style="bold"];
    "bb::Object#foo_26" [
        label = "block[id=26](<constant:HasMeth>$133, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#foo_26" -> "bb::Object#foo_28" [style="bold"];
    "bb::Object#foo_26" -> "bb::Object#foo_27" [style="tapered"];

    "bb::Object#foo_27" [
        label = "block[id=27](<constant:HasMeth>$133, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\l<statTemp>$100 = Solve<::Object#foo#<block>> : T.untyped\l<ifTemp>$111 = <constant:CallsWithObject>$102.nil?() : TrueClass | FalseClass\l<ifTemp>$111\l"
    ];

    "bb::Object#foo_27" -> "bb::Object#foo_34" [style="bold"];
    "bb::Object#foo_27" -> "bb::Object#foo_30" [style="tapered"];

    "bb::Object#foo_28" [
        label = "block[id=28](<constant:HasMeth>$133, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<blk>$104 = load_yield_params(::Object#foo#<block>, Object#foo#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$105 = 0 : Integer(0)\l<block-pass>$6$12 = <blk>$104.[](<blk>$105) : T.untyped\l<blockReturnTemp>$106 = <block-pass>$6$12.meth() : T.untyped\l<blockReturnTemp>$108 = blockreturn<::Object#foo#<block>> <blockReturnTemp>$106 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_28" -> "bb::Object#foo_26" [style="bold"];
    "bb::Object#foo_30" [
        label = "block[id=30](<constant:HasMeth>$133, <constant:CallsWithObject>$102, <constant:CallsWithObjectChild>$122)\l<block-pre-call-temp>$114 = <constant:CallsWithObject>$102.calls_with_object() : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_30" -> "bb::Object#foo_31" [style="bold"];
    "bb::Object#foo_31" [
        label = "block[id=31](<constant:HasMeth>$133, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#foo_31" -> "bb::Object#foo_33" [style="bold"];
    "bb::Object#foo_31" -> "bb::Object#foo_32" [style="tapered"];

    "bb::Object#foo_32" [
        label = "block[id=32](<constant:HasMeth>$133, <constant:CallsWithObjectChild>$122)\l<statTemp>$109 = Solve<::Object#foo#<block>> : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_32" -> "bb::Object#foo_34" [style="bold"];
    "bb::Object#foo_33" [
        label = "block[id=33](<constant:HasMeth>$133, <constant:CallsWithObjectChild>$122)\louterLoops: 1\l<blk>$115 = load_yield_params(::Object#foo#<block>, Object#foo#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$116 = 0 : Integer(0)\l<block-pass>$8$13 = <blk>$115.[](<blk>$116) : T.untyped\l<blockReturnTemp>$117 = <block-pass>$8$13.meth() : T.untyped\l<blockReturnTemp>$119 = blockreturn<::Object#foo#<block>> <blockReturnTemp>$117 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_33" -> "bb::Object#foo_31" [style="bold"];
    "bb::Object#foo_34" [
        label = "block[id=34](<constant:HasMeth>$133, <constant:CallsWithObjectChild>$122)\l<block-pre-call-temp>$123 = <constant:CallsWithObjectChild>$122.calls_with_object() : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_34" -> "bb::Object#foo_35" [style="bold"];
    "bb::Object#foo_35" [
        label = "block[id=35](<constant:HasMeth>$133)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#foo_35" -> "bb::Object#foo_37" [style="bold"];
    "bb::Object#foo_35" -> "bb::Object#foo_36" [style="tapered"];

    "bb::Object#foo_36" [
        label = "block[id=36](<constant:HasMeth>$133)\l<statTemp>$120 = Solve<::Object#foo#<block>> : T.untyped\l<statTemp>$130 = self : Object\l<statTemp>$131 = <constant:HasMeth>$133.new() : HasMeth\l<block-pre-call-temp>$134 = <statTemp>$130.calls_arg_with_object(<statTemp>$131) : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_36" -> "bb::Object#foo_38" [style="bold"];
    "bb::Object#foo_37" [
        label = "block[id=37](<constant:HasMeth>$133)\louterLoops: 1\l<blk>$124 = load_yield_params(::Object#foo#<block>, Object#foo#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$125 = 0 : Integer(0)\l<block-pass>$9$14 = <blk>$124.[](<blk>$125) : T.untyped\l<blockReturnTemp>$126 = <block-pass>$9$14.meth() : T.untyped\l<blockReturnTemp>$128 = blockreturn<::Object#foo#<block>> <blockReturnTemp>$126 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_37" -> "bb::Object#foo_35" [style="bold"];
    "bb::Object#foo_38" [
        label = "block[id=38](<constant:HasMeth>$133)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#foo_38" -> "bb::Object#foo_40" [style="bold"];
    "bb::Object#foo_38" -> "bb::Object#foo_39" [style="tapered"];

    "bb::Object#foo_39" [
        label = "block[id=39](<constant:HasMeth>$133)\l<statTemp>$129 = Solve<::Object#foo#<block>> : T.untyped\l<statTemp>$140 = self : Object\l<statTemp>$141 = <constant:HasMeth>$133.new() : HasMeth\l<block-pre-call-temp>$143 = <statTemp>$140.calls_arg_with_object(<statTemp>$141) : T.untyped\l<unconditional>\l"
    ];

    "bb::Object#foo_39" -> "bb::Object#foo_41" [style="bold"];
    "bb::Object#foo_40" [
        label = "block[id=40](<constant:HasMeth>$133)\louterLoops: 1\l<blk>$135 = load_yield_params(::Object#foo#<block>, Object#foo#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$136 = 0 : Integer(0)\l<block-pass>$10$15 = <blk>$135.[](<blk>$136) : T.untyped\l<blockReturnTemp>$137 = <block-pass>$10$15.meth() : T.untyped\l<blockReturnTemp>$139 = blockreturn<::Object#foo#<block>> <blockReturnTemp>$137 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_40" -> "bb::Object#foo_38" [style="bold"];
    "bb::Object#foo_41" [
        label = "block[id=41]()\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Object#foo_41" -> "bb::Object#foo_43" [style="bold"];
    "bb::Object#foo_41" -> "bb::Object#foo_42" [style="tapered"];

    "bb::Object#foo_42" [
        label = "block[id=42]()\l<returnMethodTemp>$2 = Solve<::Object#foo#<block>> : T.untyped\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_42" -> "bb::Object#foo_1" [style="bold"];
    "bb::Object#foo_43" [
        label = "block[id=43]()\louterLoops: 1\l<blk>$144 = load_yield_params(::Object#foo#<block>, Object#foo#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$145 = 0 : Integer(0)\lx$16 = <blk>$144.[](<blk>$145) : T.untyped\l<blockReturnTemp>$146 = x$16.meth() : T.untyped\l<blockReturnTemp>$148 = blockreturn<::Object#foo#<block>> <blockReturnTemp>$146 : <impossible>\l<unconditional>\l"
    ];

    "bb::Object#foo_43" -> "bb::Object#foo_41" [style="bold"];
}

subgraph "cluster_#<static-init>" {
    label = "#<static-init>";
    color = blue;
    "bb#<static-init>_0" [shape = invhouse];
    "bb#<static-init>_1" [shape = parallelogram];

    "bb#<static-init>_0" [
        label = "block[id=0]()\l<constant:RubyTyper>$7 = alias <constant:RubyTyper> : <Class:RubyTyper>\l<constant:HasMeth>$9 = alias <constant:HasMeth> : <Class:HasMeth>\l<constant:HasToProc>$14 = alias <constant:HasToProc> : <Class:HasToProc>\l<constant:CallsWithObject>$19 = alias <constant:CallsWithObject> : <Class:CallsWithObject>\l<constant:CallsWithObjectChild>$24 = alias <constant:CallsWithObjectChild> : <Class:CallsWithObjectChild>\l<statTemp>$5 = <constant:RubyTyper>$7.keep_for_ide(<constant:HasMeth>$9) : T.untyped\l<statTemp>$11 = <constant:RubyTyper>$7.keep_for_ide(<constant:HasToProc>$14) : T.untyped\l<statTemp>$16 = <constant:RubyTyper>$7.keep_for_ide(<constant:CallsWithObject>$19) : T.untyped\l<statTemp>$21 = <constant:RubyTyper>$7.keep_for_ide(<constant:CallsWithObjectChild>$24) : T.untyped\l<statTemp>$25 = <constant:RubyTyper>$7.keep_for_ide(<constant:CallsWithObject>$19) : T.untyped\l<statTemp>$29 = self : <Class:<root>>\l<block-pre-call-temp>$30 = <statTemp>$29.foo() : T.untyped\l<unconditional>\l"
    ];

    "bb#<static-init>_0" -> "bb#<static-init>_2" [style="bold"];
    "bb#<static-init>_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb#<static-init>_1" -> "bb#<static-init>_1" [style="bold"];
    "bb#<static-init>_2" [
        label = "block[id=2]()\louterLoops: 1\l<block-call>\l"
    ];

    "bb#<static-init>_2" -> "bb#<static-init>_4" [style="bold"];
    "bb#<static-init>_2" -> "bb#<static-init>_3" [style="tapered"];

    "bb#<static-init>_3" [
        label = "block[id=3]()\l<statTemp>$28 = Solve<#<static-init>#<block>> : T.untyped\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb#<static-init>_3" -> "bb#<static-init>_1" [style="bold"];
    "bb#<static-init>_4" [
        label = "block[id=4]()\louterLoops: 1\l<blk>$31 = load_yield_params(#<static-init>#<block>, <static-init>#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$32 = 0 : Integer(0)\lx$17 = <blk>$31.[](<blk>$32) : T.untyped\l<blockReturnTemp>$33 = \"foo\" : String(\"foo\")\l<blockReturnTemp>$34 = blockreturn<#<static-init>#<block>> <blockReturnTemp>$33 : <impossible>\l<unconditional>\l"
    ];

    "bb#<static-init>_4" -> "bb#<static-init>_2" [style="bold"];
}

subgraph "cluster_::HasMeth#meth" {
    label = "::HasMeth#meth";
    color = blue;
    "bb::HasMeth#meth_0" [shape = invhouse];
    "bb::HasMeth#meth_1" [shape = parallelogram];

    "bb::HasMeth#meth_0" [
        label = "block[id=0]()\l<returnMethodTemp>$2 = \"meth\" : String(\"meth\")\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::HasMeth#meth_0" -> "bb::HasMeth#meth_1" [style="bold"];
    "bb::HasMeth#meth_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::HasMeth#meth_1" -> "bb::HasMeth#meth_1" [style="bold"];
}

subgraph "cluster_::HasToProc#to_proc" {
    label = "::HasToProc#to_proc";
    color = blue;
    "bb::HasToProc#to_proc_0" [shape = invhouse];
    "bb::HasToProc#to_proc_1" [shape = parallelogram];

    "bb::HasToProc#to_proc_0" [
        label = "block[id=0]()\l<statTemp>$4 = self : HasToProc\l<returnMethodTemp>$2 = <statTemp>$4.returns_lambda() : T.untyped\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::HasToProc#to_proc_0" -> "bb::HasToProc#to_proc_1" [style="bold"];
    "bb::HasToProc#to_proc_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::HasToProc#to_proc_1" -> "bb::HasToProc#to_proc_1" [style="bold"];
}

subgraph "cluster_::<Class:CallsWithObject>#calls_with_object" {
    label = "::<Class:CallsWithObject>#calls_with_object";
    color = blue;
    "bb::<Class:CallsWithObject>#calls_with_object_0" [shape = invhouse];
    "bb::<Class:CallsWithObject>#calls_with_object_1" [shape = parallelogram];

    "bb::<Class:CallsWithObject>#calls_with_object_0" [
        label = "block[id=0]()\l<constant:HasMeth>$7 = alias <constant:HasMeth> : <Class:HasMeth>\l<selfMethodTemp>$3 = self : <Class:CallsWithObject>\lblk = load_arg(<selfMethodTemp>$3#calls_with_object, 0) : T.untyped\l<statTemp>$5 = <constant:HasMeth>$7.new() : HasMeth\l<returnMethodTemp>$2 = blk.call(<statTemp>$5) : T.untyped\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::<Class:CallsWithObject>#calls_with_object_0" -> "bb::<Class:CallsWithObject>#calls_with_object_1" [style="bold"];
    "bb::<Class:CallsWithObject>#calls_with_object_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:CallsWithObject>#calls_with_object_1" -> "bb::<Class:CallsWithObject>#calls_with_object_1" [style="bold"];
}

subgraph "cluster_::<Class:CallsWithObjectChild>#calls_with_object" {
    label = "::<Class:CallsWithObjectChild>#calls_with_object";
    color = blue;
    "bb::<Class:CallsWithObjectChild>#calls_with_object_0" [shape = invhouse];
    "bb::<Class:CallsWithObjectChild>#calls_with_object_1" [shape = parallelogram];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_0" [
        label = "block[id=0]()\l<constant:<Magic>>$13 = alias <constant:<Magic>> : <Magic>\l<selfMethodTemp>$3 = self : <Class:CallsWithObjectChild>\lblk = load_arg(<selfMethodTemp>$3#calls_with_object, 0) : T.untyped\l<statTemp>$4 = self : <Class:CallsWithObjectChild>\l<block-pre-call-temp>$5 = <statTemp>$4.super() : T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_0" -> "bb::<Class:CallsWithObjectChild>#calls_with_object_2" [style="bold"];
    "bb::<Class:CallsWithObjectChild>#calls_with_object_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_1" -> "bb::<Class:CallsWithObjectChild>#calls_with_object_1" [style="bold"];
    "bb::<Class:CallsWithObjectChild>#calls_with_object_2" [
        label = "block[id=2](<constant:<Magic>>$13, blk)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_2" -> "bb::<Class:CallsWithObjectChild>#calls_with_object_4" [style="bold"];
    "bb::<Class:CallsWithObjectChild>#calls_with_object_2" -> "bb::<Class:CallsWithObjectChild>#calls_with_object_3" [style="tapered"];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_3" [
        label = "block[id=3]()\l<returnMethodTemp>$2 = Solve<::<Class:CallsWithObjectChild>#calls_with_object#<block>> : T.untyped\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_3" -> "bb::<Class:CallsWithObjectChild>#calls_with_object_1" [style="bold"];
    "bb::<Class:CallsWithObjectChild>#calls_with_object_4" [
        label = "block[id=4](<constant:<Magic>>$13, blk)\louterLoops: 1\l<blk>$6 = load_yield_params(::<Class:CallsWithObjectChild>#calls_with_object#<block>, CallsWithObjectChild.calls_with_object#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$7 = 0 : Integer(0)\l<block-pass>$2$2 = <blk>$6.[](<blk>$7) : T.untyped\l<statTemp>$9 = blk.to_proc() : T.untyped\l<statTemp>$14 = <block-pass>$2$2.to_a() : T.untyped\l<statTemp>$11 = <constant:<Magic>>$13.<splat>(<statTemp>$14) : T.untyped\l<blockReturnTemp>$8 = <statTemp>$9.call(<statTemp>$11) : T.untyped\l<blockReturnTemp>$16 = blockreturn<::<Class:CallsWithObjectChild>#calls_with_object#<block>> <blockReturnTemp>$8 : <impossible>\l<unconditional>\l"
    ];

    "bb::<Class:CallsWithObjectChild>#calls_with_object_4" -> "bb::<Class:CallsWithObjectChild>#calls_with_object_2" [style="bold"];
}

}

