class <emptyTree><<C <U <root>>>> < ()
  class <emptyTree>::<C <U HasMeth>><<C <U <todo sym>>>> < (::<todo sym>)
    def <U meth><<C <U <todo sym>>>>(&<U <blk>>)
      "meth"
    end
  end

  def <U returns_lambda><<C <U <todo sym>>>>(&<U <blk>>)
    self(<C <U <todo sym>>>).<U lambda>() do |<U x>|
      "returns_lambda"
    end
  end

  class <emptyTree>::<C <U HasToProc>><<C <U <todo sym>>>> < (::<todo sym>)
    def <U to_proc><<C <U <todo sym>>>>(&<U <blk>>)
      self(<C <U <todo sym>>>).<U returns_lambda>()
    end
  end

  def <U calls_arg_with_object><<C <U <todo sym>>>>(<U arg>, &<U blk>)
    <U blk>.<U call>(<U arg>)
  end

  def <U calls_with_object><<C <U <todo sym>>>>(&<U blk>)
    self(<C <U <todo sym>>>).<U calls_arg_with_object>(<emptyTree>::<C <U HasMeth>>.<U new>()) do |*<D <U <block-pass>> $2>|
      ::<Magic>.<U <call-with-splat>>(<U blk>.<U to_proc>(), :"call", <D <U <block-pass>> $2>)
    end
  end

  class <emptyTree>::<C <U CallsWithObject>><<C <U <todo sym>>>> < (::<todo sym>)
    def self.<U calls_with_object><<C <U <todo sym>>>>(&<U blk>)
      <U blk>.<U call>(<emptyTree>::<C <U HasMeth>>.<U new>())
    end
  end

  class <emptyTree>::<C <U CallsWithObjectChild>><<C <U <todo sym>>>> < (<emptyTree>::<C <U CallsWithObject>>)
    def self.<U calls_with_object><<C <U <todo sym>>>>(&<U blk>)
      self(<C <U <todo sym>>>).<U super>() do |*<D <U <block-pass>> $2>|
        ::<Magic>.<U <call-with-splat>>(<U blk>.<U to_proc>(), :"call", <D <U <block-pass>> $2>)
      end
    end
  end

  def <U foo><<C <U <todo sym>>>>(&<U blk>)
    begin
      self(<C <U <todo sym>>>).<U calls_with_object>() do |<D <U <block-pass>> $2>|
        <D <U <block-pass>> $2>.<U meth>()
      end
      self(<C <U <todo sym>>>).<U calls_with_object>() do |*<U args>|
        ::<Magic>.<U <call-with-splat>>(:"meth".<U to_proc>(), :"call", <U args>.<U to_a>())
      end
      self(<C <U <todo sym>>>).<U calls_with_object>() do |<U x>|
        :"meth".<U to_proc>().<U call>(<U x>)
      end
      self(<C <U <todo sym>>>).<U calls_with_object>() do |<U x>|
        <U x>.<U meth>()
      end
      self(<C <U <todo sym>>>).<U calls_with_object>() do |*<D <U <block-pass>> $3>|
        ::<Magic>.<U <call-with-splat>>(<U blk>.<U to_proc>(), :"call", <D <U <block-pass>> $3>)
      end
      self(<C <U <todo sym>>>).<U calls_with_object>() do |*<D <U <block-pass>> $4>|
        ::<Magic>.<U <call-with-splat>>(self(<C <U <todo sym>>>).<U returns_lambda>().<U to_proc>(), :"call", <D <U <block-pass>> $4>)
      end
      self(<C <U <todo sym>>>).<U calls_with_object>() do |*<D <U <block-pass>> $5>|
        ::<Magic>.<U <call-with-splat>>(<emptyTree>::<C <U HasToProc>>.<U new>().<U to_proc>(), :"call", <D <U <block-pass>> $5>)
      end
      self(<C <U <todo sym>>>).<U calls_with_object>() do |*<U args>|
        ::<Magic>.<U <call-with-splat>>(<emptyTree>::<C <U HasToProc>>.<U new>().<U to_proc>(), :"call", <U args>.<U to_a>())
      end
      <emptyTree>::<C <U CallsWithObject>>.<U calls_with_object>() do |<D <U <block-pass>> $6>|
        <D <U <block-pass>> $6>.<U meth>()
      end
      begin
        <D <U <assignTemp>> $7> = <emptyTree>::<C <U CallsWithObject>>
        if <D <U <assignTemp>> $7>.<U nil?>()
          nil
        else
          <D <U <assignTemp>> $7>.<U calls_with_object>() do |<D <U <block-pass>> $8>|
            <D <U <block-pass>> $8>.<U meth>()
          end
        end
      end
      <emptyTree>::<C <U CallsWithObjectChild>>.<U calls_with_object>() do |<D <U <block-pass>> $9>|
        <D <U <block-pass>> $9>.<U meth>()
      end
      self(<C <U <todo sym>>>).<U calls_arg_with_object>(<emptyTree>::<C <U HasMeth>>.<U new>()) do |<D <U <block-pass>> $10>|
        <D <U <block-pass>> $10>.<U meth>()
      end
      self(<C <U <todo sym>>>).<U calls_arg_with_object>(<emptyTree>::<C <U HasMeth>>.<U new>()) do |<U x>|
        <U x>.<U meth>()
      end
    end
  end

  self(<C <U <todo sym>>>).<U foo>() do |<U x>|
    "foo"
  end
end
