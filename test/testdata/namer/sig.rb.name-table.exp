class <constant:<root>> < ::Object () @ test/testdata/namer/sig.rb:2
  class <constant:A> < ::Object () @ test/testdata/namer/sig.rb:7
    method bad (a, b, c, d, e, f, g, h, i, j, k, l, m) -> T2 @ test/testdata/namer/sig.rb:50
      argument a<> -> untyped @ test/testdata/namer/sig.rb:35
      argument b<> -> untyped @ test/testdata/namer/sig.rb:36
      argument c<> -> Object @ test/testdata/namer/sig.rb:37
      argument d<> -> untyped @ test/testdata/namer/sig.rb:38
      argument e<> -> untyped @ test/testdata/namer/sig.rb:39
      argument f<> -> untyped @ test/testdata/namer/sig.rb:40
      argument g<> -> <impossible> @ test/testdata/namer/sig.rb:41
      argument h<> -> untyped @ test/testdata/namer/sig.rb:42
      argument i<> -> untyped @ test/testdata/namer/sig.rb:43
      argument j<> -> untyped @ test/testdata/namer/sig.rb:44
      argument k<> -> untyped @ test/testdata/namer/sig.rb:45
      argument l<> -> ShapeType {
      } @ test/testdata/namer/sig.rb:46
      argument m<> -> ShapeType {
        Symbol(:"foo") => untyped
      } @ test/testdata/namer/sig.rb:47
    method f1 (x) -> T1 @ test/testdata/namer/sig.rb:67
      argument x<> -> untyped @ test/testdata/namer/sig.rb:67
    method f2 (x) -> T2 @ test/testdata/namer/sig.rb:71
      argument x<> -> T1 @ test/testdata/namer/sig.rb:70
    method f3 () -> T1 @ test/testdata/namer/sig.rb:75
    method f4 (y) -> T1 @ test/testdata/namer/sig.rb:100
      argument y<> -> T1 @ test/testdata/namer/sig.rb:98
    method good (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) -> T2 @ test/testdata/namer/sig.rb:31
      argument a<> -> TupleType {
        0 = T1
        1 = T2
      } @ test/testdata/namer/sig.rb:9
      argument b<> -> T1 @ test/testdata/namer/sig.rb:10
      argument c<> -> T1 | NilClass @ test/testdata/namer/sig.rb:11
      argument d<> -> T1 | T2 @ test/testdata/namer/sig.rb:12
      argument e<> -> untyped @ test/testdata/namer/sig.rb:13
      argument f<> -> AppliedType {
        klass = ::Array
        targs = [
          <constant:Elem> = T1
        ]
      } @ test/testdata/namer/sig.rb:14
      argument g<> -> AppliedType {
        klass = ::Hash
        targs = [
          <constant:K> = T1
          <constant:V> = T2
          <constant:Elem> = TupleType {
              0 = T1
              1 = T2
            }
        ]
      } @ test/testdata/namer/sig.rb:15
      argument h<> -> FalseClass | Integer | Float | String | Symbol @ test/testdata/namer/sig.rb:16
      argument i<> -> T1 @ test/testdata/namer/sig.rb:17
      argument j<> -> <Class:T1> @ test/testdata/namer/sig.rb:18
      argument k<> -> <Class:T1> @ test/testdata/namer/sig.rb:19
      argument l<> -> <Class:T1> @ test/testdata/namer/sig.rb:20
      argument m<> -> <Class:T1> @ test/testdata/namer/sig.rb:21
      argument n<> -> <Class:M1> @ test/testdata/namer/sig.rb:22
      argument o<> -> ShapeType {
        Symbol(:"foo") => String
        Symbol(:"bar") => Integer | NilClass
      } @ test/testdata/namer/sig.rb:23
      argument p<> -> ShapeType {
      } @ test/testdata/namer/sig.rb:27
      argument q<> -> ShapeType {
        String("hi") => String
        Symbol(:"bye") => String
      } @ test/testdata/namer/sig.rb:28
    method no_params () -> T1 @ test/testdata/namer/sig.rb:58
    method noreturn () -> <impossible> @ test/testdata/namer/sig.rb:54
    method private : private (x) -> T1 @ test/testdata/namer/sig.rb:79
      argument x<> -> T1 @ test/testdata/namer/sig.rb:78
    method protected : protected (x) -> T1 @ test/testdata/namer/sig.rb:84
      argument x<> -> T1 @ test/testdata/namer/sig.rb:83
    method public (x) -> T1 @ test/testdata/namer/sig.rb:89
      argument x<> -> T1 @ test/testdata/namer/sig.rb:88
    method test_abstract () -> T1 @ test/testdata/namer/sig.rb:109
    method test_abstract_untyped () @ test/testdata/namer/sig.rb:123
    method test_implementation (x, y) @ test/testdata/namer/sig.rb:112
      argument x<> -> untyped @ test/testdata/namer/sig.rb:112
      argument y<> -> untyped @ test/testdata/namer/sig.rb:112
    method test_kwargs (returns) -> T2 @ test/testdata/namer/sig.rb:63
      argument returns<> -> T1 @ test/testdata/namer/sig.rb:61
    method test_overridable () -> T1 @ test/testdata/namer/sig.rb:118
    method test_overridable_implementation () -> T1 @ test/testdata/namer/sig.rb:121
    method test_override () -> T1 @ test/testdata/namer/sig.rb:115
    method test_standard_untyped () @ test/testdata/namer/sig.rb:124
    method test_yield_no_block_type (x, <blk>) -> Integer @ test/testdata/namer/sig.rb:104
      argument <blk><block> -> untyped @ test/testdata/namer/sig.rb:105
      argument x<> -> Integer @ test/testdata/namer/sig.rb:103
  class <constant:M1> (<constant:BasicObject>) @ test/testdata/namer/sig.rb:4
  class <constant:T1> < ::Object () @ test/testdata/namer/sig.rb:2
  class <constant:T2> < ::Object () @ test/testdata/namer/sig.rb:3
  class <singleton class:<constant:A>> < ::<Class:Object> () @ test/testdata/namer/sig.rb:7
    method static : private (x) -> T1 @ test/testdata/namer/sig.rb:94
      argument x<> -> T1 @ test/testdata/namer/sig.rb:93
  class <singleton class:<constant:M1>> < ::Module () @ test/testdata/namer/sig.rb:4
  class <singleton class:<constant:T1>> < ::<Class:Object> () @ test/testdata/namer/sig.rb:2
  class <singleton class:<constant:T2>> < ::<Class:Object> () @ test/testdata/namer/sig.rb:3
  method <static-init>$10 () @ test/testdata/namer/sig.rb:2
  static-field <constant:A1> -> AliasType { symbol = ::T1 } @ test/testdata/namer/sig.rb:5

