digraph "yield.rb" {
subgraph "cluster_#<static-init>" {
    label = "#<static-init>";
    color = blue;
    "bb#<static-init>_0" [shape = invhouse];
    "bb#<static-init>_1" [shape = parallelogram];

    "bb#<static-init>_0" [
        label = "block[id=0]()\l<constant:RubyTyper>$7 = alias <constant:RubyTyper> : <Class:RubyTyper>\l<constant:Main>$9 = alias <constant:Main> : <Class:Main>\l<statTemp>$5 = <constant:RubyTyper>$7.keep_for_ide(<constant:Main>$9) : T.untyped\l<statTemp>$11 = <constant:Main>$9.new() : Main\l<statTemp>$10 = <statTemp>$11.main() : T.untyped\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb#<static-init>_0" -> "bb#<static-init>_1" [style="bold"];
    "bb#<static-init>_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb#<static-init>_1" -> "bb#<static-init>_1" [style="bold"];
}

subgraph "cluster_::Main#yielder" {
    label = "::Main#yielder";
    color = blue;
    "bb::Main#yielder_0" [shape = invhouse];
    "bb::Main#yielder_1" [shape = parallelogram];

    "bb::Main#yielder_0" [
        label = "block[id=0]()\l<selfMethodTemp>$3 = self : Main\l<blk> = load_arg(<selfMethodTemp>$3#yielder, 0) : T.untyped\l<statTemp>$6 = 1 : Integer(1)\la = <blk>.call(<statTemp>$6) : T.untyped\l<returnMethodTemp>$2 = <blk>.call(a) : T.untyped\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#yielder_0" -> "bb::Main#yielder_1" [style="bold"];
    "bb::Main#yielder_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Main#yielder_1" -> "bb::Main#yielder_1" [style="bold"];
}

subgraph "cluster_::Main#blockpass" {
    label = "::Main#blockpass";
    color = blue;
    "bb::Main#blockpass_0" [shape = invhouse];
    "bb::Main#blockpass_1" [shape = parallelogram];

    "bb::Main#blockpass_0" [
        label = "block[id=0]()\l<selfMethodTemp>$3 = self : Main\lblk = load_arg(<selfMethodTemp>$3#blockpass, 0) : T.untyped\l<statTemp>$6 = 1 : Integer(1)\la = blk.call(<statTemp>$6) : T.untyped\l<returnMethodTemp>$2 = blk.call(a) : T.untyped\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#blockpass_0" -> "bb::Main#blockpass_1" [style="bold"];
    "bb::Main#blockpass_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Main#blockpass_1" -> "bb::Main#blockpass_1" [style="bold"];
}

subgraph "cluster_::Main#mixed" {
    label = "::Main#mixed";
    color = blue;
    "bb::Main#mixed_0" [shape = invhouse];
    "bb::Main#mixed_1" [shape = parallelogram];

    "bb::Main#mixed_0" [
        label = "block[id=0]()\l<selfMethodTemp>$3 = self : Main\lblk = load_arg(<selfMethodTemp>$3#mixed, 0) : T.untyped\l<statTemp>$6 = 1 : Integer(1)\la = blk.call(<statTemp>$6) : T.untyped\l<returnMethodTemp>$2 = blk.call(a) : T.untyped\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#mixed_0" -> "bb::Main#mixed_1" [style="bold"];
    "bb::Main#mixed_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Main#mixed_1" -> "bb::Main#mixed_1" [style="bold"];
}

subgraph "cluster_::Main#blockyield" {
    label = "::Main#blockyield";
    color = blue;
    "bb::Main#blockyield_0" [shape = invhouse];
    "bb::Main#blockyield_1" [shape = parallelogram];

    "bb::Main#blockyield_0" [
        label = "block[id=0]()\l<statTemp>$4 = self : Main\l<block-pre-call-temp>$5 = <statTemp>$4.yielder() : T.untyped\l<unconditional>\l"
    ];

    "bb::Main#blockyield_0" -> "bb::Main#blockyield_2" [style="bold"];
    "bb::Main#blockyield_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Main#blockyield_1" -> "bb::Main#blockyield_1" [style="bold"];
    "bb::Main#blockyield_2" [
        label = "block[id=2]()\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Main#blockyield_2" -> "bb::Main#blockyield_4" [style="bold"];
    "bb::Main#blockyield_2" -> "bb::Main#blockyield_3" [style="tapered"];

    "bb::Main#blockyield_3" [
        label = "block[id=3]()\l<returnMethodTemp>$2 = Solve<::Main#blockyield#<block>> : T.untyped\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#blockyield_3" -> "bb::Main#blockyield_1" [style="bold"];
    "bb::Main#blockyield_4" [
        label = "block[id=4]()\louterLoops: 1\l<blk>$6 = load_yield_params(::Main#blockyield#<block>, Main#blockyield#<block>) : TupleType {\l  0 = T.untyped\l  1 = T.untyped\l}\l<blk>$7 = 0 : Integer(0)\li$5 = <blk>$6.[](<blk>$7) : T.untyped\l<blk>$7 = 1 : Integer(1)\l<blk>$5 = <blk>$6.[](<blk>$7) : T.untyped\l<blockReturnTemp>$8 = <blk>$5.call(i$5) : T.untyped\l<blockReturnTemp>$11 = blockreturn<::Main#blockyield#<block>> <blockReturnTemp>$8 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#blockyield_4" -> "bb::Main#blockyield_2" [style="bold"];
}

subgraph "cluster_::Main#main" {
    label = "::Main#main";
    color = blue;
    "bb::Main#main_0" [shape = invhouse];
    "bb::Main#main_1" [shape = parallelogram];

    "bb::Main#main_0" [
        label = "block[id=0]()\l<constant:<Magic>>$24 = alias <constant:<Magic>> : <Magic>\l<statTemp>$5 = self : Main\l<block-pre-call-temp>$6 = <statTemp>$5.lambda() : Proc\l<unconditional>\l"
    ];

    "bb::Main#main_0" -> "bb::Main#main_2" [style="bold"];
    "bb::Main#main_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Main#main_1" -> "bb::Main#main_1" [style="bold"];
    "bb::Main#main_2" [
        label = "block[id=2](<constant:<Magic>>$24)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Main#main_2" -> "bb::Main#main_4" [style="bold"];
    "bb::Main#main_2" -> "bb::Main#main_3" [style="tapered"];

    "bb::Main#main_3" [
        label = "block[id=3](<constant:<Magic>>$24)\ll = Solve<::Main#main#<block>> : Proc\l<statTemp>$15 = self : Main\l<block-pre-call-temp>$16 = <statTemp>$15.yielder() : T.untyped\l<unconditional>\l"
    ];

    "bb::Main#main_3" -> "bb::Main#main_5" [style="bold"];
    "bb::Main#main_4" [
        label = "block[id=4](<constant:<Magic>>$24)\louterLoops: 1\l<blk>$7 = load_yield_params(::Main#main#<block>, Main#main#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$8 = 0 : Integer(0)\lx$7 = <blk>$7.[](<blk>$8) : T.untyped\l<statTemp>$11 = self : Main\l<statTemp>$10 = <statTemp>$11.puts(x$7) : NilClass\l<blockReturnTemp>$9 = 3 : Integer(3)\l<blockReturnTemp>$13 = blockreturn<::Main#main#<block>> <blockReturnTemp>$9 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#main_4" -> "bb::Main#main_2" [style="bold"];
    "bb::Main#main_5" [
        label = "block[id=5](<constant:<Magic>>$24, l)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Main#main_5" -> "bb::Main#main_7" [style="bold"];
    "bb::Main#main_5" -> "bb::Main#main_6" [style="tapered"];

    "bb::Main#main_6" [
        label = "block[id=6](<constant:<Magic>>$24, l)\l<statTemp>$14 = Solve<::Main#main#<block>> : T.untyped\l<statTemp>$29 = self : Main\l<block-pre-call-temp>$30 = <statTemp>$29.blockpass() : T.untyped\l<unconditional>\l"
    ];

    "bb::Main#main_6" -> "bb::Main#main_8" [style="bold"];
    "bb::Main#main_7" [
        label = "block[id=7](<constant:<Magic>>$24, l)\louterLoops: 1\l<blk>$17 = load_yield_params(::Main#main#<block>, Main#main#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$18 = 0 : Integer(0)\l<block-pass>$2$8 = <blk>$17.[](<blk>$18) : T.untyped\l<statTemp>$20 = l.to_proc() : Proc\l<statTemp>$25 = <block-pass>$2$8.to_a() : T.untyped\l<statTemp>$22 = <constant:<Magic>>$24.<splat>(<statTemp>$25) : T.untyped\l<blockReturnTemp>$19 = <statTemp>$20.call(<statTemp>$22) : T.untyped\l<blockReturnTemp>$27 = blockreturn<::Main#main#<block>> <blockReturnTemp>$19 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#main_7" -> "bb::Main#main_5" [style="bold"];
    "bb::Main#main_8" [
        label = "block[id=8](<constant:<Magic>>$24, l)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Main#main_8" -> "bb::Main#main_10" [style="bold"];
    "bb::Main#main_8" -> "bb::Main#main_9" [style="tapered"];

    "bb::Main#main_9" [
        label = "block[id=9](<constant:<Magic>>$24, l)\l<statTemp>$28 = Solve<::Main#main#<block>> : T.untyped\l<statTemp>$42 = self : Main\l<block-pre-call-temp>$43 = <statTemp>$42.mixed() : T.untyped\l<unconditional>\l"
    ];

    "bb::Main#main_9" -> "bb::Main#main_11" [style="bold"];
    "bb::Main#main_10" [
        label = "block[id=10](<constant:<Magic>>$24, l)\louterLoops: 1\l<blk>$31 = load_yield_params(::Main#main#<block>, Main#main#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$32 = 0 : Integer(0)\l<block-pass>$3$9 = <blk>$31.[](<blk>$32) : T.untyped\l<statTemp>$34 = l.to_proc() : Proc\l<statTemp>$38 = <block-pass>$3$9.to_a() : T.untyped\l<statTemp>$36 = <constant:<Magic>>$24.<splat>(<statTemp>$38) : T.untyped\l<blockReturnTemp>$33 = <statTemp>$34.call(<statTemp>$36) : T.untyped\l<blockReturnTemp>$40 = blockreturn<::Main#main#<block>> <blockReturnTemp>$33 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#main_10" -> "bb::Main#main_8" [style="bold"];
    "bb::Main#main_11" [
        label = "block[id=11](<constant:<Magic>>$24, l)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Main#main_11" -> "bb::Main#main_13" [style="bold"];
    "bb::Main#main_11" -> "bb::Main#main_12" [style="tapered"];

    "bb::Main#main_12" [
        label = "block[id=12](<constant:<Magic>>$24, l)\l<statTemp>$41 = Solve<::Main#main#<block>> : T.untyped\l<statTemp>$54 = self : Main\l<block-pre-call-temp>$55 = <statTemp>$54.blockyield() : T.untyped\l<unconditional>\l"
    ];

    "bb::Main#main_12" -> "bb::Main#main_14" [style="bold"];
    "bb::Main#main_13" [
        label = "block[id=13](<constant:<Magic>>$24, l)\louterLoops: 1\l<blk>$44 = load_yield_params(::Main#main#<block>, Main#main#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$45 = 0 : Integer(0)\l<block-pass>$4$10 = <blk>$44.[](<blk>$45) : T.untyped\l<statTemp>$47 = l.to_proc() : Proc\l<statTemp>$51 = <block-pass>$4$10.to_a() : T.untyped\l<statTemp>$49 = <constant:<Magic>>$24.<splat>(<statTemp>$51) : T.untyped\l<blockReturnTemp>$46 = <statTemp>$47.call(<statTemp>$49) : T.untyped\l<blockReturnTemp>$53 = blockreturn<::Main#main#<block>> <blockReturnTemp>$46 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#main_13" -> "bb::Main#main_11" [style="bold"];
    "bb::Main#main_14" [
        label = "block[id=14](<constant:<Magic>>$24, l)\louterLoops: 1\l<block-call>\l"
    ];

    "bb::Main#main_14" -> "bb::Main#main_16" [style="bold"];
    "bb::Main#main_14" -> "bb::Main#main_15" [style="tapered"];

    "bb::Main#main_15" [
        label = "block[id=15]()\l<returnMethodTemp>$2 = Solve<::Main#main#<block>> : T.untyped\l<finalReturn> = return <returnMethodTemp>$2 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#main_15" -> "bb::Main#main_1" [style="bold"];
    "bb::Main#main_16" [
        label = "block[id=16](<constant:<Magic>>$24, l)\louterLoops: 1\l<blk>$56 = load_yield_params(::Main#main#<block>, Main#main#<block>) : TupleType {\l  0 = T.untyped\l}\l<blk>$57 = 0 : Integer(0)\l<block-pass>$5$11 = <blk>$56.[](<blk>$57) : T.untyped\l<statTemp>$59 = l.to_proc() : Proc\l<statTemp>$63 = <block-pass>$5$11.to_a() : T.untyped\l<statTemp>$61 = <constant:<Magic>>$24.<splat>(<statTemp>$63) : T.untyped\l<blockReturnTemp>$58 = <statTemp>$59.call(<statTemp>$61) : T.untyped\l<blockReturnTemp>$65 = blockreturn<::Main#main#<block>> <blockReturnTemp>$58 : <impossible>\l<unconditional>\l"
    ];

    "bb::Main#main_16" -> "bb::Main#main_14" [style="bold"];
}

}

