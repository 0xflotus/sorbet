Integer {
  val = "1"
}
{
  "type" : "Integer",
  "val" : "1"
}
class <emptyTree><<constant:<root>>> < ()
  1
end
ClassDef{
  name = EmptyTree<<constant:<root>>>
  ancestors = []
  rhs = [
    IntLit{ value = 1 }
  ]
}
class <emptyTree><<constant:<root>>> < ()
  1
end
ClassDef{
  name = EmptyTree<<constant:<root>>>
  ancestors = []
  rhs = [
    IntLit{ value = 1 }
  ]
}
class <constant:<root>> < ::<constant:Object> () -> <Class:<root>> @ -e:1
  method <static-init>$8 () @ -e:1

class <constant:<root>> < ::<constant:Object> () -> <Class:<root>> @ -e:1
  class <constant:<<JUNK>>> () -> <Class:<<JUNK>>> @ ???
  class <constant:<<RESERVED>>0> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>10> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>11> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>12> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>13> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>14> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>15> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>16> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>17> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>18> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>19> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>1> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>20> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>21> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>22> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>23> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>24> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>25> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>26> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>27> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>28> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>29> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>2> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>30> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>31> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>32> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>33> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>34> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>35> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>36> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>37> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>38> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>39> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>3> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>40> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>41> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>42> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>43> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>44> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>45> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>46> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>47> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>48> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>49> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>4> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>50> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>51> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>52> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>53> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>54> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>55> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>56> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>57> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>58> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>59> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>5> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>60> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>61> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>62> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>63> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>64> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>65> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>66> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>67> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>68> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>69> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>6> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>70> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>71> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>72> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>73> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>74> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>75> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>76> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>77> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>78> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>79> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>7> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>80> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>81> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>82> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>83> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>84> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>85> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>86> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>87> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>88> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>89> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>8> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>90> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>91> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>92> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>93> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>94> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>95> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>96> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>97> < ::<constant:Object> () @ ???
  class <constant:<<RESERVED>>9> < ::<constant:Object> () @ ???
  class <constant:<Magic>> < ::<constant:Object> () -> <Magic> @ ???
    method <build-array> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ ???
      argument arg0<repeated> -> Object @ ???
    method <build-hash> (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ ???
      argument arg0<repeated> -> Object @ ???
    method <splat> (arg0) -> untyped @ ???
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ ???
  class <constant:<bottom>> () @ ???
  class <constant:<none>> () @ ???
  class <constant:<todo sym>> () -> <Class:<todo sym>> @ ???
  class <constant:<top>> () @ ???
  class <constant:Abbrev> (<constant:BasicObject>) -> <Class:Abbrev> @ rbi/stdlib.rbi:__LINE__
  class <constant:ArgumentError> < ::<constant:StandardError> () -> <Class:ArgumentError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> ArgumentError @ rbi/stdlib.rbi:__LINE__
    method dup () -> ArgumentError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> ArgumentError @ rbi/stdlib.rbi:__LINE__
    method taint () -> ArgumentError @ rbi/stdlib.rbi:__LINE__
    method trust () -> ArgumentError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> ArgumentError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> ArgumentError @ rbi/stdlib.rbi:__LINE__
  class <constant:Array>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Array> @ rbi/stdlib.rbi:__LINE__
    method & (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method * (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method + (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method - (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method << (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : *> (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : +> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : []=> (arg0, arg1, arg2) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : []> (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : collect> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : combination> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : count> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : cycle> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : delete> (blk) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc0>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : delete_if> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : drop_while> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each> (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_index> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : fetch> (arg0, arg1) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : fill> (arg0, arg1, arg2) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : first> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : index> (blk) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : initialize> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : last> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : map!> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : map> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : permutation> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : pop> () -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : reject!> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : reject> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : repeated_combination> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : repeated_permutation> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : reverse_each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : rindex> (blk) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : sample> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : select!> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : select> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : shift> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : slice!> (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : slice> (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : sort!> (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : sort> (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : sort_by!> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : take_while> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : []=> (arg0, arg1) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : []> (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : count> (blk) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : fetch> (arg0, blk) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Array>#<constant:Elem>)
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : fill> (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : index> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : initialize> (arg0, arg1) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : rindex> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : slice!> (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : slice> (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : fill> (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Array>#<constant:Elem>)
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : fill> (arg0, arg1, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Array>#<constant:Elem>)
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.5 : fill> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Array>#<constant:Elem>)
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method [] (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method []= (arg0, arg1) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method assoc (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method at (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method clear () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method clone () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method collect (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method combination (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method compact () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method compact! () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method concat (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method count () -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method cycle (arg0, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method delete (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method delete_at (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method delete_if (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method drop (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method drop_while (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method dup () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method each () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method each_index (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method empty? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method fetch (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method fill (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method first () -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method flatten () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method freeze () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method include? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method index (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method initialize () -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method insert (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<repeated> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method join (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method keep_if (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method last () -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method length () -> Integer @ rbi/stdlib.rbi:__LINE__
    method map (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method map! (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method member? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method permutation (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method pop (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method product (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = untyped
            ]
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = BasicObject
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method push (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method rassoc (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method reject (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method reject! (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method repeated_combination (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method repeated_permutation (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method reverse () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method reverse! () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method reverse_each (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method rindex (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method rotate (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method rotate! (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method sample () -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method select (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method select! (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method shift () -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method shuffle () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method shuffle! () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method size () -> Integer @ rbi/stdlib.rbi:__LINE__
    method slice (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method slice! (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method sort () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method sort! () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method sort_by! (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method taint () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method take (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method take_while (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method to_a () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method to_ary () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method transpose () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method trust () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method uniq () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method uniq! () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method unshift (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> LambdaParam(::<constant:Array>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method untaint () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untrust () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method values_at (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = Integer
            ]
          } | Integer @ rbi/stdlib.rbi:__LINE__
    method zip (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = untyped
            ]
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = BasicObject
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method | (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
  class <constant:Base64> (<constant:BasicObject>) -> <Class:Base64> @ rbi/stdlib.rbi:__LINE__
  class <constant:BasicObject> () -> <Class:BasicObject> @ rbi/stdlib.rbi:__LINE__
    method ! () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method != (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : instance_eval> (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc0>
        targs = [
          <constant:Return> = BasicObject
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument filename<optional> @ rbi/stdlib.rbi:__LINE__
      argument lineno<optional> @ rbi/stdlib.rbi:__LINE__
    method == (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method __id__ () -> Integer @ rbi/stdlib.rbi:__LINE__
    method __send__ (arg0, arg1) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
      argument arg1<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method equal? (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method instance_eval (arg0, filename, lineno) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument filename<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument lineno<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method instance_exec (args, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> BasicObject @ rbi/stdlib.rbi:__LINE__
  class <constant:Benchmark> (<constant:BasicObject>) -> <Class:Benchmark> @ rbi/stdlib.rbi:__LINE__
    class <constant:Job> < ::<constant:Object> () -> <Class:Benchmark::Job> @ rbi/stdlib.rbi:__LINE__
    class <constant:Report> < ::<constant:Object> () -> <Class:Benchmark::Report> @ rbi/stdlib.rbi:__LINE__
    class <constant:Tms> < ::<constant:Object> () -> <Class:Benchmark::Tms> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:CAPTION> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FORMAT> -> String @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Job>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Report>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Tms>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    static-field <constant:BENCHMARK_VERSION> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CAPTION> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FORMAT> -> String @ rbi/stdlib.rbi:__LINE__
  class <constant:BigDecimal> < ::<constant:Numeric> () -> <Class:BigDecimal> @ rbi/stdlib.rbi:__LINE__
    method % (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method * (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method ** (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method + (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method +@ () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method - (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method -@ () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method / (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method < (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <= (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <=> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : **> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : *> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : +> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : -> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : /> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : <=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : <=>> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : <> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : >=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : >> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : div> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : fdiv> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : power> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : quo> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : round> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : truncate> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : **> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : *> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : +> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : -> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : /> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : <=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : <=>> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : <> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : >=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : >> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : div> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : fdiv> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : power> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : quo> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : **> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : *> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : +> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : -> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : /> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : <=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : <=>> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : <> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : >=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : >> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : div> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : fdiv> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : power> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : quo> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : *> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : +> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : -> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : /> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : fdiv> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : quo> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method == (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method === (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method > (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method >= (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method _dump () -> String @ rbi/stdlib.rbi:__LINE__
    method abs () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method abs2 () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method add (arg0, arg1) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method angle () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method arg () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method ceil () -> Integer @ rbi/stdlib.rbi:__LINE__
    method clone () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method coerce (arg0) -> TupleType {
      0 = BigDecimal
      1 = BigDecimal
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method conj () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method conjugate () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method denominator () -> Integer @ rbi/stdlib.rbi:__LINE__
    method div (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method divmod (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method dup () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method eql? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method equal? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method exponent () -> Integer @ rbi/stdlib.rbi:__LINE__
    method fdiv (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method finite? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method fix () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method floor () -> Integer @ rbi/stdlib.rbi:__LINE__
    method frac () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method freeze () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method hash () -> Integer @ rbi/stdlib.rbi:__LINE__
    method imag () -> Integer @ rbi/stdlib.rbi:__LINE__
    method imaginary () -> Integer @ rbi/stdlib.rbi:__LINE__
    method infinite? () -> NilClass | Integer @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method magnitude () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method modulo (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method mult (arg0, arg1) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method nan? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method nonzero? () -> Object @ rbi/stdlib.rbi:__LINE__
    method numerator () -> Integer @ rbi/stdlib.rbi:__LINE__
    method phase () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method power (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method precs () -> TupleType {
      0 = Integer
      1 = Integer
    } @ rbi/stdlib.rbi:__LINE__
    method quo (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method real () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method real? () -> TrueClass @ rbi/stdlib.rbi:__LINE__
    method remainder (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method round () -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method sign () -> Integer @ rbi/stdlib.rbi:__LINE__
    method split () -> TupleType {
      0 = Integer
      1 = String
      2 = Integer
      3 = Integer
    } @ rbi/stdlib.rbi:__LINE__
    method sqrt (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method sub (arg0, arg1) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method taint () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method to_c () -> Complex @ rbi/stdlib.rbi:__LINE__
    method to_f () -> Float @ rbi/stdlib.rbi:__LINE__
    method to_i () -> Integer @ rbi/stdlib.rbi:__LINE__
    method to_int () -> Integer @ rbi/stdlib.rbi:__LINE__
    method to_r () -> Rational @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method truncate () -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method trust () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method untaint () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method untrust () -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method zero? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    static-field <constant:BASE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EXCEPTION_ALL> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EXCEPTION_INFINITY> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EXCEPTION_OVERFLOW> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EXCEPTION_UNDERFLOW> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EXCEPTION_ZERODIVIDE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:INFINITY> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NAN> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ROUND_CEILING> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ROUND_DOWN> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ROUND_FLOOR> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ROUND_HALF_DOWN> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ROUND_HALF_EVEN> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ROUND_HALF_UP> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ROUND_MODE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ROUND_UP> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SIGN_NEGATIVE_FINITE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SIGN_NEGATIVE_INFINITE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SIGN_NEGATIVE_ZERO> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SIGN_POSITIVE_FINITE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SIGN_POSITIVE_INFINITE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SIGN_POSITIVE_ZERO> -> Integer @ rbi/stdlib.rbi:__LINE__
  class <constant:BigMath> (<constant:BasicObject>) -> <Class:BigMath> @ rbi/stdlib.rbi:__LINE__
    method E (prec) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument prec<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method PI (prec) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument prec<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method atan (x, prec) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument prec<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method cos (x, prec) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument prec<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method sin (x, prec) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument prec<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method sqrt (x, prec) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument prec<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer @ rbi/stdlib.rbi:__LINE__
  class <constant:Binding> < ::<constant:Object> () -> <Class:Binding> @ rbi/stdlib.rbi:__LINE__
    method clone () -> Binding @ rbi/stdlib.rbi:__LINE__
    method dup () -> Binding @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Binding @ rbi/stdlib.rbi:__LINE__
    method taint () -> Binding @ rbi/stdlib.rbi:__LINE__
    method trust () -> Binding @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Binding @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Binding @ rbi/stdlib.rbi:__LINE__
  class <constant:CSV>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:CSV> @ rbi/stdlib.rbi:__LINE__
    class <constant:FieldInfo>[<constant:Elem>] < ::<constant:Struct> () -> <Class:CSV::FieldInfo> @ rbi/stdlib.rbi:__LINE__
      typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
    class <constant:MalformedCSVError> < ::<constant:RuntimeError> () -> <Class:CSV::MalformedCSVError> @ rbi/stdlib.rbi:__LINE__
    class <constant:Row>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:CSV::Row> @ rbi/stdlib.rbi:__LINE__
      typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
    class <constant:Table>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:CSV::Table> @ rbi/stdlib.rbi:__LINE__
      typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:FieldInfo>> < ::<singleton class:<constant:Struct>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:MalformedCSVError>> < ::<singleton class:<constant:RuntimeError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Row>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Table>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    method clone () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method dup () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method freeze () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method taint () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method trust () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untaint () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untrust () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:DEFAULT_OPTIONS> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:VERSION> -> String @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:Elem> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
  class <constant:Class> < ::<constant:Module> () -> <Class:Class> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : superclass> () -> Class @ rbi/stdlib.rbi:__LINE__
    method allocate () -> untyped @ rbi/stdlib.rbi:__LINE__
    method clone () -> Class @ rbi/stdlib.rbi:__LINE__
    method dup () -> Class @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Class @ rbi/stdlib.rbi:__LINE__
    method include (arg0) -> Class @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Module @ rbi/stdlib.rbi:__LINE__
    method inherited (arg0) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Class @ rbi/stdlib.rbi:__LINE__
    method instance_methods (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method name () -> String @ rbi/stdlib.rbi:__LINE__
    method prepend (arg0) -> Class @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Module @ rbi/stdlib.rbi:__LINE__
    method private_class_method (arg0) -> Class @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method private_constant (arg0) -> Class @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method public_class_method (arg0) -> Class @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method public_constant (arg0) -> Class @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method superclass () -> Class | NilClass @ rbi/stdlib.rbi:__LINE__
    method taint () -> Class @ rbi/stdlib.rbi:__LINE__
    method trust () -> Class @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Class @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Class @ rbi/stdlib.rbi:__LINE__
  class <constant:ClosedQueueError> < ::<constant:StopIteration> () -> <Class:ClosedQueueError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> ClosedQueueError @ rbi/stdlib.rbi:__LINE__
    method dup () -> ClosedQueueError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> ClosedQueueError @ rbi/stdlib.rbi:__LINE__
    method taint () -> ClosedQueueError @ rbi/stdlib.rbi:__LINE__
    method trust () -> ClosedQueueError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> ClosedQueueError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> ClosedQueueError @ rbi/stdlib.rbi:__LINE__
  class <constant:Comparable> (<constant:BasicObject>) -> <Class:Comparable> @ rbi/stdlib.rbi:__LINE__
  class <constant:Complex> < ::<constant:Numeric> () -> <Class:Complex> @ rbi/stdlib.rbi:__LINE__
    method * (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method ** (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method + (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method +@ () -> Complex @ rbi/stdlib.rbi:__LINE__
    method - (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method -@ () -> Complex @ rbi/stdlib.rbi:__LINE__
    method / (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : **> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : *> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : +> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : -> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : /> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : quo> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : rationalize> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : **> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : *> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : +> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : -> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : /> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : quo> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : **> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : *> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : +> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : -> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : /> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : quo> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : **> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : *> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : +> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : -> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : /> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : quo> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method == (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method abs () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method abs2 () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method angle () -> Float @ rbi/stdlib.rbi:__LINE__
    method arg () -> Float @ rbi/stdlib.rbi:__LINE__
    method clone () -> Complex @ rbi/stdlib.rbi:__LINE__
    method coerce (arg0) -> TupleType {
      0 = Complex
      1 = Complex
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method conj () -> Complex @ rbi/stdlib.rbi:__LINE__
    method conjugate () -> Complex @ rbi/stdlib.rbi:__LINE__
    method denominator () -> Integer @ rbi/stdlib.rbi:__LINE__
    method dup () -> Complex @ rbi/stdlib.rbi:__LINE__
    method eql? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method equal? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method fdiv (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Complex @ rbi/stdlib.rbi:__LINE__
    method hash () -> Integer @ rbi/stdlib.rbi:__LINE__
    method imag () -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method imaginary () -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method magnitude () -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method numerator () -> Complex @ rbi/stdlib.rbi:__LINE__
    method phase () -> Float @ rbi/stdlib.rbi:__LINE__
    method polar () -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    } @ rbi/stdlib.rbi:__LINE__
    method quo (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method rationalize () -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method real () -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method real? () -> FalseClass @ rbi/stdlib.rbi:__LINE__
    method rect () -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    } @ rbi/stdlib.rbi:__LINE__
    method rectangular () -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    } @ rbi/stdlib.rbi:__LINE__
    method taint () -> Complex @ rbi/stdlib.rbi:__LINE__
    method to_c () -> Complex @ rbi/stdlib.rbi:__LINE__
    method to_f () -> Float @ rbi/stdlib.rbi:__LINE__
    method to_i () -> Integer @ rbi/stdlib.rbi:__LINE__
    method to_r () -> Rational @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method trust () -> Complex @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Complex @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Complex @ rbi/stdlib.rbi:__LINE__
    method zero? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    static-field <constant:I> -> Complex @ rbi/stdlib.rbi:__LINE__
  class <constant:Coverage> (<constant:BasicObject>) -> <Class:Coverage> @ rbi/stdlib.rbi:__LINE__
  class <constant:Data> < ::<constant:Object> () -> <Class:Data> @ rbi/stdlib.rbi:__LINE__
    method clone () -> Data @ rbi/stdlib.rbi:__LINE__
    method dup () -> Data @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Data @ rbi/stdlib.rbi:__LINE__
    method taint () -> Data @ rbi/stdlib.rbi:__LINE__
    method trust () -> Data @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Data @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Data @ rbi/stdlib.rbi:__LINE__
  class <constant:Date> < ::<constant:Object> (<constant:Comparable>) -> <Class:Date> @ rbi/stdlib.rbi:__LINE__
    class <constant:Infinity> < ::<constant:Numeric> () -> <Class:Date::Infinity> @ rbi/stdlib.rbi:__LINE__
      method +@ () -> Date::Infinity @ rbi/date.rbi:3
      method -@ () -> Date::Infinity @ rbi/date.rbi:6
      method <=> (other) -> Integer | NilClass @ rbi/date.rbi:9
        argument other<> -> untyped @ rbi/date.rbi:8
      method abs () -> Date::Infinity @ rbi/date.rbi:18
      method coerce (other) -> Numeric @ rbi/date.rbi:15
        argument other<> -> untyped @ rbi/date.rbi:14
      method d () -> TrueClass | FalseClass @ rbi/date.rbi:33
      method finite? () -> TrueClass | FalseClass @ rbi/date.rbi:24
      method infinite? () -> TrueClass | FalseClass @ rbi/date.rbi:27
      method nan? () -> TrueClass | FalseClass @ rbi/date.rbi:30
      method to_f () -> Float @ rbi/date.rbi:12
      method zero? () -> TrueClass | FalseClass @ rbi/date.rbi:21
    class <singleton class:<constant:Infinity>> < ::<singleton class:<constant:Numeric>> () @ rbi/date.rbi:1
    method + (arg0) -> untyped @ rbi/date.rbi:83
      argument arg0<> -> untyped @ rbi/date.rbi:82
    method - (arg0) -> untyped @ rbi/date.rbi:89
      argument arg0<> -> untyped @ rbi/date.rbi:88
    method << (arg0) -> untyped @ rbi/date.rbi:59
      argument arg0<> -> untyped @ rbi/date.rbi:58
    method <=> (arg0) -> untyped @ rbi/date.rbi:56
      argument arg0<> -> untyped @ rbi/date.rbi:55
    method === (arg0) -> untyped @ rbi/date.rbi:65
      argument arg0<> -> untyped @ rbi/date.rbi:64
    method >> (arg0) -> untyped @ rbi/date.rbi:62
      argument arg0<> -> untyped @ rbi/date.rbi:61
    method ajd () -> untyped @ rbi/date.rbi:80
    method amjd () -> untyped @ rbi/date.rbi:191
    method asctime () -> untyped @ rbi/date.rbi:155
    method blank? () -> untyped @ rbi/date.rbi:149
    method clone () -> Date @ rbi/stdlib.rbi:__LINE__
    method ctime () -> untyped @ rbi/date.rbi:113
    method cwday () -> untyped @ rbi/date.rbi:206
    method cweek () -> untyped @ rbi/date.rbi:203
    method cwyear () -> untyped @ rbi/date.rbi:200
    method day () -> untyped @ rbi/date.rbi:95
    method day_fraction () -> untyped @ rbi/date.rbi:197
    method downto (arg0) -> untyped @ rbi/date.rbi:152
      argument arg0<> -> untyped @ rbi/date.rbi:151
    method dup () -> Date @ rbi/stdlib.rbi:__LINE__
    method england () -> untyped @ rbi/date.rbi:224
    method eql? (arg0) -> untyped @ rbi/date.rbi:68
      argument arg0<> -> untyped @ rbi/date.rbi:67
    method freeze () -> Date @ rbi/stdlib.rbi:__LINE__
    method friday? () -> untyped @ rbi/date.rbi:143
    method gregorian () -> untyped @ rbi/date.rbi:230
    method gregorian? () -> untyped @ rbi/date.rbi:215
    method hash () -> untyped @ rbi/date.rbi:209
    method httpdate () -> untyped @ rbi/date.rbi:185
    method initialize (year, month, mday, start) -> Date @ rbi/date.rbi:43
      argument mday<optional> -> Integer @ rbi/date.rbi:40
      argument month<optional> -> Integer @ rbi/date.rbi:39
      argument start<optional> -> Integer @ rbi/date.rbi:41
      argument year<optional> -> Integer @ rbi/date.rbi:38
    method inspect () -> untyped @ rbi/date.rbi:86
    method iso8601 () -> untyped @ rbi/date.rbi:170
    method italy () -> untyped @ rbi/date.rbi:221
    method jd () -> untyped @ rbi/date.rbi:125
    method jisx0301 () -> untyped @ rbi/date.rbi:188
    method julian () -> untyped @ rbi/date.rbi:227
    method julian? () -> untyped @ rbi/date.rbi:212
    method ld () -> untyped @ rbi/date.rbi:236
    method leap? () -> untyped @ rbi/date.rbi:167
    method localize (locale, options) -> untyped @ rbi/date.rbi:53
      argument locale<optional> -> untyped @ rbi/date.rbi:49
      argument options<optional> -> untyped @ rbi/date.rbi:50
    method marshal_dump () -> untyped @ rbi/date.rbi:74
    method marshal_load (arg0) -> untyped @ rbi/date.rbi:77
      argument arg0<> -> untyped @ rbi/date.rbi:76
    method mday () -> untyped @ rbi/date.rbi:92
    method mjd () -> untyped @ rbi/date.rbi:194
    method mon () -> untyped @ rbi/date.rbi:98
    method monday? () -> untyped @ rbi/date.rbi:131
    method month () -> untyped @ rbi/date.rbi:101
    method new_start (arg0) -> untyped @ rbi/date.rbi:218
      argument arg0<repeated> -> untyped @ rbi/date.rbi:217
    method next () -> untyped @ rbi/date.rbi:245
    method next_day (arg0) -> untyped @ rbi/date.rbi:233
      argument arg0<repeated> -> untyped @ rbi/date.rbi:232
    method next_month (arg0) -> untyped @ rbi/date.rbi:239
      argument arg0<repeated> -> untyped @ rbi/date.rbi:238
    method next_year (arg0) -> untyped @ rbi/date.rbi:251
      argument arg0<repeated> -> untyped @ rbi/date.rbi:250
    method pretty_date () -> untyped @ rbi/date.rbi:116
    method prev_day (arg0) -> untyped @ rbi/date.rbi:242
      argument arg0<repeated> -> untyped @ rbi/date.rbi:241
    method prev_month (arg0) -> untyped @ rbi/date.rbi:248
      argument arg0<repeated> -> untyped @ rbi/date.rbi:247
    method prev_year (arg0) -> untyped @ rbi/date.rbi:254
      argument arg0<repeated> -> untyped @ rbi/date.rbi:253
    method rfc2822 () -> untyped @ rbi/date.rbi:179
    method rfc3339 () -> untyped @ rbi/date.rbi:173
    method rfc822 () -> untyped @ rbi/date.rbi:182
    method saturday? () -> untyped @ rbi/date.rbi:146
    method start () -> untyped @ rbi/date.rbi:71
    method step (arg0) -> untyped @ rbi/date.rbi:140
      argument arg0<repeated> -> untyped @ rbi/date.rbi:139
    method strftime (arg0) -> untyped @ rbi/date.rbi:158
      argument arg0<repeated> -> untyped @ rbi/date.rbi:157
    method succ () -> untyped @ rbi/date.rbi:119
    method sunday? () -> untyped @ rbi/date.rbi:128
    method taint () -> Date @ rbi/stdlib.rbi:__LINE__
    method thursday? () -> untyped @ rbi/date.rbi:161
    method to_date () -> Date @ rbi/date.rbi:260
    method to_datetime () -> DateTime @ rbi/date.rbi:263
    method to_s () -> untyped @ rbi/date.rbi:164
    method to_time () -> Time @ rbi/date.rbi:257
    method to_utc_time () -> untyped @ rbi/date.rbi:122
    method trust () -> Date @ rbi/stdlib.rbi:__LINE__
    method tuesday? () -> untyped @ rbi/date.rbi:134
    method untaint () -> Date @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Date @ rbi/stdlib.rbi:__LINE__
    method upto (arg0) -> untyped @ rbi/date.rbi:46
      argument arg0<> -> untyped @ rbi/date.rbi:45
    method wday () -> untyped @ rbi/date.rbi:107
    method wednesday? () -> untyped @ rbi/date.rbi:137
    method xmlschema () -> untyped @ rbi/date.rbi:176
    method yday () -> untyped @ rbi/date.rbi:110
    method year () -> untyped @ rbi/date.rbi:104
    static-field <constant:ABBR_DAYNAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ABBR_MONTHNAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:DAYNAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ENGLAND> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:GREGORIAN> -> Float @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ITALY> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:JULIAN> -> Float @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MONTHNAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
  class <constant:DateTime> < ::<constant:Date> () -> <Class:DateTime> @ rbi/stdlib.rbi:__LINE__
    method blank? () -> untyped @ rbi/date.rbi:428
    method clone () -> DateTime @ rbi/stdlib.rbi:__LINE__
    method dup () -> DateTime @ rbi/stdlib.rbi:__LINE__
    method freeze () -> DateTime @ rbi/stdlib.rbi:__LINE__
    method hour () -> untyped @ rbi/date.rbi:386
    method iso8601 (arg0) -> untyped @ rbi/date.rbi:395
      argument arg0<repeated> -> untyped @ rbi/date.rbi:394
    method jisx0301 (arg0) -> untyped @ rbi/date.rbi:404
      argument arg0<repeated> -> untyped @ rbi/date.rbi:403
    method localize (locale, options) -> untyped @ rbi/date.rbi:438
      argument locale<optional> -> untyped @ rbi/date.rbi:434
      argument options<optional> -> untyped @ rbi/date.rbi:435
    method min () -> untyped @ rbi/date.rbi:371
    method minute () -> untyped @ rbi/date.rbi:407
    method new_offset (arg0) -> untyped @ rbi/date.rbi:416
      argument arg0<repeated> -> untyped @ rbi/date.rbi:415
    method offset () -> untyped @ rbi/date.rbi:377
    method rfc3339 (arg0) -> untyped @ rbi/date.rbi:398
      argument arg0<repeated> -> untyped @ rbi/date.rbi:397
    method sec () -> untyped @ rbi/date.rbi:383
    method sec_fraction () -> untyped @ rbi/date.rbi:410
    method second () -> untyped @ rbi/date.rbi:392
    method second_fraction () -> untyped @ rbi/date.rbi:413
    method strftime (arg0) -> untyped @ rbi/date.rbi:389
      argument arg0<repeated> -> untyped @ rbi/date.rbi:388
    method taint () -> DateTime @ rbi/stdlib.rbi:__LINE__
    method to_date () -> Date @ rbi/date.rbi:422
    method to_datetime () -> DateTime @ rbi/date.rbi:425
    method to_s () -> untyped @ rbi/date.rbi:374
    method to_time () -> Time @ rbi/date.rbi:419
    method to_utc_time () -> untyped @ rbi/date.rbi:431
    method trust () -> DateTime @ rbi/stdlib.rbi:__LINE__
    method untaint () -> DateTime @ rbi/stdlib.rbi:__LINE__
    method untrust () -> DateTime @ rbi/stdlib.rbi:__LINE__
    method xmlschema (arg0) -> untyped @ rbi/date.rbi:401
      argument arg0<repeated> -> untyped @ rbi/date.rbi:400
    method zone () -> untyped @ rbi/date.rbi:380
    static-field <constant:ABBR_DAYNAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ABBR_MONTHNAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:DAYNAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ENGLAND> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:GREGORIAN> -> Float @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ITALY> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:JULIAN> -> Float @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MONTHNAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
  class <constant:DidYouMean> (<constant:BasicObject>) -> <Class:DidYouMean> @ rbi/stdlib.rbi:__LINE__
    class <constant:ClassNameChecker> < ::<constant:Object> () -> <Class:DidYouMean::ClassNameChecker> @ rbi/stdlib.rbi:__LINE__
      class <constant:ClassName> () -> <Class:DidYouMean::ClassNameChecker::ClassName> @ rbi/stdlib.rbi:__LINE__
        static-field <constant:RUBYGEMS_ACTIVATION_MONITOR> -> Monitor @ rbi/stdlib.rbi:__LINE__
      class <singleton class:<constant:ClassName>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    class <constant:Correctable> (<constant:BasicObject>) -> <Class:DidYouMean::Correctable> @ rbi/stdlib.rbi:__LINE__
    class <constant:Formatter> < ::<constant:Object> () -> <Class:DidYouMean::Formatter> @ rbi/stdlib.rbi:__LINE__
    class <constant:Jaro> (<constant:BasicObject>) -> <Class:DidYouMean::Jaro> @ rbi/stdlib.rbi:__LINE__
    class <constant:JaroWinkler> (<constant:BasicObject>) -> <Class:DidYouMean::JaroWinkler> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:THRESHOLD> -> Float @ rbi/stdlib.rbi:__LINE__
      static-field <constant:WEIGHT> -> Float @ rbi/stdlib.rbi:__LINE__
    class <constant:Levenshtein> (<constant:BasicObject>) -> <Class:DidYouMean::Levenshtein> @ rbi/stdlib.rbi:__LINE__
    class <constant:MethodNameChecker> < ::<constant:Object> () -> <Class:DidYouMean::MethodNameChecker> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:NAMES_TO_EXCLUDE> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    class <constant:NameErrorCheckers> (<constant:BasicObject>) -> <Class:DidYouMean::NameErrorCheckers> @ rbi/stdlib.rbi:__LINE__
    class <constant:NullChecker> < ::<constant:Object> () -> <Class:DidYouMean::NullChecker> @ rbi/stdlib.rbi:__LINE__
    class <constant:SpellChecker> < ::<constant:Object> () -> <Class:DidYouMean::SpellChecker> @ rbi/stdlib.rbi:__LINE__
    class <constant:VariableNameChecker> < ::<constant:Object> () -> <Class:DidYouMean::VariableNameChecker> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:NAMES_TO_EXCLUDE> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ClassNameChecker>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Correctable>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Formatter>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Jaro>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:JaroWinkler>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Levenshtein>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:MethodNameChecker>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:NameErrorCheckers>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:NullChecker>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:SpellChecker>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:VariableNameChecker>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IGNORED_CALLERS> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SPELL_CHECKERS> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:VERSION> -> String @ rbi/stdlib.rbi:__LINE__
  class <constant:Dir>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Dir> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method clone () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method close () -> NilClass @ rbi/stdlib.rbi:__LINE__
    method dup () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method each (blk) -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method fileno () -> Integer @ rbi/stdlib.rbi:__LINE__
    method freeze () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method initialize (arg0, arg1) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Encoding @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method path () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method pos () -> Integer @ rbi/stdlib.rbi:__LINE__
    method pos= (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method read () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method rewind () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method seek (arg0) -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method taint () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method tell () -> Integer @ rbi/stdlib.rbi:__LINE__
    method to_path () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method trust () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untaint () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untrust () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:Elem> -> String @ rbi/stdlib.rbi:__LINE__
  class <constant:EOFError> < ::<constant:IOError> () -> <Class:EOFError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> EOFError @ rbi/stdlib.rbi:__LINE__
    method dup () -> EOFError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> EOFError @ rbi/stdlib.rbi:__LINE__
    method taint () -> EOFError @ rbi/stdlib.rbi:__LINE__
    method trust () -> EOFError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> EOFError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> EOFError @ rbi/stdlib.rbi:__LINE__
  class <constant:Encoding> < ::<constant:Object> () -> <Class:Encoding> @ rbi/stdlib.rbi:__LINE__
    class <constant:CompatibilityError> < ::<constant:EncodingError> () -> <Class:Encoding::CompatibilityError> @ rbi/stdlib.rbi:__LINE__
    class <constant:Converter> < ::<constant:Data> () -> <Class:Encoding::Converter> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:AFTER_OUTPUT> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:CRLF_NEWLINE_DECORATOR> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:CR_NEWLINE_DECORATOR> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:INVALID_MASK> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:INVALID_REPLACE> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:PARTIAL_INPUT> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:UNDEF_HEX_CHARREF> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:UNDEF_MASK> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:UNDEF_REPLACE> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:UNIVERSAL_NEWLINE_DECORATOR> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:XML_ATTR_CONTENT_DECORATOR> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:XML_ATTR_QUOTE_DECORATOR> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:XML_TEXT_DECORATOR> -> Integer @ rbi/stdlib.rbi:__LINE__
    class <constant:ConverterNotFoundError> < ::<constant:EncodingError> () -> <Class:Encoding::ConverterNotFoundError> @ rbi/stdlib.rbi:__LINE__
    class <constant:InvalidByteSequenceError> < ::<constant:EncodingError> () -> <Class:Encoding::InvalidByteSequenceError> @ rbi/stdlib.rbi:__LINE__
    class <constant:UndefinedConversionError> < ::<constant:EncodingError> () -> <Class:Encoding::UndefinedConversionError> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:CompatibilityError>> < ::<singleton class:<constant:EncodingError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Converter>> < ::<singleton class:<constant:Data>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ConverterNotFoundError>> < ::<singleton class:<constant:EncodingError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:InvalidByteSequenceError>> < ::<singleton class:<constant:EncodingError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:UndefinedConversionError>> < ::<singleton class:<constant:EncodingError>> () @ rbi/stdlib.rbi:__LINE__
    method ascii_compatible? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method clone () -> Encoding @ rbi/stdlib.rbi:__LINE__
    method dummy? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method dup () -> Encoding @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Encoding @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method name () -> String @ rbi/stdlib.rbi:__LINE__
    method names () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method replicate (name) -> Encoding @ rbi/stdlib.rbi:__LINE__
      argument name<> -> String @ rbi/stdlib.rbi:__LINE__
    method taint () -> Encoding @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method trust () -> Encoding @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Encoding @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ANSI_X3_4_1968> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ASCII> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ASCII_8BIT> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:BIG5> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:BIG5_HKSCS> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:BIG5_HKSCS_2008> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:BIG5_UAO> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:BINARY> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP1250> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP1251> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP1252> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP1253> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP1254> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP1255> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP1256> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP1257> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP1258> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP437> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP50220> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP50221> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP51932> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP65000> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP65001> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP737> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP775> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP850> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP852> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP855> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP857> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP860> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP861> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP862> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP863> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP864> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP865> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP866> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP869> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP874> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP878> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP932> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP936> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP949> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP950> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CP951> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CSWINDOWS31J> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EBCDIC_CP_US> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EMACS_MULE> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EUCCN> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EUCJP> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EUCJP_MS> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EUCKR> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EUCTW> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EUC_CN> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EUC_JISX0213> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EUC_JIS_2004> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EUC_JP> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EUC_JP_MS> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EUC_KR> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EUC_TW> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:GB12345> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:GB18030> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:GB1988> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:GB2312> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:GBK> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM037> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM437> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM737> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM775> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM850> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM852> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM855> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM857> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM860> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM861> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM862> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM863> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM864> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM865> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM866> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IBM869> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO2022_JP2> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO2022_JP> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_10> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_11> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_13> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_14> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_15> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_16> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_1> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_2> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_3> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_4> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_5> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_6> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_7> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_8> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO8859_9> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_2022_JP> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_2022_JP_2> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_2022_JP_KDDI> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_10> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_11> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_13> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_14> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_15> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_16> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_1> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_2> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_3> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_4> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_5> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_6> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_7> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_8> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ISO_8859_9> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:KOI8_R> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:KOI8_U> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MACCENTEURO> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MACCROATIAN> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MACCYRILLIC> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MACGREEK> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MACICELAND> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MACJAPAN> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MACJAPANESE> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MACROMAN> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MACROMANIA> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MACTHAI> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MACTURKISH> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MACUKRAINE> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:PCK> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SHIFT_JIS> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SJIS> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SJIS_DOCOMO> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SJIS_KDDI> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SJIS_SOFTBANK> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:STATELESS_ISO_2022_JP> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:STATELESS_ISO_2022_JP_KDDI> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:TIS_620> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UCS_2BE> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UCS_4BE> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UCS_4LE> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:US_ASCII> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF8_DOCOMO> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF8_KDDI> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF8_MAC> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF8_SOFTBANK> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF_16> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF_16BE> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF_16LE> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF_32> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF_32BE> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF_32LE> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF_7> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF_8> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF_8_HFS> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UTF_8_MAC> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WINDOWS_1250> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WINDOWS_1251> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WINDOWS_1252> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WINDOWS_1253> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WINDOWS_1254> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WINDOWS_1255> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WINDOWS_1256> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WINDOWS_1257> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WINDOWS_1258> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WINDOWS_31J> -> Encoding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WINDOWS_874> -> Encoding @ rbi/stdlib.rbi:__LINE__
  class <constant:EncodingError> < ::<constant:StandardError> () -> <Class:EncodingError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> EncodingError @ rbi/stdlib.rbi:__LINE__
    method dup () -> EncodingError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> EncodingError @ rbi/stdlib.rbi:__LINE__
    method taint () -> EncodingError @ rbi/stdlib.rbi:__LINE__
    method trust () -> EncodingError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> EncodingError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> EncodingError @ rbi/stdlib.rbi:__LINE__
  class <constant:Enumerable>[<constant:Elem>] (<constant:BasicObject>) -> <Class:Enumerable> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : all?> (blk) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : any?> (blk) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : collect> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : count> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : cycle> (n) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument n<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : detect> (ifnone) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument ifnone<optional> -> Proc @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : drop_while> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_cons> (n) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument n<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_slice> (n) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument n<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_with_index> () -> AppliedType {
      klass = ::<constant:Enumerable>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : find> (ifnone) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument ifnone<optional> -> Proc @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : find_all> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : find_index> (blk) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument value<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : first> (n) -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          ]
        } | NilClass @ rbi/stdlib.rbi:__LINE__
      argument n<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : grep> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : group_by> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : inject> (arg0) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Symbol @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument initial<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : map> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : max> (blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : max_by> (blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : min> (blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : min_by> (blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : minmax> (blk) -> TupleType {
      0 = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      1 = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : minmax_by> (blk) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : none?> (blk) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : one?> (blk) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : partition> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : reduce> (arg0) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Symbol @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument initial<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : reject> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : reverse_each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : select> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : sort> (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : sort_by> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : take_while> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : count> (blk) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : find_index> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument value<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : inject> (initial, blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument initial<optional> -> LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : max> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : max_by> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : min> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : min_by> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : reduce> (initial, blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument initial<optional> -> LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : inject> (blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument initial<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : max> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : max_by> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : min> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : min_by> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : reduce> (blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument initial<optional> @ rbi/stdlib.rbi:__LINE__
    method all? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method any? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method collect (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method collect_concat (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = AppliedType {
              klass = ::<constant:Enumerator>
              targs = [
                <constant:Elem> = BasicObject
              ]
            }
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method count () -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method cycle (n, blk) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument n<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method detect (ifnone, blk) -> NilClass | LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument ifnone<optional> -> Proc @ rbi/stdlib.rbi:__LINE__
    method drop (n) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument n<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method drop_while (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_cons (n, blk) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument n<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method each_slice (n, blk) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument n<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method each_with_index (blk) -> AppliedType {
      klass = ::<constant:Enumerable>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method entries () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method find (ifnone, blk) -> NilClass | LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument ifnone<optional> -> Proc @ rbi/stdlib.rbi:__LINE__
    method find_all (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method find_index (value) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument value<optional> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method first () -> NilClass | LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument n<optional> @ rbi/stdlib.rbi:__LINE__
    method flat_map (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = AppliedType {
              klass = ::<constant:Enumerator>
              targs = [
                <constant:Elem> = BasicObject
              ]
            }
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method grep (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method group_by (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
            ]
          }
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method include? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method inject (initial, arg0) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Symbol @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument initial<optional> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method map (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method max () -> LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method max_by () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method member? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method min () -> LambdaParam(::<constant:Enumerable>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method min_by () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method minmax () -> TupleType {
      0 = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      1 = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method minmax_by () -> TupleType {
      0 = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      1 = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method none? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method one? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method partition (blk) -> TupleType {
      0 = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
            ]
          }
      1 = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
            ]
          }
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method reduce (initial, arg0) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Symbol @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument initial<optional> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method reject (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method reverse_each (blk) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method select (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method sort () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method sort_by (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method take (n) -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          ]
        } | NilClass @ rbi/stdlib.rbi:__LINE__
      argument n<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method take_while (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method to_a () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method to_h () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        <constant:V> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
  class <constant:Enumerator>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Enumerator> @ rbi/stdlib.rbi:__LINE__
    class <constant:Generator>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Enumerator::Generator> @ rbi/stdlib.rbi:__LINE__
      typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
    class <constant:Lazy>[<constant:Elem>] < ::<constant:Enumerator> () -> <Class:Enumerator::Lazy> @ rbi/stdlib.rbi:__LINE__
      typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
    class <constant:Yielder> < ::<constant:Object> () -> <Class:Enumerator::Yielder> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Generator>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Lazy>> < ::<singleton class:<constant:Enumerator>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Yielder>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_with_index> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
            1 = Integer
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_with_object> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
            1 = untyped
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : initialize> (arg0, blk) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Proc @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = untyped
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : with_index> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
            1 = Integer
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : with_object> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
            1 = untyped
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method clone () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method dup () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method each (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_with_index (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
          <constant:Arg1> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_with_object (arg0, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
          <constant:Arg1> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method feed (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Enumerator>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method freeze () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method initialize (arg0, blk) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = untyped
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method next () -> LambdaParam(::<constant:Enumerator>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method next_values () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method peek () -> LambdaParam(::<constant:Enumerator>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method peek_values () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method rewind () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method size () -> Integer | Float | NilClass @ rbi/stdlib.rbi:__LINE__
    method taint () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method trust () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untaint () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untrust () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method with_index (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
          <constant:Arg1> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method with_object (arg0, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
          <constant:Arg1> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
  class <constant:Errno> (<constant:BasicObject>) -> <Class:Errno> @ rbi/stdlib.rbi:__LINE__
    class <constant:E2BIG> < ::<constant:SystemCallError> () -> <Class:Errno::E2BIG> @ rbi/stdlib.rbi:__LINE__
    class <constant:EACCES> < ::<constant:SystemCallError> () -> <Class:Errno::EACCES> @ rbi/stdlib.rbi:__LINE__
    class <constant:EADDRINUSE> < ::<constant:SystemCallError> () -> <Class:Errno::EADDRINUSE> @ rbi/stdlib.rbi:__LINE__
    class <constant:EADDRNOTAVAIL> < ::<constant:SystemCallError> () -> <Class:Errno::EADDRNOTAVAIL> @ rbi/stdlib.rbi:__LINE__
    class <constant:EADV> < ::<constant:SystemCallError> () -> <Class:Errno::EADV> @ rbi/stdlib.rbi:__LINE__
    class <constant:EAFNOSUPPORT> < ::<constant:SystemCallError> () -> <Class:Errno::EAFNOSUPPORT> @ rbi/stdlib.rbi:__LINE__
    class <constant:EAGAIN> < ::<constant:SystemCallError> () -> <Class:Errno::EAGAIN> @ rbi/stdlib.rbi:__LINE__
    class <constant:EALREADY> < ::<constant:SystemCallError> () -> <Class:Errno::EALREADY> @ rbi/stdlib.rbi:__LINE__
    class <constant:EBADE> < ::<constant:SystemCallError> () -> <Class:Errno::EBADE> @ rbi/stdlib.rbi:__LINE__
    class <constant:EBADF> < ::<constant:SystemCallError> () -> <Class:Errno::EBADF> @ rbi/stdlib.rbi:__LINE__
    class <constant:EBADFD> < ::<constant:SystemCallError> () -> <Class:Errno::EBADFD> @ rbi/stdlib.rbi:__LINE__
    class <constant:EBADMSG> < ::<constant:SystemCallError> () -> <Class:Errno::EBADMSG> @ rbi/stdlib.rbi:__LINE__
    class <constant:EBADR> < ::<constant:SystemCallError> () -> <Class:Errno::EBADR> @ rbi/stdlib.rbi:__LINE__
    class <constant:EBADRQC> < ::<constant:SystemCallError> () -> <Class:Errno::EBADRQC> @ rbi/stdlib.rbi:__LINE__
    class <constant:EBADSLT> < ::<constant:SystemCallError> () -> <Class:Errno::EBADSLT> @ rbi/stdlib.rbi:__LINE__
    class <constant:EBFONT> < ::<constant:SystemCallError> () -> <Class:Errno::EBFONT> @ rbi/stdlib.rbi:__LINE__
    class <constant:EBUSY> < ::<constant:SystemCallError> () -> <Class:Errno::EBUSY> @ rbi/stdlib.rbi:__LINE__
    class <constant:ECANCELED> < ::<constant:SystemCallError> () -> <Class:Errno::ECANCELED> @ rbi/stdlib.rbi:__LINE__
    class <constant:ECHILD> < ::<constant:SystemCallError> () -> <Class:Errno::ECHILD> @ rbi/stdlib.rbi:__LINE__
    class <constant:ECHRNG> < ::<constant:SystemCallError> () -> <Class:Errno::ECHRNG> @ rbi/stdlib.rbi:__LINE__
    class <constant:ECOMM> < ::<constant:SystemCallError> () -> <Class:Errno::ECOMM> @ rbi/stdlib.rbi:__LINE__
    class <constant:ECONNABORTED> < ::<constant:SystemCallError> () -> <Class:Errno::ECONNABORTED> @ rbi/stdlib.rbi:__LINE__
    class <constant:ECONNREFUSED> < ::<constant:SystemCallError> () -> <Class:Errno::ECONNREFUSED> @ rbi/stdlib.rbi:__LINE__
    class <constant:ECONNRESET> < ::<constant:SystemCallError> () -> <Class:Errno::ECONNRESET> @ rbi/stdlib.rbi:__LINE__
    class <constant:EDEADLK> < ::<constant:SystemCallError> () -> <Class:Errno::EDEADLK> @ rbi/stdlib.rbi:__LINE__
    class <constant:EDESTADDRREQ> < ::<constant:SystemCallError> () -> <Class:Errno::EDESTADDRREQ> @ rbi/stdlib.rbi:__LINE__
    class <constant:EDOM> < ::<constant:SystemCallError> () -> <Class:Errno::EDOM> @ rbi/stdlib.rbi:__LINE__
    class <constant:EDOTDOT> < ::<constant:SystemCallError> () -> <Class:Errno::EDOTDOT> @ rbi/stdlib.rbi:__LINE__
    class <constant:EDQUOT> < ::<constant:SystemCallError> () -> <Class:Errno::EDQUOT> @ rbi/stdlib.rbi:__LINE__
    class <constant:EEXIST> < ::<constant:SystemCallError> () -> <Class:Errno::EEXIST> @ rbi/stdlib.rbi:__LINE__
    class <constant:EFAULT> < ::<constant:SystemCallError> () -> <Class:Errno::EFAULT> @ rbi/stdlib.rbi:__LINE__
    class <constant:EFBIG> < ::<constant:SystemCallError> () -> <Class:Errno::EFBIG> @ rbi/stdlib.rbi:__LINE__
    class <constant:EHOSTDOWN> < ::<constant:SystemCallError> () -> <Class:Errno::EHOSTDOWN> @ rbi/stdlib.rbi:__LINE__
    class <constant:EHOSTUNREACH> < ::<constant:SystemCallError> () -> <Class:Errno::EHOSTUNREACH> @ rbi/stdlib.rbi:__LINE__
    class <constant:EHWPOISON> < ::<constant:SystemCallError> () -> <Class:Errno::EHWPOISON> @ rbi/stdlib.rbi:__LINE__
    class <constant:EIDRM> < ::<constant:SystemCallError> () -> <Class:Errno::EIDRM> @ rbi/stdlib.rbi:__LINE__
    class <constant:EILSEQ> < ::<constant:SystemCallError> () -> <Class:Errno::EILSEQ> @ rbi/stdlib.rbi:__LINE__
    class <constant:EINPROGRESS> < ::<constant:SystemCallError> () -> <Class:Errno::EINPROGRESS> @ rbi/stdlib.rbi:__LINE__
    class <constant:EINTR> < ::<constant:SystemCallError> () -> <Class:Errno::EINTR> @ rbi/stdlib.rbi:__LINE__
    class <constant:EINVAL> < ::<constant:SystemCallError> () -> <Class:Errno::EINVAL> @ rbi/stdlib.rbi:__LINE__
    class <constant:EIO> < ::<constant:SystemCallError> () -> <Class:Errno::EIO> @ rbi/stdlib.rbi:__LINE__
    class <constant:EISCONN> < ::<constant:SystemCallError> () -> <Class:Errno::EISCONN> @ rbi/stdlib.rbi:__LINE__
    class <constant:EISDIR> < ::<constant:SystemCallError> () -> <Class:Errno::EISDIR> @ rbi/stdlib.rbi:__LINE__
    class <constant:EISNAM> < ::<constant:SystemCallError> () -> <Class:Errno::EISNAM> @ rbi/stdlib.rbi:__LINE__
    class <constant:EKEYEXPIRED> < ::<constant:SystemCallError> () -> <Class:Errno::EKEYEXPIRED> @ rbi/stdlib.rbi:__LINE__
    class <constant:EKEYREJECTED> < ::<constant:SystemCallError> () -> <Class:Errno::EKEYREJECTED> @ rbi/stdlib.rbi:__LINE__
    class <constant:EKEYREVOKED> < ::<constant:SystemCallError> () -> <Class:Errno::EKEYREVOKED> @ rbi/stdlib.rbi:__LINE__
    class <constant:EL2HLT> < ::<constant:SystemCallError> () -> <Class:Errno::EL2HLT> @ rbi/stdlib.rbi:__LINE__
    class <constant:EL2NSYNC> < ::<constant:SystemCallError> () -> <Class:Errno::EL2NSYNC> @ rbi/stdlib.rbi:__LINE__
    class <constant:EL3HLT> < ::<constant:SystemCallError> () -> <Class:Errno::EL3HLT> @ rbi/stdlib.rbi:__LINE__
    class <constant:EL3RST> < ::<constant:SystemCallError> () -> <Class:Errno::EL3RST> @ rbi/stdlib.rbi:__LINE__
    class <constant:ELIBACC> < ::<constant:SystemCallError> () -> <Class:Errno::ELIBACC> @ rbi/stdlib.rbi:__LINE__
    class <constant:ELIBBAD> < ::<constant:SystemCallError> () -> <Class:Errno::ELIBBAD> @ rbi/stdlib.rbi:__LINE__
    class <constant:ELIBEXEC> < ::<constant:SystemCallError> () -> <Class:Errno::ELIBEXEC> @ rbi/stdlib.rbi:__LINE__
    class <constant:ELIBMAX> < ::<constant:SystemCallError> () -> <Class:Errno::ELIBMAX> @ rbi/stdlib.rbi:__LINE__
    class <constant:ELIBSCN> < ::<constant:SystemCallError> () -> <Class:Errno::ELIBSCN> @ rbi/stdlib.rbi:__LINE__
    class <constant:ELNRNG> < ::<constant:SystemCallError> () -> <Class:Errno::ELNRNG> @ rbi/stdlib.rbi:__LINE__
    class <constant:ELOOP> < ::<constant:SystemCallError> () -> <Class:Errno::ELOOP> @ rbi/stdlib.rbi:__LINE__
    class <constant:EMEDIUMTYPE> < ::<constant:SystemCallError> () -> <Class:Errno::EMEDIUMTYPE> @ rbi/stdlib.rbi:__LINE__
    class <constant:EMFILE> < ::<constant:SystemCallError> () -> <Class:Errno::EMFILE> @ rbi/stdlib.rbi:__LINE__
    class <constant:EMLINK> < ::<constant:SystemCallError> () -> <Class:Errno::EMLINK> @ rbi/stdlib.rbi:__LINE__
    class <constant:EMSGSIZE> < ::<constant:SystemCallError> () -> <Class:Errno::EMSGSIZE> @ rbi/stdlib.rbi:__LINE__
    class <constant:EMULTIHOP> < ::<constant:SystemCallError> () -> <Class:Errno::EMULTIHOP> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENAMETOOLONG> < ::<constant:SystemCallError> () -> <Class:Errno::ENAMETOOLONG> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENAVAIL> < ::<constant:SystemCallError> () -> <Class:Errno::ENAVAIL> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENETDOWN> < ::<constant:SystemCallError> () -> <Class:Errno::ENETDOWN> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENETRESET> < ::<constant:SystemCallError> () -> <Class:Errno::ENETRESET> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENETUNREACH> < ::<constant:SystemCallError> () -> <Class:Errno::ENETUNREACH> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENFILE> < ::<constant:SystemCallError> () -> <Class:Errno::ENFILE> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOANO> < ::<constant:SystemCallError> () -> <Class:Errno::ENOANO> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOBUFS> < ::<constant:SystemCallError> () -> <Class:Errno::ENOBUFS> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOCSI> < ::<constant:SystemCallError> () -> <Class:Errno::ENOCSI> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENODATA> < ::<constant:SystemCallError> () -> <Class:Errno::ENODATA> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENODEV> < ::<constant:SystemCallError> () -> <Class:Errno::ENODEV> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOENT> < ::<constant:SystemCallError> () -> <Class:Errno::ENOENT> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOEXEC> < ::<constant:SystemCallError> () -> <Class:Errno::ENOEXEC> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOKEY> < ::<constant:SystemCallError> () -> <Class:Errno::ENOKEY> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOLCK> < ::<constant:SystemCallError> () -> <Class:Errno::ENOLCK> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOLINK> < ::<constant:SystemCallError> () -> <Class:Errno::ENOLINK> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOMEDIUM> < ::<constant:SystemCallError> () -> <Class:Errno::ENOMEDIUM> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOMEM> < ::<constant:SystemCallError> () -> <Class:Errno::ENOMEM> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOMSG> < ::<constant:SystemCallError> () -> <Class:Errno::ENOMSG> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENONET> < ::<constant:SystemCallError> () -> <Class:Errno::ENONET> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOPKG> < ::<constant:SystemCallError> () -> <Class:Errno::ENOPKG> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOPROTOOPT> < ::<constant:SystemCallError> () -> <Class:Errno::ENOPROTOOPT> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOSPC> < ::<constant:SystemCallError> () -> <Class:Errno::ENOSPC> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOSR> < ::<constant:SystemCallError> () -> <Class:Errno::ENOSR> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOSTR> < ::<constant:SystemCallError> () -> <Class:Errno::ENOSTR> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOSYS> < ::<constant:SystemCallError> () -> <Class:Errno::ENOSYS> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOTBLK> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTBLK> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOTCONN> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTCONN> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOTDIR> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTDIR> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOTEMPTY> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTEMPTY> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOTNAM> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTNAM> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOTRECOVERABLE> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTRECOVERABLE> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOTSOCK> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTSOCK> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOTTY> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTTY> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENOTUNIQ> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTUNIQ> @ rbi/stdlib.rbi:__LINE__
    class <constant:ENXIO> < ::<constant:SystemCallError> () -> <Class:Errno::ENXIO> @ rbi/stdlib.rbi:__LINE__
    class <constant:EOPNOTSUPP> < ::<constant:SystemCallError> () -> <Class:Errno::EOPNOTSUPP> @ rbi/stdlib.rbi:__LINE__
    class <constant:EOVERFLOW> < ::<constant:SystemCallError> () -> <Class:Errno::EOVERFLOW> @ rbi/stdlib.rbi:__LINE__
    class <constant:EOWNERDEAD> < ::<constant:SystemCallError> () -> <Class:Errno::EOWNERDEAD> @ rbi/stdlib.rbi:__LINE__
    class <constant:EPERM> < ::<constant:SystemCallError> () -> <Class:Errno::EPERM> @ rbi/stdlib.rbi:__LINE__
    class <constant:EPFNOSUPPORT> < ::<constant:SystemCallError> () -> <Class:Errno::EPFNOSUPPORT> @ rbi/stdlib.rbi:__LINE__
    class <constant:EPIPE> < ::<constant:SystemCallError> () -> <Class:Errno::EPIPE> @ rbi/stdlib.rbi:__LINE__
    class <constant:EPROTO> < ::<constant:SystemCallError> () -> <Class:Errno::EPROTO> @ rbi/stdlib.rbi:__LINE__
    class <constant:EPROTONOSUPPORT> < ::<constant:SystemCallError> () -> <Class:Errno::EPROTONOSUPPORT> @ rbi/stdlib.rbi:__LINE__
    class <constant:EPROTOTYPE> < ::<constant:SystemCallError> () -> <Class:Errno::EPROTOTYPE> @ rbi/stdlib.rbi:__LINE__
    class <constant:ERANGE> < ::<constant:SystemCallError> () -> <Class:Errno::ERANGE> @ rbi/stdlib.rbi:__LINE__
    class <constant:EREMCHG> < ::<constant:SystemCallError> () -> <Class:Errno::EREMCHG> @ rbi/stdlib.rbi:__LINE__
    class <constant:EREMOTE> < ::<constant:SystemCallError> () -> <Class:Errno::EREMOTE> @ rbi/stdlib.rbi:__LINE__
    class <constant:EREMOTEIO> < ::<constant:SystemCallError> () -> <Class:Errno::EREMOTEIO> @ rbi/stdlib.rbi:__LINE__
    class <constant:ERESTART> < ::<constant:SystemCallError> () -> <Class:Errno::ERESTART> @ rbi/stdlib.rbi:__LINE__
    class <constant:ERFKILL> < ::<constant:SystemCallError> () -> <Class:Errno::ERFKILL> @ rbi/stdlib.rbi:__LINE__
    class <constant:EROFS> < ::<constant:SystemCallError> () -> <Class:Errno::EROFS> @ rbi/stdlib.rbi:__LINE__
    class <constant:ESHUTDOWN> < ::<constant:SystemCallError> () -> <Class:Errno::ESHUTDOWN> @ rbi/stdlib.rbi:__LINE__
    class <constant:ESOCKTNOSUPPORT> < ::<constant:SystemCallError> () -> <Class:Errno::ESOCKTNOSUPPORT> @ rbi/stdlib.rbi:__LINE__
    class <constant:ESPIPE> < ::<constant:SystemCallError> () -> <Class:Errno::ESPIPE> @ rbi/stdlib.rbi:__LINE__
    class <constant:ESRCH> < ::<constant:SystemCallError> () -> <Class:Errno::ESRCH> @ rbi/stdlib.rbi:__LINE__
    class <constant:ESRMNT> < ::<constant:SystemCallError> () -> <Class:Errno::ESRMNT> @ rbi/stdlib.rbi:__LINE__
    class <constant:ESTALE> < ::<constant:SystemCallError> () -> <Class:Errno::ESTALE> @ rbi/stdlib.rbi:__LINE__
    class <constant:ESTRPIPE> < ::<constant:SystemCallError> () -> <Class:Errno::ESTRPIPE> @ rbi/stdlib.rbi:__LINE__
    class <constant:ETIME> < ::<constant:SystemCallError> () -> <Class:Errno::ETIME> @ rbi/stdlib.rbi:__LINE__
    class <constant:ETIMEDOUT> < ::<constant:SystemCallError> () -> <Class:Errno::ETIMEDOUT> @ rbi/stdlib.rbi:__LINE__
    class <constant:ETOOMANYREFS> < ::<constant:SystemCallError> () -> <Class:Errno::ETOOMANYREFS> @ rbi/stdlib.rbi:__LINE__
    class <constant:ETXTBSY> < ::<constant:SystemCallError> () -> <Class:Errno::ETXTBSY> @ rbi/stdlib.rbi:__LINE__
    class <constant:EUCLEAN> < ::<constant:SystemCallError> () -> <Class:Errno::EUCLEAN> @ rbi/stdlib.rbi:__LINE__
    class <constant:EUNATCH> < ::<constant:SystemCallError> () -> <Class:Errno::EUNATCH> @ rbi/stdlib.rbi:__LINE__
    class <constant:EUSERS> < ::<constant:SystemCallError> () -> <Class:Errno::EUSERS> @ rbi/stdlib.rbi:__LINE__
    class <constant:EXDEV> < ::<constant:SystemCallError> () -> <Class:Errno::EXDEV> @ rbi/stdlib.rbi:__LINE__
    class <constant:EXFULL> < ::<constant:SystemCallError> () -> <Class:Errno::EXFULL> @ rbi/stdlib.rbi:__LINE__
    class <constant:NOERROR> < ::<constant:SystemCallError> () -> <Class:Errno::NOERROR> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:E2BIG>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EACCES>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EADDRINUSE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EADDRNOTAVAIL>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EADV>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EAFNOSUPPORT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EAGAIN>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EALREADY>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EBADE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EBADF>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EBADFD>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EBADMSG>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EBADR>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EBADRQC>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EBADSLT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EBFONT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EBUSY>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ECANCELED>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ECHILD>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ECHRNG>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ECOMM>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ECONNABORTED>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ECONNREFUSED>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ECONNRESET>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EDEADLK>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EDESTADDRREQ>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EDOM>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EDOTDOT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EDQUOT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EEXIST>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EFAULT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EFBIG>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EHOSTDOWN>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EHOSTUNREACH>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EHWPOISON>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EIDRM>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EILSEQ>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EINPROGRESS>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EINTR>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EINVAL>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EIO>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EISCONN>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EISDIR>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EISNAM>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EKEYEXPIRED>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EKEYREJECTED>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EKEYREVOKED>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EL2HLT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EL2NSYNC>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EL3HLT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EL3RST>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ELIBACC>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ELIBBAD>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ELIBEXEC>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ELIBMAX>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ELIBSCN>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ELNRNG>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ELOOP>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EMEDIUMTYPE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EMFILE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EMLINK>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EMSGSIZE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EMULTIHOP>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENAMETOOLONG>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENAVAIL>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENETDOWN>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENETRESET>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENETUNREACH>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENFILE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOANO>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOBUFS>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOCSI>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENODATA>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENODEV>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOENT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOEXEC>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOKEY>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOLCK>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOLINK>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOMEDIUM>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOMEM>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOMSG>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENONET>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOPKG>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOPROTOOPT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOSPC>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOSR>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOSTR>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOSYS>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOTBLK>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOTCONN>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOTDIR>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOTEMPTY>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOTNAM>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOTRECOVERABLE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOTSOCK>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOTTY>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENOTUNIQ>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ENXIO>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EOPNOTSUPP>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EOVERFLOW>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EOWNERDEAD>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EPERM>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EPFNOSUPPORT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EPIPE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EPROTO>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EPROTONOSUPPORT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EPROTOTYPE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ERANGE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EREMCHG>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EREMOTE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EREMOTEIO>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ERESTART>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ERFKILL>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EROFS>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ESHUTDOWN>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ESOCKTNOSUPPORT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ESPIPE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ESRCH>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ESRMNT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ESTALE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ESTRPIPE>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ETIME>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ETIMEDOUT>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ETOOMANYREFS>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ETXTBSY>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EUCLEAN>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EUNATCH>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EUSERS>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EXDEV>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EXFULL>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:NOERROR>> < ::<singleton class:<constant:SystemCallError>> () @ rbi/stdlib.rbi:__LINE__
  class <constant:Exception> < ::<constant:Object> () -> <Class:Exception> @ rbi/stdlib.rbi:__LINE__
    method == (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method backtrace () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method backtrace_locations () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Thread::Backtrace::Location
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method cause () -> NilClass @ rbi/stdlib.rbi:__LINE__
    method clone () -> Exception @ rbi/stdlib.rbi:__LINE__
    method dup () -> Exception @ rbi/stdlib.rbi:__LINE__
    method exception (arg0) -> Exception @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Exception @ rbi/stdlib.rbi:__LINE__
    method initialize (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method message () -> String @ rbi/stdlib.rbi:__LINE__
    method set_backtrace (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method taint () -> Exception @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method trust () -> Exception @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Exception @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Exception @ rbi/stdlib.rbi:__LINE__
  class <constant:FalseClass> < ::<constant:Object> () -> <Class:FalseClass> @ rbi/stdlib.rbi:__LINE__
    method clone () -> FalseClass @ rbi/stdlib.rbi:__LINE__
    method dup () -> FalseClass @ rbi/stdlib.rbi:__LINE__
    method freeze () -> FalseClass @ rbi/stdlib.rbi:__LINE__
    method taint () -> FalseClass @ rbi/stdlib.rbi:__LINE__
    method trust () -> FalseClass @ rbi/stdlib.rbi:__LINE__
    method untaint () -> FalseClass @ rbi/stdlib.rbi:__LINE__
    method untrust () -> FalseClass @ rbi/stdlib.rbi:__LINE__
  class <constant:Fiber> < ::<constant:Object> () -> <Class:Fiber> @ rbi/stdlib.rbi:__LINE__
    method clone () -> Fiber @ rbi/stdlib.rbi:__LINE__
    method dup () -> Fiber @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Fiber @ rbi/stdlib.rbi:__LINE__
    method taint () -> Fiber @ rbi/stdlib.rbi:__LINE__
    method trust () -> Fiber @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Fiber @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Fiber @ rbi/stdlib.rbi:__LINE__
  class <constant:FiberError> < ::<constant:StandardError> () -> <Class:FiberError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> FiberError @ rbi/stdlib.rbi:__LINE__
    method dup () -> FiberError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> FiberError @ rbi/stdlib.rbi:__LINE__
    method taint () -> FiberError @ rbi/stdlib.rbi:__LINE__
    method trust () -> FiberError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> FiberError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> FiberError @ rbi/stdlib.rbi:__LINE__
  class <constant:File>[<constant:Elem>] < ::<constant:IO> () -> <Class:File> @ rbi/stdlib.rbi:__LINE__
    class <constant:Constants> (<constant:BasicObject>) -> <Class:File::Constants> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:APPEND> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:BINARY> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:CREAT> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DIRECT> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DSYNC> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:EXCL> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FNM_CASEFOLD> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FNM_DOTMATCH> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FNM_EXTGLOB> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FNM_NOESCAPE> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FNM_PATHNAME> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FNM_SHORTNAME> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FNM_SYSCASE> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:LOCK_EX> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:LOCK_NB> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:LOCK_SH> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:LOCK_UN> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:NOATIME> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:NOCTTY> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:NOFOLLOW> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:NONBLOCK> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:NULL> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:RDONLY> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:RDWR> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:RSYNC> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SHARE_DELETE> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SYNC> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TMPFILE> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TRUNC> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:WRONLY> -> Integer @ rbi/stdlib.rbi:__LINE__
    class <constant:Stat> < ::<constant:Object> (<constant:Comparable>) -> <Class:File::Stat> @ rbi/stdlib.rbi:__LINE__
      method <=> (other) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
        argument other<> -> File::Stat @ rbi/stdlib.rbi:__LINE__
      method atime () -> Time @ rbi/stdlib.rbi:__LINE__
      method birthtime () -> Time @ rbi/stdlib.rbi:__LINE__
      method blksize () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      method blockdev? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method blocks () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      method chardev? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method ctime () -> Time @ rbi/stdlib.rbi:__LINE__
      method dev () -> Integer @ rbi/stdlib.rbi:__LINE__
      method dev_major () -> Integer @ rbi/stdlib.rbi:__LINE__
      method dev_minor () -> Integer @ rbi/stdlib.rbi:__LINE__
      method directory? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method executable? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method executable_real? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method file? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method ftype () -> String @ rbi/stdlib.rbi:__LINE__
      method gid () -> Integer @ rbi/stdlib.rbi:__LINE__
      method grpowned? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method initialize (file) -> Object @ rbi/stdlib.rbi:__LINE__
        argument file<> -> String @ rbi/stdlib.rbi:__LINE__
      method ino () -> Integer @ rbi/stdlib.rbi:__LINE__
      method inspect () -> String @ rbi/stdlib.rbi:__LINE__
      method mode () -> Integer @ rbi/stdlib.rbi:__LINE__
      method mtime () -> Time @ rbi/stdlib.rbi:__LINE__
      method nlink () -> Integer @ rbi/stdlib.rbi:__LINE__
      method owned? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method pipe? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method rdev () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      method rdev_major () -> Integer @ rbi/stdlib.rbi:__LINE__
      method rdev_minor () -> Integer @ rbi/stdlib.rbi:__LINE__
      method readable? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method readable_real? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method setgid? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method setuid? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method size () -> Integer @ rbi/stdlib.rbi:__LINE__
      method socket? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method sticky? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method symlink? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method uid () -> Integer @ rbi/stdlib.rbi:__LINE__
      method world_readable? () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      method world_writable? () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      method writable? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method writable_real? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method zero? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Constants>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Stat>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    method << (arg0) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : set_encoding> (int_enc) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument ext_or_ext_int_enc<optional> @ rbi/stdlib.rbi:__LINE__
      argument int_enc<optional> -> String | Encoding @ rbi/stdlib.rbi:__LINE__
    method atime () -> Time @ rbi/stdlib.rbi:__LINE__
    method binmode () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method birthtime () -> Time @ rbi/stdlib.rbi:__LINE__
    method chmod (mode) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument mode<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method chown (owner, group) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument group<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument owner<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method clone () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method ctime () -> Time @ rbi/stdlib.rbi:__LINE__
    method dup () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method each (sep, limit, blk) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method each_byte (blk) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_char (blk) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_codepoint (blk) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method flock (arg0) -> Integer | TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method flush () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method freeze () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method initialize (file, mode, perm, opt) -> Object @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
      argument mode<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument opt<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument perm<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method lstat () -> File::Stat @ rbi/stdlib.rbi:__LINE__
    method mtime () -> Time @ rbi/stdlib.rbi:__LINE__
    method path () -> String @ rbi/stdlib.rbi:__LINE__
    method set_encoding (ext_or_ext_int_enc) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument ext_or_ext_int_enc<optional> -> String | Encoding @ rbi/stdlib.rbi:__LINE__
      argument int_enc<optional> @ rbi/stdlib.rbi:__LINE__
    method size () -> Integer @ rbi/stdlib.rbi:__LINE__
    method taint () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method to_io () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method to_path () -> String @ rbi/stdlib.rbi:__LINE__
    method truncate (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method trust () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untaint () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untrust () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ALT_SEPARATOR> -> NilClass @ rbi/stdlib.rbi:__LINE__
    static-field <constant:APPEND> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:BINARY> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CREAT> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:DIRECT> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:DSYNC> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EXCL> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_CASEFOLD> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_DOTMATCH> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_EXTGLOB> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_NOESCAPE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_PATHNAME> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_SHORTNAME> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_SYSCASE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:LOCK_EX> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:LOCK_NB> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:LOCK_SH> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:LOCK_UN> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NOATIME> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NOCTTY> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NOFOLLOW> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NONBLOCK> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NULL> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:PATH_SEPARATOR> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RDONLY> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RDWR> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RSYNC> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SEEK_CUR> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SEEK_DATA> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SEEK_END> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SEEK_HOLE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SEEK_SET> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SEPARATOR> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SHARE_DELETE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SYNC> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:TMPFILE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:TRUNC> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WRONLY> -> Integer @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:Elem> -> String @ rbi/stdlib.rbi:__LINE__
  class <constant:FileTest> (<constant:BasicObject>) -> <Class:FileTest> @ rbi/stdlib.rbi:__LINE__
  class <constant:FileUtils> (<constant:BasicObject>) -> <Class:FileUtils> @ rbi/stdlib.rbi:__LINE__
  class <constant:Float> < ::<constant:Numeric> () -> <Class:Float> @ rbi/stdlib.rbi:__LINE__
    method % (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method * (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method ** (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method + (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method +@ () -> Float @ rbi/stdlib.rbi:__LINE__
    method - (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method -@ () -> Float @ rbi/stdlib.rbi:__LINE__
    method / (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method < (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <= (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <=> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : %> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : **> (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : *> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : +> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : -> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : /> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : <=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : <=>> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : <> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : >=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : >> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : coerce> (arg0) -> TupleType {
      0 = Float
      1 = Float
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : div> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : fdiv> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : modulo> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : quo> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : rationalize> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : round> (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : %> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : **> (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : *> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : +> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : -> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : /> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : <=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : <=>> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : <> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : >=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : >> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : div> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : fdiv> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : modulo> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : quo> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : %> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : **> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : *> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : +> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : -> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : /> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : <=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : <=>> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : <> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : >=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : >> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : div> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : fdiv> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : modulo> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : quo> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : **> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : *> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : +> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : -> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : /> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : fdiv> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : quo> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method == (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method === (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method > (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method >= (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method abs () -> Float @ rbi/stdlib.rbi:__LINE__
    method abs2 () -> Float @ rbi/stdlib.rbi:__LINE__
    method angle () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method arg () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method ceil () -> Integer @ rbi/stdlib.rbi:__LINE__
    method clone () -> Float @ rbi/stdlib.rbi:__LINE__
    method coerce (arg0) -> TupleType {
      0 = Float
      1 = Float
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method conj () -> Float @ rbi/stdlib.rbi:__LINE__
    method conjugate () -> Float @ rbi/stdlib.rbi:__LINE__
    method denominator () -> Integer @ rbi/stdlib.rbi:__LINE__
    method div (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method divmod (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method dup () -> Float @ rbi/stdlib.rbi:__LINE__
    method eql? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method equal? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method fdiv (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method finite? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method floor () -> Integer @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Float @ rbi/stdlib.rbi:__LINE__
    method hash () -> Integer @ rbi/stdlib.rbi:__LINE__
    method imag () -> Integer @ rbi/stdlib.rbi:__LINE__
    method imaginary () -> Integer @ rbi/stdlib.rbi:__LINE__
    method infinite? () -> Object @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method magnitude () -> Float @ rbi/stdlib.rbi:__LINE__
    method modulo (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method nan? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method next_float () -> Float @ rbi/stdlib.rbi:__LINE__
    method numerator () -> Integer @ rbi/stdlib.rbi:__LINE__
    method phase () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method prev_float () -> Float @ rbi/stdlib.rbi:__LINE__
    method quo (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method rationalize () -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method real () -> Float @ rbi/stdlib.rbi:__LINE__
    method real? () -> TrueClass @ rbi/stdlib.rbi:__LINE__
    method round () -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method taint () -> Float @ rbi/stdlib.rbi:__LINE__
    method to_c () -> Complex @ rbi/stdlib.rbi:__LINE__
    method to_f () -> Float @ rbi/stdlib.rbi:__LINE__
    method to_i () -> Integer @ rbi/stdlib.rbi:__LINE__
    method to_int () -> Integer @ rbi/stdlib.rbi:__LINE__
    method to_r () -> Rational @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method truncate () -> Integer @ rbi/stdlib.rbi:__LINE__
    method trust () -> Float @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Float @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Float @ rbi/stdlib.rbi:__LINE__
    method zero? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    static-field <constant:DIG> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EPSILON> -> Float @ rbi/stdlib.rbi:__LINE__
    static-field <constant:INFINITY> -> Float @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MANT_DIG> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MAX> -> Float @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MAX_10_EXP> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MAX_EXP> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MIN> -> Float @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MIN_10_EXP> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MIN_EXP> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NAN> -> Float @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RADIX> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ROUNDS> -> Integer @ rbi/stdlib.rbi:__LINE__
  class <constant:FloatDomainError> < ::<constant:RangeError> () -> <Class:FloatDomainError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> FloatDomainError @ rbi/stdlib.rbi:__LINE__
    method dup () -> FloatDomainError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> FloatDomainError @ rbi/stdlib.rbi:__LINE__
    method taint () -> FloatDomainError @ rbi/stdlib.rbi:__LINE__
    method trust () -> FloatDomainError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> FloatDomainError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> FloatDomainError @ rbi/stdlib.rbi:__LINE__
  class <constant:Forwardable> (<constant:BasicObject>) -> <Class:Forwardable> @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FILTER_EXCEPTION> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FORWARDABLE_VERSION> -> String @ rbi/stdlib.rbi:__LINE__
  class <constant:GC> (<constant:BasicObject>) -> <Class:GC> @ rbi/stdlib.rbi:__LINE__
    class <constant:Profiler> (<constant:BasicObject>) -> <Class:GC::Profiler> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Profiler>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    static-field <constant:INTERNAL_CONSTANTS> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:OPTS> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
  class <constant:Gem> (<constant:BasicObject>) -> <Class:Gem> @ rbi/stdlib.rbi:__LINE__
    class <constant:BasicSpecification> < ::<constant:Object> () -> <Class:Gem::BasicSpecification> @ rbi/stdlib.rbi:__LINE__
    class <constant:CommandLineError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::CommandLineError> @ rbi/stdlib.rbi:__LINE__
    class <constant:ConfigFile> () -> untyped @ rbi/stdlib.rbi:__LINE__
    class <constant:ConflictError> < ::<constant:Gem>::<constant:LoadError> () -> <Class:Gem::ConflictError> @ rbi/stdlib.rbi:__LINE__
    class <constant:Dependency> < ::<constant:Object> () -> <Class:Gem::Dependency> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TYPES> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    class <constant:DependencyError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::DependencyError> @ rbi/stdlib.rbi:__LINE__
    class <constant:DependencyRemovalException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::DependencyRemovalException> @ rbi/stdlib.rbi:__LINE__
    class <constant:DependencyResolutionError> < ::<constant:Gem>::<constant:DependencyError> () -> <Class:Gem::DependencyResolutionError> @ rbi/stdlib.rbi:__LINE__
    class <constant:Deprecate> (<constant:BasicObject>) -> <Class:Gem::Deprecate> @ rbi/stdlib.rbi:__LINE__
    class <constant:DocumentError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::DocumentError> @ rbi/stdlib.rbi:__LINE__
    class <constant:EndOfYAMLException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::EndOfYAMLException> @ rbi/stdlib.rbi:__LINE__
    class <constant:ErrorReason> < ::<constant:Object> () -> <Class:Gem::ErrorReason> @ rbi/stdlib.rbi:__LINE__
    class <constant:Exception> < ::<constant:RuntimeError> () -> <Class:Gem::Exception> @ rbi/stdlib.rbi:__LINE__
    class <constant:FilePermissionError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::FilePermissionError> @ rbi/stdlib.rbi:__LINE__
    class <constant:FormatException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::FormatException> @ rbi/stdlib.rbi:__LINE__
    class <constant:GemNotFoundException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::GemNotFoundException> @ rbi/stdlib.rbi:__LINE__
    class <constant:GemNotInHomeException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::GemNotInHomeException> @ rbi/stdlib.rbi:__LINE__
    class <constant:ImpossibleDependenciesError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::ImpossibleDependenciesError> @ rbi/stdlib.rbi:__LINE__
    class <constant:InstallError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::InstallError> @ rbi/stdlib.rbi:__LINE__
    class <constant:InvalidSpecificationException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::InvalidSpecificationException> @ rbi/stdlib.rbi:__LINE__
    class <constant:List>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Gem::List> @ rbi/stdlib.rbi:__LINE__
      typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
    class <constant:LoadError> < ::<constant:LoadError> () -> <Class:Gem::LoadError> @ rbi/stdlib.rbi:__LINE__
    class <constant:MissingSpecError> < ::<constant:Gem>::<constant:LoadError> () -> <Class:Gem::MissingSpecError> @ rbi/stdlib.rbi:__LINE__
    class <constant:MissingSpecVersionError> < ::<constant:Gem>::<constant:MissingSpecError> () -> <Class:Gem::MissingSpecVersionError> @ rbi/stdlib.rbi:__LINE__
    class <constant:OperationNotSupportedError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::OperationNotSupportedError> @ rbi/stdlib.rbi:__LINE__
    class <constant:PathSupport> < ::<constant:Object> () -> <Class:Gem::PathSupport> @ rbi/stdlib.rbi:__LINE__
    class <constant:Platform> < ::<constant:Object> () -> <Class:Gem::Platform> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:CURRENT> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:RUBY> -> String @ rbi/stdlib.rbi:__LINE__
    class <constant:PlatformMismatch> < ::<constant:Gem>::<constant:ErrorReason> () -> <Class:Gem::PlatformMismatch> @ rbi/stdlib.rbi:__LINE__
    class <constant:RemoteError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::RemoteError> @ rbi/stdlib.rbi:__LINE__
    class <constant:RemoteInstallationCancelled> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::RemoteInstallationCancelled> @ rbi/stdlib.rbi:__LINE__
    class <constant:RemoteInstallationSkipped> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::RemoteInstallationSkipped> @ rbi/stdlib.rbi:__LINE__
    class <constant:RemoteSourceException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::RemoteSourceException> @ rbi/stdlib.rbi:__LINE__
    class <constant:Requirement> < ::<constant:Object> () -> <Class:Gem::Requirement> @ rbi/stdlib.rbi:__LINE__
      class <constant:BadRequirementError> < ::<constant:ArgumentError> () -> <Class:Gem::Requirement::BadRequirementError> @ rbi/stdlib.rbi:__LINE__
      class <singleton class:<constant:BadRequirementError>> < ::<singleton class:<constant:ArgumentError>> () @ rbi/stdlib.rbi:__LINE__
      static-field <constant:OPS> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:PATTERN> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:PATTERN_RAW> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SOURCE_SET_REQUIREMENT> -> Object @ rbi/stdlib.rbi:__LINE__
    class <constant:RubyVersionMismatch> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::RubyVersionMismatch> @ rbi/stdlib.rbi:__LINE__
    class <constant:SourceFetchProblem> < ::<constant:Gem>::<constant:ErrorReason> () -> <Class:Gem::SourceFetchProblem> @ rbi/stdlib.rbi:__LINE__
    class <constant:SpecificGemNotFoundException> < ::<constant:Gem>::<constant:GemNotFoundException> () -> <Class:Gem::SpecificGemNotFoundException> @ rbi/stdlib.rbi:__LINE__
    class <constant:Specification> < ::<constant:Gem>::<constant:BasicSpecification> () -> <Class:Gem::Specification> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:CURRENT_SPECIFICATION_VERSION> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:EMPTY> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:MARSHAL_FIELDS> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:NONEXISTENT_SPECIFICATION_VERSION> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:NOT_FOUND> -> Object @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SPECIFICATION_VERSION_HISTORY> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TODAY> -> Time @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VALID_NAME_PATTERN> -> Regexp @ rbi/stdlib.rbi:__LINE__
    class <constant:StubSpecification> < ::<constant:Gem>::<constant:BasicSpecification> () -> <Class:Gem::StubSpecification> @ rbi/stdlib.rbi:__LINE__
      class <constant:StubLine> < ::<constant:Object> () -> <Class:Gem::StubSpecification::StubLine> @ rbi/stdlib.rbi:__LINE__
        static-field <constant:NO_EXTENSIONS> -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = untyped
          ]
        } @ rbi/stdlib.rbi:__LINE__
        static-field <constant:REQUIRE_PATHS> -> AppliedType {
          klass = ::<constant:Hash>
          targs = [
            <constant:K> = untyped
            <constant:V> = untyped
            <constant:Elem> = untyped
          ]
        } @ rbi/stdlib.rbi:__LINE__
        static-field <constant:REQUIRE_PATH_LIST> -> AppliedType {
          klass = ::<constant:Hash>
          targs = [
            <constant:K> = untyped
            <constant:V> = untyped
            <constant:Elem> = untyped
          ]
        } @ rbi/stdlib.rbi:__LINE__
      class <singleton class:<constant:StubLine>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
      static-field <constant:OPEN_MODE> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:PREFIX> -> String @ rbi/stdlib.rbi:__LINE__
    class <constant:SystemExitException> < ::<constant:SystemExit> () -> <Class:Gem::SystemExitException> @ rbi/stdlib.rbi:__LINE__
    class <constant:UnsatisfiableDependencyError> < ::<constant:Gem>::<constant:DependencyError> () -> <Class:Gem::UnsatisfiableDependencyError> @ rbi/stdlib.rbi:__LINE__
    class <constant:VerificationError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::VerificationError> @ rbi/stdlib.rbi:__LINE__
    class <constant:Version> < ::<constant:Object> (<constant:Comparable>) -> <Class:Gem::Version> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ANCHORED_VERSION_PATTERN> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION_PATTERN> -> String @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:BasicSpecification>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:CommandLineError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ConflictError>> < ::<constant:Gem>::<singleton class:<constant:LoadError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Dependency>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:DependencyError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:DependencyRemovalException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:DependencyResolutionError>> < ::<constant:Gem>::<singleton class:<constant:DependencyError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Deprecate>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:DocumentError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EndOfYAMLException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ErrorReason>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Exception>> < ::<singleton class:<constant:RuntimeError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:FilePermissionError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:FormatException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:GemNotFoundException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:GemNotInHomeException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ImpossibleDependenciesError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:InstallError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:InvalidSpecificationException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:List>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:LoadError>> < ::<singleton class:<constant:LoadError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:MissingSpecError>> < ::<constant:Gem>::<singleton class:<constant:LoadError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:MissingSpecVersionError>> < ::<constant:Gem>::<singleton class:<constant:MissingSpecError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:OperationNotSupportedError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:PathSupport>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Platform>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:PlatformMismatch>> < ::<constant:Gem>::<singleton class:<constant:ErrorReason>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:RemoteError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:RemoteInstallationCancelled>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:RemoteInstallationSkipped>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:RemoteSourceException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Requirement>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:RubyVersionMismatch>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:SourceFetchProblem>> < ::<constant:Gem>::<singleton class:<constant:ErrorReason>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:SpecificGemNotFoundException>> < ::<constant:Gem>::<singleton class:<constant:GemNotFoundException>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Specification>> < ::<constant:Gem>::<singleton class:<constant:BasicSpecification>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:StubSpecification>> < ::<constant:Gem>::<singleton class:<constant:BasicSpecification>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:SystemExitException>> < ::<singleton class:<constant:SystemExit>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:UnsatisfiableDependencyError>> < ::<constant:Gem>::<singleton class:<constant:DependencyError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:VerificationError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Version>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    static-field <constant:DEFAULT_HOST> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:GEM_DEP_FILES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:GEM_PRELUDE_SUCKAGE> -> NilClass @ rbi/stdlib.rbi:__LINE__
    static-field <constant:LOADED_SPECS_MUTEX> -> Thread::Mutex @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MARSHAL_SPEC_DIR> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:READ_BINARY_ERRORS> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:REPOSITORY_DEFAULT_GEM_SUBDIRECTORIES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:REPOSITORY_SUBDIRECTORIES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBYGEMS_DIR> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:VERSION> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WIN_PATTERNS> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WRITE_BINARY_ERRORS> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
  class <constant:Hash>[<constant:K>, <constant:V>, <constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Hash> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : default> (arg0, blk) -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Hash>#<constant:V>)
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : delete> (arg0, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : delete_if> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_key> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_pair> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_value> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : fetch> (arg0, arg1) -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : keep_if> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : merge> (arg0, blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = BasicObject
          <constant:V> = BasicObject
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc3>
        targs = [
          <constant:Return> = BasicObject | LambdaParam(::<constant:Hash>#<constant:V>)
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
          <constant:Arg2> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : reject> (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : fetch> (arg0, blk) -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Hash>#<constant:V>)
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method [] (arg0) -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
    method []= (arg0, arg1) -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
    method assoc (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:K>) | LambdaParam(::<constant:Hash>#<constant:V>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
    method clear () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method clone () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method compare_by_identity () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method compare_by_identity? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method default (arg0) -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method default= (arg0) -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
    method delete (arg0) -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method delete_if (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method dup () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method each (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_key (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_pair (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_value (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method empty? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method fetch (arg0) -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method freeze () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method has_key? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method has_value? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method invert () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method keep_if (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method key (arg0) -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method key? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method keys () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:K>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method length () -> Integer @ rbi/stdlib.rbi:__LINE__
    method member? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method merge (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = BasicObject
          <constant:V> = BasicObject
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method rassoc (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:K>) | LambdaParam(::<constant:Hash>#<constant:V>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
    method rehash () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method reject () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method reject! (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method select (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method select! (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method shift () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:K>) | LambdaParam(::<constant:Hash>#<constant:V>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method size () -> Integer @ rbi/stdlib.rbi:__LINE__
    method store (arg0, arg1) -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> LambdaParam(::<constant:Hash>#<constant:V>) @ rbi/stdlib.rbi:__LINE__
    method taint () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method to_a () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:K>) | LambdaParam(::<constant:Hash>#<constant:V>)
            ]
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method to_hash () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method trust () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untaint () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untrust () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method value? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method values () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:V>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method values_at (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:V>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> LambdaParam(::<constant:Hash>#<constant:K>) @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:K> @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:V> @ rbi/stdlib.rbi:__LINE__
  class <constant:IO>[<constant:Elem>] < ::<constant:Object> (<constant:Constants>, <constant:Enumerable>) -> <Class:IO> @ rbi/stdlib.rbi:__LINE__
    class <constant:EAGAINWaitReadable> < ::<constant:Errno>::<constant:EAGAIN> (<constant:WaitReadable>) -> <Class:IO::EAGAINWaitReadable> @ rbi/stdlib.rbi:__LINE__
    class <constant:EAGAINWaitWritable> < ::<constant:Errno>::<constant:EAGAIN> (<constant:WaitWritable>) -> <Class:IO::EAGAINWaitWritable> @ rbi/stdlib.rbi:__LINE__
    class <constant:EINPROGRESSWaitReadable> < ::<constant:Errno>::<constant:EINPROGRESS> (<constant:WaitReadable>) -> <Class:IO::EINPROGRESSWaitReadable> @ rbi/stdlib.rbi:__LINE__
    class <constant:EINPROGRESSWaitWritable> < ::<constant:Errno>::<constant:EINPROGRESS> (<constant:WaitWritable>) -> <Class:IO::EINPROGRESSWaitWritable> @ rbi/stdlib.rbi:__LINE__
    class <constant:WaitReadable> (<constant:BasicObject>) -> <Class:IO::WaitReadable> @ rbi/stdlib.rbi:__LINE__
    class <constant:WaitWritable> (<constant:BasicObject>) -> <Class:IO::WaitWritable> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EAGAINWaitReadable>> < ::<constant:Errno>::<singleton class:<constant:EAGAIN>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EAGAINWaitWritable>> < ::<constant:Errno>::<singleton class:<constant:EAGAIN>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EINPROGRESSWaitReadable>> < ::<constant:Errno>::<singleton class:<constant:EINPROGRESS>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:EINPROGRESSWaitWritable>> < ::<constant:Errno>::<singleton class:<constant:EINPROGRESS>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:WaitReadable>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:WaitWritable>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method << (arg0) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : bytes> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : chars> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : codepoints> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each> (sep, limit) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_byte> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_char> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_codepoint> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_line> (sep, limit) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : lines> (sep, limit) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : read_nonblock> (len, buf) -> String @ rbi/stdlib.rbi:__LINE__
      argument buf<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument len<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : readpartial> (maxlen, outbuf) -> String @ rbi/stdlib.rbi:__LINE__
      argument maxlen<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument outbuf<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : reopen> (mode_str) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument mode_str<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument other_IO<> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : set_encoding> (int_enc) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument ext_or_ext_int_enc<optional> @ rbi/stdlib.rbi:__LINE__
      argument int_enc<optional> -> String | Encoding @ rbi/stdlib.rbi:__LINE__
    method advise (arg0, offset, len) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
      argument len<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument offset<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method autoclose= (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method autoclose? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method binmode () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method binmode? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method bytes (blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method chars (blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method clone () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method close () -> NilClass @ rbi/stdlib.rbi:__LINE__
    method close_on_exec= (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method close_on_exec? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method close_read () -> NilClass @ rbi/stdlib.rbi:__LINE__
    method close_write () -> NilClass @ rbi/stdlib.rbi:__LINE__
    method closed? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method codepoints (blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method dup () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method each (sep, limit, blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method each_byte (blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_char (blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_codepoint (blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_line (sep, limit, blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method eof () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method eof? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method fcntl (integer_cmd, arg) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg<> -> String | Integer @ rbi/stdlib.rbi:__LINE__
      argument integer_cmd<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method fdatasync () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
    method fileno () -> Integer @ rbi/stdlib.rbi:__LINE__
    method flush () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method freeze () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method fsync () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
    method getbyte () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
    method getc () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method gets (sep, limit) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method initialize (fd, mode, opt) -> Object @ rbi/stdlib.rbi:__LINE__
      argument fd<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument mode<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument opt<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method internal_encoding () -> Encoding @ rbi/stdlib.rbi:__LINE__
    method ioctl (integer_cmd, arg) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg<> -> String | Integer @ rbi/stdlib.rbi:__LINE__
      argument integer_cmd<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method isatty () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method lineno () -> Integer @ rbi/stdlib.rbi:__LINE__
    method lineno= (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method lines (sep, limit, blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method pid () -> Integer @ rbi/stdlib.rbi:__LINE__
    method pos () -> Integer @ rbi/stdlib.rbi:__LINE__
    method pos= (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method print (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method printf (format_string, arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument format_string<> -> String @ rbi/stdlib.rbi:__LINE__
    method putc (arg0) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Numeric | String @ rbi/stdlib.rbi:__LINE__
    method puts (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method read (length, outbuf) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument length<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument outbuf<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method read_nonblock (len) -> String @ rbi/stdlib.rbi:__LINE__
      argument buf<optional> @ rbi/stdlib.rbi:__LINE__
      argument len<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method readbyte () -> Integer @ rbi/stdlib.rbi:__LINE__
    method readchar () -> String @ rbi/stdlib.rbi:__LINE__
    method readline (sep, limit) -> String @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method readlines (sep, limit) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method readpartial (maxlen) -> String @ rbi/stdlib.rbi:__LINE__
      argument maxlen<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument outbuf<optional> @ rbi/stdlib.rbi:__LINE__
    method reopen (other_IO) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument mode_str<optional> @ rbi/stdlib.rbi:__LINE__
      argument other_IO<> -> AppliedType {
        klass = ::<constant:IO>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method rewind () -> Integer @ rbi/stdlib.rbi:__LINE__
    method seek (amount, whence) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument amount<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument whence<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method set_encoding (ext_or_ext_int_enc) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument ext_or_ext_int_enc<optional> -> String | Encoding @ rbi/stdlib.rbi:__LINE__
      argument int_enc<optional> @ rbi/stdlib.rbi:__LINE__
    method stat () -> File::Stat @ rbi/stdlib.rbi:__LINE__
    method sync () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method sync= (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method sysread (maxlen, outbuf) -> String @ rbi/stdlib.rbi:__LINE__
      argument maxlen<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument outbuf<> -> String @ rbi/stdlib.rbi:__LINE__
    method sysseek (amount, whence) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument amount<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument whence<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method syswrite (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method taint () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method tell () -> Integer @ rbi/stdlib.rbi:__LINE__
    method to_i () -> Integer @ rbi/stdlib.rbi:__LINE__
    method to_io () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method trust () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method tty? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method ungetbyte (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String | Integer @ rbi/stdlib.rbi:__LINE__
    method ungetc (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method untaint () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untrust () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method write (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:APPEND> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:BINARY> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CREAT> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:DIRECT> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:DSYNC> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EXCL> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_CASEFOLD> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_DOTMATCH> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_EXTGLOB> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_NOESCAPE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_PATHNAME> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_SHORTNAME> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FNM_SYSCASE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:LOCK_EX> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:LOCK_NB> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:LOCK_SH> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:LOCK_UN> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NOATIME> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NOCTTY> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NOFOLLOW> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NONBLOCK> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NULL> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RDONLY> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RDWR> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RSYNC> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SEEK_CUR> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SEEK_DATA> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SEEK_END> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SEEK_HOLE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SEEK_SET> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SHARE_DELETE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SYNC> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:TMPFILE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:TRUNC> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WRONLY> -> Integer @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:Elem> -> String @ rbi/stdlib.rbi:__LINE__
  class <constant:IOError> < ::<constant:StandardError> () -> <Class:IOError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> IOError @ rbi/stdlib.rbi:__LINE__
    method dup () -> IOError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> IOError @ rbi/stdlib.rbi:__LINE__
    method taint () -> IOError @ rbi/stdlib.rbi:__LINE__
    method trust () -> IOError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> IOError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> IOError @ rbi/stdlib.rbi:__LINE__
  class <constant:IndexError> < ::<constant:StandardError> () -> <Class:IndexError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> IndexError @ rbi/stdlib.rbi:__LINE__
    method dup () -> IndexError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> IndexError @ rbi/stdlib.rbi:__LINE__
    method taint () -> IndexError @ rbi/stdlib.rbi:__LINE__
    method trust () -> IndexError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> IndexError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> IndexError @ rbi/stdlib.rbi:__LINE__
  class <constant:Integer> < ::<constant:Numeric> () -> <Class:Integer> @ rbi/stdlib.rbi:__LINE__
    method % (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method & (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method * (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method ** (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method + (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method +@ () -> Integer @ rbi/stdlib.rbi:__LINE__
    method - (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method -@ () -> Integer @ rbi/stdlib.rbi:__LINE__
    method / (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method < (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method << (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <= (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <=> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : %> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : **> (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : *> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : +> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : -> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : /> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : <=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : <=>> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : <> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : >=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : >> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : []> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : div> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : downto> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : fdiv> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : modulo> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : quo> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : rationalize> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : remainder> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : round> (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : times> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : upto> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : %> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : **> (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : *> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : +> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : -> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : /> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : <=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : <=>> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : <> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : >=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : >> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : []> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : div> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : fdiv> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : modulo> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : quo> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : remainder> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : %> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : **> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : *> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : +> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : -> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : /> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : <=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : <=>> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : <> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : >=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : >> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : []> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : div> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : fdiv> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : modulo> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : quo> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : remainder> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : **> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : *> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : +> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : -> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : /> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : fdiv> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : quo> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method == (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method === (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method > (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method >= (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method >> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method [] (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method ^ (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method abs () -> Integer @ rbi/stdlib.rbi:__LINE__
    method abs2 () -> Integer @ rbi/stdlib.rbi:__LINE__
    method angle () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method arg () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method bit_length () -> Integer @ rbi/stdlib.rbi:__LINE__
    method ceil () -> Integer @ rbi/stdlib.rbi:__LINE__
    method chr (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Encoding @ rbi/stdlib.rbi:__LINE__
    method clone () -> Integer @ rbi/stdlib.rbi:__LINE__
    method coerce (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method conj () -> Integer @ rbi/stdlib.rbi:__LINE__
    method conjugate () -> Integer @ rbi/stdlib.rbi:__LINE__
    method denominator () -> Integer @ rbi/stdlib.rbi:__LINE__
    method div (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method divmod (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method downto (arg0, blk) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method dup () -> Integer @ rbi/stdlib.rbi:__LINE__
    method eql? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method equal? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method even? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method fdiv (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method floor () -> Integer @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Integer @ rbi/stdlib.rbi:__LINE__
    method gcd (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method gcdlcm (arg0) -> TupleType {
      0 = Integer
      1 = Integer
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method hash () -> Integer @ rbi/stdlib.rbi:__LINE__
    method imag () -> Integer @ rbi/stdlib.rbi:__LINE__
    method imaginary () -> Integer @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method integer? () -> TrueClass @ rbi/stdlib.rbi:__LINE__
    method lcm (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method magnitude () -> Integer @ rbi/stdlib.rbi:__LINE__
    method modulo (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method next () -> Integer @ rbi/stdlib.rbi:__LINE__
    method numerator () -> Integer @ rbi/stdlib.rbi:__LINE__
    method odd? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method ord () -> Integer @ rbi/stdlib.rbi:__LINE__
    method phase () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method pred () -> Integer @ rbi/stdlib.rbi:__LINE__
    method quo (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method rationalize () -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method real () -> Integer @ rbi/stdlib.rbi:__LINE__
    method real? () -> TrueClass @ rbi/stdlib.rbi:__LINE__
    method remainder (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method round () -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method size () -> Integer @ rbi/stdlib.rbi:__LINE__
    method succ () -> Integer @ rbi/stdlib.rbi:__LINE__
    method taint () -> Integer @ rbi/stdlib.rbi:__LINE__
    method times (blk) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method to_c () -> Complex @ rbi/stdlib.rbi:__LINE__
    method to_f () -> Float @ rbi/stdlib.rbi:__LINE__
    method to_i () -> Integer @ rbi/stdlib.rbi:__LINE__
    method to_int () -> Integer @ rbi/stdlib.rbi:__LINE__
    method to_r () -> Rational @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method truncate () -> Integer @ rbi/stdlib.rbi:__LINE__
    method trust () -> Integer @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Integer @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Integer @ rbi/stdlib.rbi:__LINE__
    method upto (arg0, blk) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method zero? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method | (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method ~ () -> Integer @ rbi/stdlib.rbi:__LINE__
  class <constant:Interrupt> < ::<constant:SignalException> () -> <Class:Interrupt> @ rbi/stdlib.rbi:__LINE__
    method clone () -> Interrupt @ rbi/stdlib.rbi:__LINE__
    method dup () -> Interrupt @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Interrupt @ rbi/stdlib.rbi:__LINE__
    method taint () -> Interrupt @ rbi/stdlib.rbi:__LINE__
    method trust () -> Interrupt @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Interrupt @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Interrupt @ rbi/stdlib.rbi:__LINE__
  class <constant:Kernel> (<constant:BasicObject>) -> <Class:Kernel> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : Complex> (x) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument x<> -> String @ rbi/stdlib.rbi:__LINE__
      argument y<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : Rational> (x) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Object @ rbi/stdlib.rbi:__LINE__
      argument y<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : exit> (status) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument status<optional> -> Integer | TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : fail> (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : raise> (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : send> (arg0, arg1, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String | Symbol @ rbi/stdlib.rbi:__LINE__
      argument arg1<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : fail> (arg0, arg1) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Class @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : raise> (arg0, arg1, arg2) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Class @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : fail> (arg0, arg1, arg2) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Class @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : raise> (arg0, arg1, arg2) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Exception @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method Array (x) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Object @ rbi/stdlib.rbi:__LINE__
    method Complex (x, y) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument y<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
    method Float (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Numeric @ rbi/stdlib.rbi:__LINE__
    method Hash (x) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Object @ rbi/stdlib.rbi:__LINE__
    method Integer (arg, base) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg<> -> Numeric | String @ rbi/stdlib.rbi:__LINE__
      argument base<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method Rational (x, y) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument y<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
    method String (x) -> String @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Object @ rbi/stdlib.rbi:__LINE__
    method __callee__ () -> Symbol | NilClass @ rbi/stdlib.rbi:__LINE__
    method __dir__ () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method __method__ () -> Symbol | NilClass @ rbi/stdlib.rbi:__LINE__
    method ` (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method abort (msg) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument msg<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method at_exit (blk) -> Proc @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc0>
        targs = [
          <constant:Return> = BasicObject
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method autoload (_module, filename) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument _module<> -> String | Symbol @ rbi/stdlib.rbi:__LINE__
      argument filename<> -> String @ rbi/stdlib.rbi:__LINE__
    method autoload? (name) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument name<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method binding () -> Binding @ rbi/stdlib.rbi:__LINE__
    method clone () -> Kernel @ rbi/stdlib.rbi:__LINE__
    method configatron () @ ???
    method exit () -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument status<optional> @ rbi/stdlib.rbi:__LINE__
    method exit! (status) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument status<> -> Integer | TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method fail () -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method format (format, args) -> String @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument format<> -> String @ rbi/stdlib.rbi:__LINE__
    method gets (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method global_variables () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method hard_assert (predicate, msg, opts) -> NilClass @ rbi/assertions.rbi:8
      argument msg<optional> -> String | NilClass @ rbi/assertions.rbi:4
      argument opts<keyword, repeated> -> untyped @ rbi/assertions.rbi:5
      argument predicate<> -> TrueClass | FalseClass @ rbi/assertions.rbi:3
    method load (filename, arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument filename<> -> String @ rbi/stdlib.rbi:__LINE__
    method open (name, rest, block) -> AppliedType {
          klass = ::<constant:IO>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass @ rbi/stdlib.rbi:__LINE__
      argument block<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument name<> -> String @ rbi/stdlib.rbi:__LINE__
      argument rest<optional> -> String | Integer @ rbi/stdlib.rbi:__LINE__
    method printf (arg0, arg1, arg2) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> AppliedType {
        klass = ::<constant:IO>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg2<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method proc (blk) -> Proc @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method putc (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method puts (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method raise () -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method readline (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method readlines (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method require (path) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument path<> -> String @ rbi/stdlib.rbi:__LINE__
    method require_relative (feature) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument feature<> -> String @ rbi/stdlib.rbi:__LINE__
    method select (read, write, error, timeout) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument error<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument read<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument timeout<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument write<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method send (arg0, arg1) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String | Symbol @ rbi/stdlib.rbi:__LINE__
      argument arg1<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method sleep (duration) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument duration<> -> Numeric @ rbi/stdlib.rbi:__LINE__
    method sprintf (format, args) -> String @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument format<> -> String @ rbi/stdlib.rbi:__LINE__
    method syscall (num, args) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument num<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method test (cmd, file1, file2) -> TrueClass | FalseClass | Time @ rbi/stdlib.rbi:__LINE__
      argument cmd<> -> String @ rbi/stdlib.rbi:__LINE__
      argument file1<> -> String @ rbi/stdlib.rbi:__LINE__
      argument file2<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method warn (msg) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument msg<repeated> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBYGEMS_ACTIVATION_MONITOR> -> Monitor @ rbi/stdlib.rbi:__LINE__
  class <constant:KeyError> < ::<constant:IndexError> () -> <Class:KeyError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> KeyError @ rbi/stdlib.rbi:__LINE__
    method dup () -> KeyError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> KeyError @ rbi/stdlib.rbi:__LINE__
    method taint () -> KeyError @ rbi/stdlib.rbi:__LINE__
    method trust () -> KeyError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> KeyError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> KeyError @ rbi/stdlib.rbi:__LINE__
  class <constant:LoadError> < ::<constant:ScriptError> () -> <Class:LoadError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> LoadError @ rbi/stdlib.rbi:__LINE__
    method dup () -> LoadError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> LoadError @ rbi/stdlib.rbi:__LINE__
    method taint () -> LoadError @ rbi/stdlib.rbi:__LINE__
    method trust () -> LoadError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> LoadError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> LoadError @ rbi/stdlib.rbi:__LINE__
  class <constant:LocalJumpError> < ::<constant:StandardError> () -> <Class:LocalJumpError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> LocalJumpError @ rbi/stdlib.rbi:__LINE__
    method dup () -> LocalJumpError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> LocalJumpError @ rbi/stdlib.rbi:__LINE__
    method taint () -> LocalJumpError @ rbi/stdlib.rbi:__LINE__
    method trust () -> LocalJumpError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> LocalJumpError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> LocalJumpError @ rbi/stdlib.rbi:__LINE__
  class <constant:Marshal> (<constant:BasicObject>) -> <Class:Marshal> @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MAJOR_VERSION> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MINOR_VERSION> -> Integer @ rbi/stdlib.rbi:__LINE__
  class <constant:MatchData> < ::<constant:Object> () -> <Class:MatchData> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : []> (length) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument i<> @ rbi/stdlib.rbi:__LINE__
      argument length<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : []> () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument i<> @ rbi/stdlib.rbi:__LINE__
      argument length<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : []> () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument i<> @ rbi/stdlib.rbi:__LINE__
      argument length<optional> @ rbi/stdlib.rbi:__LINE__
    method == (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method [] (i) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument i<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument length<optional> @ rbi/stdlib.rbi:__LINE__
    method begin (n) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument n<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method captures () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method clone () -> MatchData @ rbi/stdlib.rbi:__LINE__
    method dup () -> MatchData @ rbi/stdlib.rbi:__LINE__
    method end (n) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument n<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method eql? (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method freeze () -> MatchData @ rbi/stdlib.rbi:__LINE__
    method hash () -> Integer @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method length () -> Integer @ rbi/stdlib.rbi:__LINE__
    method names () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method offset (n) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument n<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method post_match () -> String @ rbi/stdlib.rbi:__LINE__
    method pre_match () -> String @ rbi/stdlib.rbi:__LINE__
    method regexp () -> Regexp @ rbi/stdlib.rbi:__LINE__
    method size () -> Integer @ rbi/stdlib.rbi:__LINE__
    method string () -> String @ rbi/stdlib.rbi:__LINE__
    method taint () -> MatchData @ rbi/stdlib.rbi:__LINE__
    method to_a () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method trust () -> MatchData @ rbi/stdlib.rbi:__LINE__
    method untaint () -> MatchData @ rbi/stdlib.rbi:__LINE__
    method untrust () -> MatchData @ rbi/stdlib.rbi:__LINE__
    method values_at (indexes) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument indexes<repeated> -> Integer @ rbi/stdlib.rbi:__LINE__
  class <constant:Math> (<constant:BasicObject>) -> <Class:Math> @ rbi/stdlib.rbi:__LINE__
    class <constant:DomainError> < ::<constant:StandardError> () -> <Class:Math::DomainError> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:DomainError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
    static-field <constant:E> -> Float @ rbi/stdlib.rbi:__LINE__
    static-field <constant:PI> -> Float @ rbi/stdlib.rbi:__LINE__
  class <constant:Method> < ::<constant:Object> () -> <Class:Method> @ rbi/stdlib.rbi:__LINE__
    method clone () -> Method @ rbi/stdlib.rbi:__LINE__
    method dup () -> Method @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Method @ rbi/stdlib.rbi:__LINE__
    method taint () -> Method @ rbi/stdlib.rbi:__LINE__
    method trust () -> Method @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Method @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Method @ rbi/stdlib.rbi:__LINE__
  class <constant:Module> < ::<constant:Object> () -> <Class:Module> @ rbi/stdlib.rbi:__LINE__
    method < (other) -> TrueClass | FalseClass | NilClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> Module @ rbi/stdlib.rbi:__LINE__
    method <= (other) -> TrueClass | FalseClass | NilClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> Module @ rbi/stdlib.rbi:__LINE__
    method <=> (other) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> Module @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : define_method> (arg0, blk) -> Symbol @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : initialize> (blk) -> Object @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Module
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method == (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method === (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method > (other) -> TrueClass | FalseClass | NilClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> Module @ rbi/stdlib.rbi:__LINE__
    method >= (other) -> TrueClass | FalseClass | NilClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> Module @ rbi/stdlib.rbi:__LINE__
    method alias_method (new_name, old_name) -> Module @ rbi/stdlib.rbi:__LINE__
      argument new_name<> -> Symbol @ rbi/stdlib.rbi:__LINE__
      argument old_name<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method ancestors () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Module
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method append_features (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Module @ rbi/stdlib.rbi:__LINE__
    method attr (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method attr_accessor (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method attr_reader (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method attr_writer (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method autoload (_module, filename) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument _module<> -> Symbol @ rbi/stdlib.rbi:__LINE__
      argument filename<> -> String @ rbi/stdlib.rbi:__LINE__
    method autoload? (name) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument name<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method class_eval (arg0, filename, lineno) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument filename<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument lineno<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method class_exec (args, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method class_variable_defined? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method class_variable_get (arg0) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method class_variable_set (arg0, arg1) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method class_variables (inherit) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument inherit<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method clone () -> Module @ rbi/stdlib.rbi:__LINE__
    method const_defined? (arg0, inherit) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
      argument inherit<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method const_get (arg0, inherit) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
      argument inherit<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method const_missing (arg0) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method const_set (arg0, arg1) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method constants (inherit) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument inherit<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method define_method (arg0, arg1) -> Symbol @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Method @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method dup () -> Module @ rbi/stdlib.rbi:__LINE__
    method eql? (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method equal? (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method extend_object (arg0) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method extended (othermod) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument othermod<> -> Module @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Module @ rbi/stdlib.rbi:__LINE__
    method include (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Module @ rbi/stdlib.rbi:__LINE__
    method include? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Module @ rbi/stdlib.rbi:__LINE__
    method included (othermod) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument othermod<> -> Module @ rbi/stdlib.rbi:__LINE__
    method included_modules () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Module
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method initialize () -> Object @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method instance_method (arg0) -> UnboundMethod @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method instance_methods (include_super) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument include_super<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method method_added (meth) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument meth<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method method_defined? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method method_removed (method_name) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument method_name<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method module_eval (arg0, filename, lineno) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument filename<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument lineno<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method module_exec (args, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method module_function (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method name () -> String @ rbi/stdlib.rbi:__LINE__
    method prepend (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Module @ rbi/stdlib.rbi:__LINE__
    method prepend_features (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Module @ rbi/stdlib.rbi:__LINE__
    method prepended (othermod) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument othermod<> -> Module @ rbi/stdlib.rbi:__LINE__
    method private (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method private_class_method (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method private_constant (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method private_instance_methods (include_super) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument include_super<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method private_method_defined? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method protected (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method protected_instance_methods (include_super) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument include_super<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method protected_method_defined? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method public (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method public_class_method (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method public_constant (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method public_instance_method (arg0) -> UnboundMethod @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method public_instance_methods (include_super) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument include_super<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method public_method_defined? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method refine (arg0, blk) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Class @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method remove_class_variable (arg0) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method remove_const (arg0) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method remove_method (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method singleton_class? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method taint () -> Module @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method trust () -> Module @ rbi/stdlib.rbi:__LINE__
    method undef_method (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Module @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Module @ rbi/stdlib.rbi:__LINE__
    method using (arg0) -> Module @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Module @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ARGF> -> Object @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ARGV> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CROSS_COMPILING> -> NilClass @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ENV> -> Object @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FALSE> -> FalseClass @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NIL> -> NilClass @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_COPYRIGHT> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_DESCRIPTION> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_ENGINE> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_ENGINE_VERSION> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_PATCHLEVEL> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_PLATFORM> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_RELEASE_DATE> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_REVISION> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_VERSION> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:STDERR> -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:STDIN> -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:STDOUT> -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:TOPLEVEL_BINDING> -> Binding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:TRUE> -> TrueClass @ rbi/stdlib.rbi:__LINE__
  class <constant:Monitor> < ::<constant:Object> (<constant:MonitorMixin>) -> <Class:Monitor> @ rbi/stdlib.rbi:__LINE__
    method clone () -> Monitor @ rbi/stdlib.rbi:__LINE__
    method dup () -> Monitor @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Monitor @ rbi/stdlib.rbi:__LINE__
    method taint () -> Monitor @ rbi/stdlib.rbi:__LINE__
    method trust () -> Monitor @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Monitor @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Monitor @ rbi/stdlib.rbi:__LINE__
  class <constant:MonitorMixin> (<constant:BasicObject>) -> <Class:MonitorMixin> @ rbi/stdlib.rbi:__LINE__
    class <constant:ConditionVariable> < ::<constant:Object> () -> <Class:MonitorMixin::ConditionVariable> @ rbi/stdlib.rbi:__LINE__
      class <constant:Timeout> < ::<constant:Exception> () -> <Class:MonitorMixin::ConditionVariable::Timeout> @ rbi/stdlib.rbi:__LINE__
      class <singleton class:<constant:Timeout>> < ::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ConditionVariable>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <constant:NameError> < ::<constant:StandardError> () -> <Class:NameError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> NameError @ rbi/stdlib.rbi:__LINE__
    method dup () -> NameError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> NameError @ rbi/stdlib.rbi:__LINE__
    method taint () -> NameError @ rbi/stdlib.rbi:__LINE__
    method trust () -> NameError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> NameError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> NameError @ rbi/stdlib.rbi:__LINE__
  class <constant:NilClass> < ::<constant:Object> () -> <Class:NilClass> @ rbi/stdlib.rbi:__LINE__
    method & (obj) -> FalseClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method ^ (obj) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method clone () -> NilClass @ rbi/stdlib.rbi:__LINE__
    method dup () -> NilClass @ rbi/stdlib.rbi:__LINE__
    method freeze () -> NilClass @ rbi/stdlib.rbi:__LINE__
    method rationalize () -> Rational @ rbi/stdlib.rbi:__LINE__
    method taint () -> NilClass @ rbi/stdlib.rbi:__LINE__
    method to_a () -> TupleType {
    } @ rbi/stdlib.rbi:__LINE__
    method to_c () -> Complex @ rbi/stdlib.rbi:__LINE__
    method to_f () -> Float @ rbi/stdlib.rbi:__LINE__
    method to_h () -> untyped @ rbi/stdlib.rbi:__LINE__
    method to_r () -> Rational @ rbi/stdlib.rbi:__LINE__
    method trust () -> NilClass @ rbi/stdlib.rbi:__LINE__
    method untaint () -> NilClass @ rbi/stdlib.rbi:__LINE__
    method untrust () -> NilClass @ rbi/stdlib.rbi:__LINE__
    method | (obj) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
  class <constant:NoMemoryError> < ::<constant:Exception> () -> <Class:NoMemoryError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> NoMemoryError @ rbi/stdlib.rbi:__LINE__
    method dup () -> NoMemoryError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> NoMemoryError @ rbi/stdlib.rbi:__LINE__
    method taint () -> NoMemoryError @ rbi/stdlib.rbi:__LINE__
    method trust () -> NoMemoryError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> NoMemoryError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> NoMemoryError @ rbi/stdlib.rbi:__LINE__
  class <constant:NoMethodError> < ::<constant:NameError> () -> <Class:NoMethodError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> NoMethodError @ rbi/stdlib.rbi:__LINE__
    method dup () -> NoMethodError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> NoMethodError @ rbi/stdlib.rbi:__LINE__
    method taint () -> NoMethodError @ rbi/stdlib.rbi:__LINE__
    method trust () -> NoMethodError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> NoMethodError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> NoMethodError @ rbi/stdlib.rbi:__LINE__
  class <constant:NotImplementedError> < ::<constant:ScriptError> () -> <Class:NotImplementedError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> NotImplementedError @ rbi/stdlib.rbi:__LINE__
    method dup () -> NotImplementedError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> NotImplementedError @ rbi/stdlib.rbi:__LINE__
    method taint () -> NotImplementedError @ rbi/stdlib.rbi:__LINE__
    method trust () -> NotImplementedError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> NotImplementedError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> NotImplementedError @ rbi/stdlib.rbi:__LINE__
  class <constant:Numeric> < ::<constant:Object> (<constant:Comparable>) -> <Class:Numeric> @ rbi/stdlib.rbi:__LINE__
    method % (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method +@ () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method -@ () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method <=> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : step> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer | Float | Rational | BigDecimal | Complex
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : step> (arg0, arg1, blk) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer | Float | Rational | BigDecimal | Complex
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : step> (arg0, arg1) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer | Float | Rational | BigDecimal | Complex
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method abs () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method abs2 () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method angle () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method arg () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method ceil () -> Integer @ rbi/stdlib.rbi:__LINE__
    method clone () -> Numeric @ rbi/stdlib.rbi:__LINE__
    method coerce (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal | Complex
      1 = Integer | Float | Rational | BigDecimal | Complex
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method conj () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method conjugate () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method denominator () -> Integer @ rbi/stdlib.rbi:__LINE__
    method div (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method divmod (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal | Complex
      1 = Integer | Float | Rational | BigDecimal | Complex
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method dup () -> Numeric @ rbi/stdlib.rbi:__LINE__
    method eql? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method fdiv (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method floor () -> Integer @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Numeric @ rbi/stdlib.rbi:__LINE__
    method i () -> Complex @ rbi/stdlib.rbi:__LINE__
    method imag () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method imaginary () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method integer? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method magnitude () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method modulo (arg0) -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method nonzero? () -> untyped @ rbi/stdlib.rbi:__LINE__
    method numerator () -> Integer @ rbi/stdlib.rbi:__LINE__
    method phase () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method polar () -> TupleType {
      0 = Integer | Float | Rational | BigDecimal | Complex
      1 = Integer | Float | Rational | BigDecimal | Complex
    } @ rbi/stdlib.rbi:__LINE__
    method quo (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method real () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method real? () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method rect () -> TupleType {
      0 = Integer | Float | Rational | BigDecimal | Complex
      1 = Integer | Float | Rational | BigDecimal | Complex
    } @ rbi/stdlib.rbi:__LINE__
    method rectangular () -> TupleType {
      0 = Integer | Float | Rational | BigDecimal | Complex
      1 = Integer | Float | Rational | BigDecimal | Complex
    } @ rbi/stdlib.rbi:__LINE__
    method remainder (arg0) -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method round (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method singleton_method_added (arg0) -> TypeError @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method step (arg0, blk) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer | Float | Rational | BigDecimal | Complex
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method taint () -> Numeric @ rbi/stdlib.rbi:__LINE__
    method to_c () -> Complex @ rbi/stdlib.rbi:__LINE__
    method to_int () -> Integer @ rbi/stdlib.rbi:__LINE__
    method truncate () -> Integer @ rbi/stdlib.rbi:__LINE__
    method trust () -> Numeric @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Numeric @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Numeric @ rbi/stdlib.rbi:__LINE__
    method zero? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
  class <constant:Object> < ::<constant:BasicObject> (<constant:Kernel>) -> <Class:Object> @ rbi/stdlib.rbi:__LINE__
    method !~ (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <=> (other) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : enum_for> (method, args, blk) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument method<optional> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : to_enum> (method, args, blk) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument method<optional> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method === (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method =~ (other) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method clone () -> Object @ rbi/stdlib.rbi:__LINE__
    method display (port) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument port<> -> AppliedType {
        klass = ::<constant:IO>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method dup () -> Object @ rbi/stdlib.rbi:__LINE__
    method enum_for (method, args) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument method<optional> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method eql? (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method extend (mod) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument mod<> -> Module @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Object @ rbi/stdlib.rbi:__LINE__
    method frozen? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method hash () -> Integer @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method instance_of? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Class @ rbi/stdlib.rbi:__LINE__
    method instance_variable_defined? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method instance_variable_get (arg0) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method instance_variable_set (arg0, arg1) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method instance_variables () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method is_a? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Module @ rbi/stdlib.rbi:__LINE__
    method kind_of? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Class @ rbi/stdlib.rbi:__LINE__
    method method (arg0) -> Method @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method methods (regular) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument regular<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method nil? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method private_methods (all) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument all<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method protected_methods (all) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument all<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method public_method (arg0) -> Method @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method public_methods (all) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument all<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method public_send (arg0, args) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method remove_instance_variable (arg0) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method send (arg0, args) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method singleton_class () -> Class @ rbi/stdlib.rbi:__LINE__
    method singleton_method (arg0) -> Method @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method singleton_methods (all) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument all<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method taint () -> Object @ rbi/stdlib.rbi:__LINE__
    method tainted? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method to_enum (method, args) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument method<optional> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method trust () -> Object @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Object @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Object @ rbi/stdlib.rbi:__LINE__
    method untrusted? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ARGF> -> Object @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ARGV> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CROSS_COMPILING> -> NilClass @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ENV> -> Object @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FALSE> -> FalseClass @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NIL> -> NilClass @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBYGEMS_ACTIVATION_MONITOR> -> Monitor @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_COPYRIGHT> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_DESCRIPTION> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_ENGINE> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_ENGINE_VERSION> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_PATCHLEVEL> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_PLATFORM> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_RELEASE_DATE> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_REVISION> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RUBY_VERSION> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:STDERR> -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:STDIN> -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:STDOUT> -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:TOPLEVEL_BINDING> -> Binding @ rbi/stdlib.rbi:__LINE__
    static-field <constant:TRUE> -> TrueClass @ rbi/stdlib.rbi:__LINE__
  class <constant:ObjectSpace> (<constant:BasicObject>) -> <Class:ObjectSpace> @ rbi/stdlib.rbi:__LINE__
    class <constant:WeakMap>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:ObjectSpace::WeakMap> @ rbi/stdlib.rbi:__LINE__
      typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:WeakMap>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <constant:Opus> () -> <Class:Opus> @ ???
    class <constant:DB> () -> <Class:Opus::DB> @ ???
      class <constant:Model> () -> <Class:Opus::DB::Model> @ ???
      class <singleton class:<constant:Model>> < ::<constant:Module> () @ ???
    class <singleton class:<constant:DB>> < ::<constant:Module> () @ ???
  class <constant:Pathname> < ::<constant:Object> () -> <Class:Pathname> @ rbi/stdlib.rbi:__LINE__
    method + (other) -> Pathname @ rbi/stdlib.rbi:__LINE__
      argument other<> -> String | Pathname @ rbi/stdlib.rbi:__LINE__
    method / (other) -> Pathname @ rbi/stdlib.rbi:__LINE__
      argument other<> -> String | Pathname @ rbi/stdlib.rbi:__LINE__
    method <=> (p1) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument p1<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_filename> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_line> (sep, limit) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : find> (ignore_error) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Pathname
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument ignore_error<> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : open> (mode, perm, opt, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:File>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument mode<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument opt<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument perm<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : opendir> (arg0, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Encoding @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Dir>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : symlink?> () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument old<optional> @ rbi/stdlib.rbi:__LINE__
    method == (p1) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument p1<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method === (p1) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument p1<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method absolute? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method ascend (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Pathname
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method atime () -> Time @ rbi/stdlib.rbi:__LINE__
    method basename (p1) -> Pathname @ rbi/stdlib.rbi:__LINE__
      argument p1<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method binread (length, offset) -> String @ rbi/stdlib.rbi:__LINE__
      argument length<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument offset<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method binwrite (arg0, offset) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument offset<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method birthtime () -> Time @ rbi/stdlib.rbi:__LINE__
    method blockdev? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method chardev? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method children (with_directory) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Pathname
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument with_directory<> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method chmod (mode) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument mode<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method chown (owner, group) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument group<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument owner<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method cleanpath (consider_symlink) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument consider_symlink<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method ctime () -> Time @ rbi/stdlib.rbi:__LINE__
    method delete () -> untyped @ rbi/stdlib.rbi:__LINE__
    method descend (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Pathname
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method directory? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method dirname () -> Pathname @ rbi/stdlib.rbi:__LINE__
    method each_child (with_directory, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Pathname
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument with_directory<> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method each_entry (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Pathname
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_filename (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_line (sep, limit, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method entries () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Pathname
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method eql? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method executable? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method executable_real? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method exist? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method expand_path (p1) -> Pathname @ rbi/stdlib.rbi:__LINE__
      argument p1<optional> -> String | Pathname @ rbi/stdlib.rbi:__LINE__
    method extname () -> String @ rbi/stdlib.rbi:__LINE__
    method file? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method find (ignore_error, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Pathname
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument ignore_error<> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method fnmatch (pattern, flags) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument flags<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument pattern<> -> String @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Pathname @ rbi/stdlib.rbi:__LINE__
    method ftype () -> String @ rbi/stdlib.rbi:__LINE__
    method grpowned? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method join (args) -> Pathname @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> String | Pathname @ rbi/stdlib.rbi:__LINE__
    method lchmod (mode) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument mode<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method lchown (owner, group) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument group<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument owner<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method lstat () -> File::Stat @ rbi/stdlib.rbi:__LINE__
    method make_link (old) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument old<> -> String @ rbi/stdlib.rbi:__LINE__
    method mkdir (p1) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument p1<> -> String @ rbi/stdlib.rbi:__LINE__
    method mkpath () -> untyped @ rbi/stdlib.rbi:__LINE__
    method mountpoint? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method mtime () -> Time @ rbi/stdlib.rbi:__LINE__
    method open (mode, perm, opt) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument mode<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument opt<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument perm<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method opendir (arg0) -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Encoding @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method owned? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method parent () -> Pathname @ rbi/stdlib.rbi:__LINE__
    method pipe? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method read (length, offset, open_args) -> String @ rbi/stdlib.rbi:__LINE__
      argument length<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument offset<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument open_args<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method readable? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method readable_real? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method readlines (sep, limit, open_args) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument open_args<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method readlink () -> String @ rbi/stdlib.rbi:__LINE__
    method realdirpath (p1) -> String @ rbi/stdlib.rbi:__LINE__
      argument p1<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method realpath (p1) -> String @ rbi/stdlib.rbi:__LINE__
      argument p1<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method relative? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method relative_path_from (base_directory) -> Pathname @ rbi/stdlib.rbi:__LINE__
      argument base_directory<> -> String | Pathname @ rbi/stdlib.rbi:__LINE__
    method rename (p1) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument p1<> -> String @ rbi/stdlib.rbi:__LINE__
    method rmdir () -> Integer @ rbi/stdlib.rbi:__LINE__
    method rmtree () -> Integer @ rbi/stdlib.rbi:__LINE__
    method root? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method setgid? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method setuid? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method size () -> Integer @ rbi/stdlib.rbi:__LINE__
    method size? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method socket? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method split () -> TupleType {
      0 = Pathname
      1 = Pathname
    } @ rbi/stdlib.rbi:__LINE__
    method stat () -> File::Stat @ rbi/stdlib.rbi:__LINE__
    method sticky? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method sub (args) -> Pathname @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> String @ rbi/stdlib.rbi:__LINE__
    method sub_ext (p1) -> Pathname @ rbi/stdlib.rbi:__LINE__
      argument p1<> -> String @ rbi/stdlib.rbi:__LINE__
    method symlink? (old) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument old<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method sysopen (mode, perm) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument mode<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument perm<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method taint () -> Pathname @ rbi/stdlib.rbi:__LINE__
    method to_path () -> String @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method truncate (length) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument length<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method unlink () -> Integer @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Pathname @ rbi/stdlib.rbi:__LINE__
    method utime (atime, mtime) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument atime<> -> Time @ rbi/stdlib.rbi:__LINE__
      argument mtime<> -> Time @ rbi/stdlib.rbi:__LINE__
    method world_readable? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method world_writable? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method writable? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method writable_real? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method write (arg0, offset, open_args) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument offset<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument open_args<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method zero? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
  class <constant:Proc0>[<constant:Return>] < ::<constant:Proc> () -> <Class:Proc0> @ bazel-out/host/genfiles/rbi/procs.rbi:1
    method <static-init> () @ bazel-out/host/genfiles/rbi/procs.rbi:10
    method [] () -> AliasType { symbol = ::<constant:Proc0>#call } @ bazel-out/host/genfiles/rbi/procs.rbi:7
    method call () -> LambdaParam(::<constant:Proc0>#<constant:Return>) @ bazel-out/host/genfiles/rbi/procs.rbi:7
    typeMember(=) <constant:Return> @ bazel-out/host/genfiles/rbi/procs.rbi:2
  class <constant:Proc10>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>, <constant:Arg4>, <constant:Arg5>, <constant:Arg6>, <constant:Arg7>, <constant:Arg8>, <constant:Arg9>] < ::<constant:Proc> () -> <Class:Proc10> @ bazel-out/host/genfiles/rbi/procs.rbi:221
    method <static-init> () @ bazel-out/host/genfiles/rbi/procs.rbi:250
    method [] () -> AliasType { symbol = ::<constant:Proc10>#call } @ bazel-out/host/genfiles/rbi/procs.rbi:247
    method call (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) -> LambdaParam(::<constant:Proc10>#<constant:Return>) @ bazel-out/host/genfiles/rbi/procs.rbi:247
      argument arg0<> -> LambdaParam(::<constant:Proc10>#<constant:Arg0>) @ bazel-out/host/genfiles/rbi/procs.rbi:235
      argument arg1<> -> LambdaParam(::<constant:Proc10>#<constant:Arg1>) @ bazel-out/host/genfiles/rbi/procs.rbi:236
      argument arg2<> -> LambdaParam(::<constant:Proc10>#<constant:Arg2>) @ bazel-out/host/genfiles/rbi/procs.rbi:237
      argument arg3<> -> LambdaParam(::<constant:Proc10>#<constant:Arg3>) @ bazel-out/host/genfiles/rbi/procs.rbi:238
      argument arg4<> -> LambdaParam(::<constant:Proc10>#<constant:Arg4>) @ bazel-out/host/genfiles/rbi/procs.rbi:239
      argument arg5<> -> LambdaParam(::<constant:Proc10>#<constant:Arg5>) @ bazel-out/host/genfiles/rbi/procs.rbi:240
      argument arg6<> -> LambdaParam(::<constant:Proc10>#<constant:Arg6>) @ bazel-out/host/genfiles/rbi/procs.rbi:241
      argument arg7<> -> LambdaParam(::<constant:Proc10>#<constant:Arg7>) @ bazel-out/host/genfiles/rbi/procs.rbi:242
      argument arg8<> -> LambdaParam(::<constant:Proc10>#<constant:Arg8>) @ bazel-out/host/genfiles/rbi/procs.rbi:243
      argument arg9<> -> LambdaParam(::<constant:Proc10>#<constant:Arg9>) @ bazel-out/host/genfiles/rbi/procs.rbi:244
    typeMember(=) <constant:Arg0> @ bazel-out/host/genfiles/rbi/procs.rbi:223
    typeMember(=) <constant:Arg1> @ bazel-out/host/genfiles/rbi/procs.rbi:224
    typeMember(=) <constant:Arg2> @ bazel-out/host/genfiles/rbi/procs.rbi:225
    typeMember(=) <constant:Arg3> @ bazel-out/host/genfiles/rbi/procs.rbi:226
    typeMember(=) <constant:Arg4> @ bazel-out/host/genfiles/rbi/procs.rbi:227
    typeMember(=) <constant:Arg5> @ bazel-out/host/genfiles/rbi/procs.rbi:228
    typeMember(=) <constant:Arg6> @ bazel-out/host/genfiles/rbi/procs.rbi:229
    typeMember(=) <constant:Arg7> @ bazel-out/host/genfiles/rbi/procs.rbi:230
    typeMember(=) <constant:Arg8> @ bazel-out/host/genfiles/rbi/procs.rbi:231
    typeMember(=) <constant:Arg9> @ bazel-out/host/genfiles/rbi/procs.rbi:232
    typeMember(=) <constant:Return> @ bazel-out/host/genfiles/rbi/procs.rbi:222
  class <constant:Proc1>[<constant:Return>, <constant:Arg0>] < ::<constant:Proc> () -> <Class:Proc1> @ bazel-out/host/genfiles/rbi/procs.rbi:14
    method <static-init> () @ bazel-out/host/genfiles/rbi/procs.rbi:25
    method [] () -> AliasType { symbol = ::<constant:Proc1>#call } @ bazel-out/host/genfiles/rbi/procs.rbi:22
    method call (arg0) -> LambdaParam(::<constant:Proc1>#<constant:Return>) @ bazel-out/host/genfiles/rbi/procs.rbi:22
      argument arg0<> -> LambdaParam(::<constant:Proc1>#<constant:Arg0>) @ bazel-out/host/genfiles/rbi/procs.rbi:19
    typeMember(=) <constant:Arg0> @ bazel-out/host/genfiles/rbi/procs.rbi:16
    typeMember(=) <constant:Return> @ bazel-out/host/genfiles/rbi/procs.rbi:15
  class <constant:Proc2>[<constant:Return>, <constant:Arg0>, <constant:Arg1>] < ::<constant:Proc> () -> <Class:Proc2> @ bazel-out/host/genfiles/rbi/procs.rbi:29
    method <static-init> () @ bazel-out/host/genfiles/rbi/procs.rbi:42
    method [] () -> AliasType { symbol = ::<constant:Proc2>#call } @ bazel-out/host/genfiles/rbi/procs.rbi:39
    method call (arg0, arg1) -> LambdaParam(::<constant:Proc2>#<constant:Return>) @ bazel-out/host/genfiles/rbi/procs.rbi:39
      argument arg0<> -> LambdaParam(::<constant:Proc2>#<constant:Arg0>) @ bazel-out/host/genfiles/rbi/procs.rbi:35
      argument arg1<> -> LambdaParam(::<constant:Proc2>#<constant:Arg1>) @ bazel-out/host/genfiles/rbi/procs.rbi:36
    typeMember(=) <constant:Arg0> @ bazel-out/host/genfiles/rbi/procs.rbi:31
    typeMember(=) <constant:Arg1> @ bazel-out/host/genfiles/rbi/procs.rbi:32
    typeMember(=) <constant:Return> @ bazel-out/host/genfiles/rbi/procs.rbi:30
  class <constant:Proc3>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>] < ::<constant:Proc> () -> <Class:Proc3> @ bazel-out/host/genfiles/rbi/procs.rbi:46
    method <static-init> () @ bazel-out/host/genfiles/rbi/procs.rbi:61
    method [] () -> AliasType { symbol = ::<constant:Proc3>#call } @ bazel-out/host/genfiles/rbi/procs.rbi:58
    method call (arg0, arg1, arg2) -> LambdaParam(::<constant:Proc3>#<constant:Return>) @ bazel-out/host/genfiles/rbi/procs.rbi:58
      argument arg0<> -> LambdaParam(::<constant:Proc3>#<constant:Arg0>) @ bazel-out/host/genfiles/rbi/procs.rbi:53
      argument arg1<> -> LambdaParam(::<constant:Proc3>#<constant:Arg1>) @ bazel-out/host/genfiles/rbi/procs.rbi:54
      argument arg2<> -> LambdaParam(::<constant:Proc3>#<constant:Arg2>) @ bazel-out/host/genfiles/rbi/procs.rbi:55
    typeMember(=) <constant:Arg0> @ bazel-out/host/genfiles/rbi/procs.rbi:48
    typeMember(=) <constant:Arg1> @ bazel-out/host/genfiles/rbi/procs.rbi:49
    typeMember(=) <constant:Arg2> @ bazel-out/host/genfiles/rbi/procs.rbi:50
    typeMember(=) <constant:Return> @ bazel-out/host/genfiles/rbi/procs.rbi:47
  class <constant:Proc4>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>] < ::<constant:Proc> () -> <Class:Proc4> @ bazel-out/host/genfiles/rbi/procs.rbi:65
    method <static-init> () @ bazel-out/host/genfiles/rbi/procs.rbi:82
    method [] () -> AliasType { symbol = ::<constant:Proc4>#call } @ bazel-out/host/genfiles/rbi/procs.rbi:79
    method call (arg0, arg1, arg2, arg3) -> LambdaParam(::<constant:Proc4>#<constant:Return>) @ bazel-out/host/genfiles/rbi/procs.rbi:79
      argument arg0<> -> LambdaParam(::<constant:Proc4>#<constant:Arg0>) @ bazel-out/host/genfiles/rbi/procs.rbi:73
      argument arg1<> -> LambdaParam(::<constant:Proc4>#<constant:Arg1>) @ bazel-out/host/genfiles/rbi/procs.rbi:74
      argument arg2<> -> LambdaParam(::<constant:Proc4>#<constant:Arg2>) @ bazel-out/host/genfiles/rbi/procs.rbi:75
      argument arg3<> -> LambdaParam(::<constant:Proc4>#<constant:Arg3>) @ bazel-out/host/genfiles/rbi/procs.rbi:76
    typeMember(=) <constant:Arg0> @ bazel-out/host/genfiles/rbi/procs.rbi:67
    typeMember(=) <constant:Arg1> @ bazel-out/host/genfiles/rbi/procs.rbi:68
    typeMember(=) <constant:Arg2> @ bazel-out/host/genfiles/rbi/procs.rbi:69
    typeMember(=) <constant:Arg3> @ bazel-out/host/genfiles/rbi/procs.rbi:70
    typeMember(=) <constant:Return> @ bazel-out/host/genfiles/rbi/procs.rbi:66
  class <constant:Proc5>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>, <constant:Arg4>] < ::<constant:Proc> () -> <Class:Proc5> @ bazel-out/host/genfiles/rbi/procs.rbi:86
    method <static-init> () @ bazel-out/host/genfiles/rbi/procs.rbi:105
    method [] () -> AliasType { symbol = ::<constant:Proc5>#call } @ bazel-out/host/genfiles/rbi/procs.rbi:102
    method call (arg0, arg1, arg2, arg3, arg4) -> LambdaParam(::<constant:Proc5>#<constant:Return>) @ bazel-out/host/genfiles/rbi/procs.rbi:102
      argument arg0<> -> LambdaParam(::<constant:Proc5>#<constant:Arg0>) @ bazel-out/host/genfiles/rbi/procs.rbi:95
      argument arg1<> -> LambdaParam(::<constant:Proc5>#<constant:Arg1>) @ bazel-out/host/genfiles/rbi/procs.rbi:96
      argument arg2<> -> LambdaParam(::<constant:Proc5>#<constant:Arg2>) @ bazel-out/host/genfiles/rbi/procs.rbi:97
      argument arg3<> -> LambdaParam(::<constant:Proc5>#<constant:Arg3>) @ bazel-out/host/genfiles/rbi/procs.rbi:98
      argument arg4<> -> LambdaParam(::<constant:Proc5>#<constant:Arg4>) @ bazel-out/host/genfiles/rbi/procs.rbi:99
    typeMember(=) <constant:Arg0> @ bazel-out/host/genfiles/rbi/procs.rbi:88
    typeMember(=) <constant:Arg1> @ bazel-out/host/genfiles/rbi/procs.rbi:89
    typeMember(=) <constant:Arg2> @ bazel-out/host/genfiles/rbi/procs.rbi:90
    typeMember(=) <constant:Arg3> @ bazel-out/host/genfiles/rbi/procs.rbi:91
    typeMember(=) <constant:Arg4> @ bazel-out/host/genfiles/rbi/procs.rbi:92
    typeMember(=) <constant:Return> @ bazel-out/host/genfiles/rbi/procs.rbi:87
  class <constant:Proc6>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>, <constant:Arg4>, <constant:Arg5>] < ::<constant:Proc> () -> <Class:Proc6> @ bazel-out/host/genfiles/rbi/procs.rbi:109
    method <static-init> () @ bazel-out/host/genfiles/rbi/procs.rbi:130
    method [] () -> AliasType { symbol = ::<constant:Proc6>#call } @ bazel-out/host/genfiles/rbi/procs.rbi:127
    method call (arg0, arg1, arg2, arg3, arg4, arg5) -> LambdaParam(::<constant:Proc6>#<constant:Return>) @ bazel-out/host/genfiles/rbi/procs.rbi:127
      argument arg0<> -> LambdaParam(::<constant:Proc6>#<constant:Arg0>) @ bazel-out/host/genfiles/rbi/procs.rbi:119
      argument arg1<> -> LambdaParam(::<constant:Proc6>#<constant:Arg1>) @ bazel-out/host/genfiles/rbi/procs.rbi:120
      argument arg2<> -> LambdaParam(::<constant:Proc6>#<constant:Arg2>) @ bazel-out/host/genfiles/rbi/procs.rbi:121
      argument arg3<> -> LambdaParam(::<constant:Proc6>#<constant:Arg3>) @ bazel-out/host/genfiles/rbi/procs.rbi:122
      argument arg4<> -> LambdaParam(::<constant:Proc6>#<constant:Arg4>) @ bazel-out/host/genfiles/rbi/procs.rbi:123
      argument arg5<> -> LambdaParam(::<constant:Proc6>#<constant:Arg5>) @ bazel-out/host/genfiles/rbi/procs.rbi:124
    typeMember(=) <constant:Arg0> @ bazel-out/host/genfiles/rbi/procs.rbi:111
    typeMember(=) <constant:Arg1> @ bazel-out/host/genfiles/rbi/procs.rbi:112
    typeMember(=) <constant:Arg2> @ bazel-out/host/genfiles/rbi/procs.rbi:113
    typeMember(=) <constant:Arg3> @ bazel-out/host/genfiles/rbi/procs.rbi:114
    typeMember(=) <constant:Arg4> @ bazel-out/host/genfiles/rbi/procs.rbi:115
    typeMember(=) <constant:Arg5> @ bazel-out/host/genfiles/rbi/procs.rbi:116
    typeMember(=) <constant:Return> @ bazel-out/host/genfiles/rbi/procs.rbi:110
  class <constant:Proc7>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>, <constant:Arg4>, <constant:Arg5>, <constant:Arg6>] < ::<constant:Proc> () -> <Class:Proc7> @ bazel-out/host/genfiles/rbi/procs.rbi:134
    method <static-init> () @ bazel-out/host/genfiles/rbi/procs.rbi:157
    method [] () -> AliasType { symbol = ::<constant:Proc7>#call } @ bazel-out/host/genfiles/rbi/procs.rbi:154
    method call (arg0, arg1, arg2, arg3, arg4, arg5, arg6) -> LambdaParam(::<constant:Proc7>#<constant:Return>) @ bazel-out/host/genfiles/rbi/procs.rbi:154
      argument arg0<> -> LambdaParam(::<constant:Proc7>#<constant:Arg0>) @ bazel-out/host/genfiles/rbi/procs.rbi:145
      argument arg1<> -> LambdaParam(::<constant:Proc7>#<constant:Arg1>) @ bazel-out/host/genfiles/rbi/procs.rbi:146
      argument arg2<> -> LambdaParam(::<constant:Proc7>#<constant:Arg2>) @ bazel-out/host/genfiles/rbi/procs.rbi:147
      argument arg3<> -> LambdaParam(::<constant:Proc7>#<constant:Arg3>) @ bazel-out/host/genfiles/rbi/procs.rbi:148
      argument arg4<> -> LambdaParam(::<constant:Proc7>#<constant:Arg4>) @ bazel-out/host/genfiles/rbi/procs.rbi:149
      argument arg5<> -> LambdaParam(::<constant:Proc7>#<constant:Arg5>) @ bazel-out/host/genfiles/rbi/procs.rbi:150
      argument arg6<> -> LambdaParam(::<constant:Proc7>#<constant:Arg6>) @ bazel-out/host/genfiles/rbi/procs.rbi:151
    typeMember(=) <constant:Arg0> @ bazel-out/host/genfiles/rbi/procs.rbi:136
    typeMember(=) <constant:Arg1> @ bazel-out/host/genfiles/rbi/procs.rbi:137
    typeMember(=) <constant:Arg2> @ bazel-out/host/genfiles/rbi/procs.rbi:138
    typeMember(=) <constant:Arg3> @ bazel-out/host/genfiles/rbi/procs.rbi:139
    typeMember(=) <constant:Arg4> @ bazel-out/host/genfiles/rbi/procs.rbi:140
    typeMember(=) <constant:Arg5> @ bazel-out/host/genfiles/rbi/procs.rbi:141
    typeMember(=) <constant:Arg6> @ bazel-out/host/genfiles/rbi/procs.rbi:142
    typeMember(=) <constant:Return> @ bazel-out/host/genfiles/rbi/procs.rbi:135
  class <constant:Proc8>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>, <constant:Arg4>, <constant:Arg5>, <constant:Arg6>, <constant:Arg7>] < ::<constant:Proc> () -> <Class:Proc8> @ bazel-out/host/genfiles/rbi/procs.rbi:161
    method <static-init> () @ bazel-out/host/genfiles/rbi/procs.rbi:186
    method [] () -> AliasType { symbol = ::<constant:Proc8>#call } @ bazel-out/host/genfiles/rbi/procs.rbi:183
    method call (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) -> LambdaParam(::<constant:Proc8>#<constant:Return>) @ bazel-out/host/genfiles/rbi/procs.rbi:183
      argument arg0<> -> LambdaParam(::<constant:Proc8>#<constant:Arg0>) @ bazel-out/host/genfiles/rbi/procs.rbi:173
      argument arg1<> -> LambdaParam(::<constant:Proc8>#<constant:Arg1>) @ bazel-out/host/genfiles/rbi/procs.rbi:174
      argument arg2<> -> LambdaParam(::<constant:Proc8>#<constant:Arg2>) @ bazel-out/host/genfiles/rbi/procs.rbi:175
      argument arg3<> -> LambdaParam(::<constant:Proc8>#<constant:Arg3>) @ bazel-out/host/genfiles/rbi/procs.rbi:176
      argument arg4<> -> LambdaParam(::<constant:Proc8>#<constant:Arg4>) @ bazel-out/host/genfiles/rbi/procs.rbi:177
      argument arg5<> -> LambdaParam(::<constant:Proc8>#<constant:Arg5>) @ bazel-out/host/genfiles/rbi/procs.rbi:178
      argument arg6<> -> LambdaParam(::<constant:Proc8>#<constant:Arg6>) @ bazel-out/host/genfiles/rbi/procs.rbi:179
      argument arg7<> -> LambdaParam(::<constant:Proc8>#<constant:Arg7>) @ bazel-out/host/genfiles/rbi/procs.rbi:180
    typeMember(=) <constant:Arg0> @ bazel-out/host/genfiles/rbi/procs.rbi:163
    typeMember(=) <constant:Arg1> @ bazel-out/host/genfiles/rbi/procs.rbi:164
    typeMember(=) <constant:Arg2> @ bazel-out/host/genfiles/rbi/procs.rbi:165
    typeMember(=) <constant:Arg3> @ bazel-out/host/genfiles/rbi/procs.rbi:166
    typeMember(=) <constant:Arg4> @ bazel-out/host/genfiles/rbi/procs.rbi:167
    typeMember(=) <constant:Arg5> @ bazel-out/host/genfiles/rbi/procs.rbi:168
    typeMember(=) <constant:Arg6> @ bazel-out/host/genfiles/rbi/procs.rbi:169
    typeMember(=) <constant:Arg7> @ bazel-out/host/genfiles/rbi/procs.rbi:170
    typeMember(=) <constant:Return> @ bazel-out/host/genfiles/rbi/procs.rbi:162
  class <constant:Proc9>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>, <constant:Arg4>, <constant:Arg5>, <constant:Arg6>, <constant:Arg7>, <constant:Arg8>] < ::<constant:Proc> () -> <Class:Proc9> @ bazel-out/host/genfiles/rbi/procs.rbi:190
    method <static-init> () @ bazel-out/host/genfiles/rbi/procs.rbi:217
    method [] () -> AliasType { symbol = ::<constant:Proc9>#call } @ bazel-out/host/genfiles/rbi/procs.rbi:214
    method call (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) -> LambdaParam(::<constant:Proc9>#<constant:Return>) @ bazel-out/host/genfiles/rbi/procs.rbi:214
      argument arg0<> -> LambdaParam(::<constant:Proc9>#<constant:Arg0>) @ bazel-out/host/genfiles/rbi/procs.rbi:203
      argument arg1<> -> LambdaParam(::<constant:Proc9>#<constant:Arg1>) @ bazel-out/host/genfiles/rbi/procs.rbi:204
      argument arg2<> -> LambdaParam(::<constant:Proc9>#<constant:Arg2>) @ bazel-out/host/genfiles/rbi/procs.rbi:205
      argument arg3<> -> LambdaParam(::<constant:Proc9>#<constant:Arg3>) @ bazel-out/host/genfiles/rbi/procs.rbi:206
      argument arg4<> -> LambdaParam(::<constant:Proc9>#<constant:Arg4>) @ bazel-out/host/genfiles/rbi/procs.rbi:207
      argument arg5<> -> LambdaParam(::<constant:Proc9>#<constant:Arg5>) @ bazel-out/host/genfiles/rbi/procs.rbi:208
      argument arg6<> -> LambdaParam(::<constant:Proc9>#<constant:Arg6>) @ bazel-out/host/genfiles/rbi/procs.rbi:209
      argument arg7<> -> LambdaParam(::<constant:Proc9>#<constant:Arg7>) @ bazel-out/host/genfiles/rbi/procs.rbi:210
      argument arg8<> -> LambdaParam(::<constant:Proc9>#<constant:Arg8>) @ bazel-out/host/genfiles/rbi/procs.rbi:211
    typeMember(=) <constant:Arg0> @ bazel-out/host/genfiles/rbi/procs.rbi:192
    typeMember(=) <constant:Arg1> @ bazel-out/host/genfiles/rbi/procs.rbi:193
    typeMember(=) <constant:Arg2> @ bazel-out/host/genfiles/rbi/procs.rbi:194
    typeMember(=) <constant:Arg3> @ bazel-out/host/genfiles/rbi/procs.rbi:195
    typeMember(=) <constant:Arg4> @ bazel-out/host/genfiles/rbi/procs.rbi:196
    typeMember(=) <constant:Arg5> @ bazel-out/host/genfiles/rbi/procs.rbi:197
    typeMember(=) <constant:Arg6> @ bazel-out/host/genfiles/rbi/procs.rbi:198
    typeMember(=) <constant:Arg7> @ bazel-out/host/genfiles/rbi/procs.rbi:199
    typeMember(=) <constant:Arg8> @ bazel-out/host/genfiles/rbi/procs.rbi:200
    typeMember(=) <constant:Return> @ bazel-out/host/genfiles/rbi/procs.rbi:191
  class <constant:Proc> < ::<constant:Object> () -> <Class:Proc> @ rbi/stdlib.rbi:__LINE__
    method arity () -> Integer @ rbi/stdlib.rbi:__LINE__
    method binding () -> Binding @ rbi/stdlib.rbi:__LINE__
    method clone () -> Proc @ rbi/stdlib.rbi:__LINE__
    method curry (arity) -> Proc @ rbi/stdlib.rbi:__LINE__
      argument arity<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method dup () -> Proc @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Proc @ rbi/stdlib.rbi:__LINE__
    method hash () -> Integer @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method lambda () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method parameters () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = TupleType {
            0 = Symbol
            1 = Symbol
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method source_location () -> TupleType {
      0 = String
      1 = Integer
    } @ rbi/stdlib.rbi:__LINE__
    method taint () -> Proc @ rbi/stdlib.rbi:__LINE__
    method to_proc () -> Proc @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method trust () -> Proc @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Proc @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Proc @ rbi/stdlib.rbi:__LINE__
  class <constant:Process> (<constant:BasicObject>) -> <Class:Process> @ rbi/stdlib.rbi:__LINE__
    class <constant:GID> (<constant:BasicObject>) -> <Class:Process::GID> @ rbi/stdlib.rbi:__LINE__
    class <constant:Status> < ::<constant:Object> () -> <Class:Process::Status> @ rbi/stdlib.rbi:__LINE__
      method & (num) -> Integer @ rbi/stdlib.rbi:__LINE__
        argument num<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method == (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
        argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      method >> (num) -> Integer @ rbi/stdlib.rbi:__LINE__
        argument num<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method coredump? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method exited? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method exitstatus () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      method inspect () -> String @ rbi/stdlib.rbi:__LINE__
      method pid () -> Integer @ rbi/stdlib.rbi:__LINE__
      method signaled? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method stopped? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method stopsig () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      method success? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method termsig () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      method to_i () -> Integer @ rbi/stdlib.rbi:__LINE__
      method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    class <constant:Sys> (<constant:BasicObject>) -> <Class:Process::Sys> @ rbi/stdlib.rbi:__LINE__
    class <constant:Tms>[<constant:Elem>] < ::<constant:Struct> () -> <Class:Process::Tms> @ rbi/stdlib.rbi:__LINE__
      typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
    class <constant:UID> (<constant:BasicObject>) -> <Class:Process::UID> @ rbi/stdlib.rbi:__LINE__
    class <constant:Waiter> < ::<constant:Thread> () -> <Class:Process::Waiter> @ rbi/stdlib.rbi:__LINE__
      method pid () -> Integer @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:GID>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
      method <overload N.1 : switch> (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
        argument blk<block> -> AppliedType {
          klass = ::<constant:Proc0>
          targs = [
            <constant:Return> = BasicObject
          ]
        } @ rbi/stdlib.rbi:__LINE__
      method change_privilege (group) -> Integer @ rbi/stdlib.rbi:__LINE__
        argument group<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method eid () -> Integer @ rbi/stdlib.rbi:__LINE__
      method eid= (group) -> Integer @ rbi/stdlib.rbi:__LINE__
        argument group<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method from_name (name) -> Integer @ rbi/stdlib.rbi:__LINE__
        argument name<> -> String @ rbi/stdlib.rbi:__LINE__
      method grant_privilege (group) -> Integer @ rbi/stdlib.rbi:__LINE__
        argument group<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method re_exchange () -> Integer @ rbi/stdlib.rbi:__LINE__
      method re_exchangeable? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method rid () -> Integer @ rbi/stdlib.rbi:__LINE__
      method sid_available? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method switch () -> Integer @ rbi/stdlib.rbi:__LINE__
        argument blk<block> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Status>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Sys>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
      method geteuid () -> Integer @ rbi/stdlib.rbi:__LINE__
      method getgid () -> Integer @ rbi/stdlib.rbi:__LINE__
      method getuid () -> Integer @ rbi/stdlib.rbi:__LINE__
      method issetugid () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method setegid (group) -> NilClass @ rbi/stdlib.rbi:__LINE__
        argument group<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method seteuid (user) -> NilClass @ rbi/stdlib.rbi:__LINE__
        argument user<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method setgid (group) -> NilClass @ rbi/stdlib.rbi:__LINE__
        argument group<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method setregid (rid, eid) -> NilClass @ rbi/stdlib.rbi:__LINE__
        argument eid<> -> Integer @ rbi/stdlib.rbi:__LINE__
        argument rid<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method setresgid (rid, eid, sid) -> NilClass @ rbi/stdlib.rbi:__LINE__
        argument eid<> -> Integer @ rbi/stdlib.rbi:__LINE__
        argument rid<> -> Integer @ rbi/stdlib.rbi:__LINE__
        argument sid<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method setresuid (rid, eid, sid) -> NilClass @ rbi/stdlib.rbi:__LINE__
        argument eid<> -> Integer @ rbi/stdlib.rbi:__LINE__
        argument rid<> -> Integer @ rbi/stdlib.rbi:__LINE__
        argument sid<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method setreuid (rid, eid) -> NilClass @ rbi/stdlib.rbi:__LINE__
        argument eid<> -> Integer @ rbi/stdlib.rbi:__LINE__
        argument rid<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method setrgid (group) -> NilClass @ rbi/stdlib.rbi:__LINE__
        argument group<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method setruid (user) -> NilClass @ rbi/stdlib.rbi:__LINE__
        argument user<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method setuid (user) -> NilClass @ rbi/stdlib.rbi:__LINE__
        argument user<> -> Integer @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Tms>> < ::<singleton class:<constant:Struct>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:UID>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
      method <overload N.1 : switch> (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
        argument blk<block> -> AppliedType {
          klass = ::<constant:Proc0>
          targs = [
            <constant:Return> = BasicObject
          ]
        } @ rbi/stdlib.rbi:__LINE__
      method change_privilege (user) -> Integer @ rbi/stdlib.rbi:__LINE__
        argument user<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method eid () -> Integer @ rbi/stdlib.rbi:__LINE__
      method eid= (user) -> Integer @ rbi/stdlib.rbi:__LINE__
        argument user<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method from_name (name) -> Integer @ rbi/stdlib.rbi:__LINE__
        argument name<> -> String @ rbi/stdlib.rbi:__LINE__
      method grant_privilege (user) -> Integer @ rbi/stdlib.rbi:__LINE__
        argument user<> -> Integer @ rbi/stdlib.rbi:__LINE__
      method re_exchange () -> Integer @ rbi/stdlib.rbi:__LINE__
      method re_exchangeable? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method rid () -> Integer @ rbi/stdlib.rbi:__LINE__
      method sid_available? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      method switch () -> Integer @ rbi/stdlib.rbi:__LINE__
        argument blk<block> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Waiter>> < ::<singleton class:<constant:Thread>> () @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CLOCK_BOOTTIME> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CLOCK_BOOTTIME_ALARM> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CLOCK_MONOTONIC> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CLOCK_MONOTONIC_COARSE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CLOCK_MONOTONIC_RAW> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CLOCK_PROCESS_CPUTIME_ID> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CLOCK_REALTIME> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CLOCK_REALTIME_ALARM> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CLOCK_REALTIME_COARSE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CLOCK_THREAD_CPUTIME_ID> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:PRIO_PGRP> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:PRIO_PROCESS> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:PRIO_USER> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_AS> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_CORE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_CPU> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_DATA> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_FSIZE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_MEMLOCK> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_MSGQUEUE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_NICE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_NOFILE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_NPROC> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_RSS> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_RTPRIO> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_RTTIME> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_SIGPENDING> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIMIT_STACK> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIM_INFINITY> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIM_SAVED_CUR> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RLIM_SAVED_MAX> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WNOHANG> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WUNTRACED> -> Integer @ rbi/stdlib.rbi:__LINE__
  class <constant:Random> < ::<constant:Object> (<constant:Formatter>) -> <Class:Random> @ rbi/stdlib.rbi:__LINE__
    class <constant:Formatter> (<constant:BasicObject>) -> <Class:Random::Formatter> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Formatter>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : rand> (max) -> Float @ rbi/stdlib.rbi:__LINE__
      argument max<optional> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = Float
            ]
          } | Float @ rbi/stdlib.rbi:__LINE__
    method == (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method bytes (size) -> String @ rbi/stdlib.rbi:__LINE__
      argument size<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method clone () -> Random @ rbi/stdlib.rbi:__LINE__
    method dup () -> Random @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Random @ rbi/stdlib.rbi:__LINE__
    method initialize (seed) -> Object @ rbi/stdlib.rbi:__LINE__
      argument seed<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method rand (max) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument max<optional> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = Integer
            ]
          } | Integer @ rbi/stdlib.rbi:__LINE__
    method seed () -> Integer @ rbi/stdlib.rbi:__LINE__
    method taint () -> Random @ rbi/stdlib.rbi:__LINE__
    method trust () -> Random @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Random @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Random @ rbi/stdlib.rbi:__LINE__
    static-field <constant:DEFAULT> -> Random @ rbi/stdlib.rbi:__LINE__
  class <constant:Range>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Range> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : first> (n) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument n<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : last> (n) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument n<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : max> (blk) -> LambdaParam(::<constant:Range>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument n<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : min> (blk) -> LambdaParam(::<constant:Range>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument n<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : step> (n) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument n<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : max> (n) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument n<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : min> (n) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument n<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : max> (n, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument n<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : min> (n, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument n<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method == (obj) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method === (obj) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method begin () -> LambdaParam(::<constant:Range>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method bsearch (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method clone () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method cover? (obj) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method dup () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method each (blk) -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method end () -> LambdaParam(::<constant:Range>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method eql? (obj) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method exclude_end? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method first () -> LambdaParam(::<constant:Range>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument n<optional> @ rbi/stdlib.rbi:__LINE__
    method freeze () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method hash () -> Integer @ rbi/stdlib.rbi:__LINE__
    method include? (obj) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method initialize (_begin, _end, exclude_end) -> Object @ rbi/stdlib.rbi:__LINE__
      argument _begin<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument _end<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument exclude_end<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method last () -> LambdaParam(::<constant:Range>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument n<optional> @ rbi/stdlib.rbi:__LINE__
    method max () -> LambdaParam(::<constant:Range>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument n<optional> @ rbi/stdlib.rbi:__LINE__
    method member? (obj) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method min () -> LambdaParam(::<constant:Range>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument n<optional> @ rbi/stdlib.rbi:__LINE__
    method size () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
    method step (n, blk) -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument n<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method taint () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method trust () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untaint () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untrust () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
  class <constant:RangeError> < ::<constant:StandardError> () -> <Class:RangeError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> RangeError @ rbi/stdlib.rbi:__LINE__
    method dup () -> RangeError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> RangeError @ rbi/stdlib.rbi:__LINE__
    method taint () -> RangeError @ rbi/stdlib.rbi:__LINE__
    method trust () -> RangeError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> RangeError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> RangeError @ rbi/stdlib.rbi:__LINE__
  class <constant:Rational> < ::<constant:Numeric> () -> <Class:Rational> @ rbi/stdlib.rbi:__LINE__
    method % (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method * (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method ** (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method + (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method +@ () -> Rational @ rbi/stdlib.rbi:__LINE__
    method - (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method -@ () -> Rational @ rbi/stdlib.rbi:__LINE__
    method / (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method < (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <= (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <=> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : %> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : **> (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : *> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : +> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : -> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : /> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : <=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : <=>> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : <> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : >=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : >> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : ceil> (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : coerce> (arg0) -> TupleType {
      0 = Float
      1 = Float
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : div> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : fdiv> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : floor> (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : modulo> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : quo> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Float @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : rationalize> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : round> (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : truncate> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : %> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : **> (arg0) -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : *> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : +> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : -> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : /> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : <=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : <=>> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : <> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : >=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : >> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : coerce> (arg0) -> TupleType {
      0 = Rational
      1 = Rational
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : div> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : fdiv> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : modulo> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : quo> (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Rational @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : %> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : **> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : *> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : +> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : -> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : /> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : <=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : <=>> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : <> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : >=> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : >> (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : coerce> (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal | Complex
      1 = Integer | Float | Rational | BigDecimal | Complex
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : div> (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : fdiv> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : modulo> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : quo> (arg0) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BigDecimal @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : **> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : *> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : +> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : -> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : /> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : fdiv> (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : quo> (arg0) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Complex @ rbi/stdlib.rbi:__LINE__
    method == (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method > (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method >= (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method abs () -> Rational @ rbi/stdlib.rbi:__LINE__
    method abs2 () -> Rational @ rbi/stdlib.rbi:__LINE__
    method angle () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method arg () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method ceil () -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method clone () -> Rational @ rbi/stdlib.rbi:__LINE__
    method coerce (arg0) -> TupleType {
      0 = Rational
      1 = Rational
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method conj () -> Rational @ rbi/stdlib.rbi:__LINE__
    method conjugate () -> Rational @ rbi/stdlib.rbi:__LINE__
    method denominator () -> Integer @ rbi/stdlib.rbi:__LINE__
    method div (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method divmod (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method dup () -> Rational @ rbi/stdlib.rbi:__LINE__
    method equal? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method fdiv (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method floor () -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Rational @ rbi/stdlib.rbi:__LINE__
    method hash () -> Integer @ rbi/stdlib.rbi:__LINE__
    method imag () -> Integer @ rbi/stdlib.rbi:__LINE__
    method imaginary () -> Integer @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method modulo (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method numerator () -> Integer @ rbi/stdlib.rbi:__LINE__
    method phase () -> Integer | Float | Rational | BigDecimal | Complex @ rbi/stdlib.rbi:__LINE__
    method quo (arg0) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method rationalize () -> Rational @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method real () -> Rational @ rbi/stdlib.rbi:__LINE__
    method real? () -> TrueClass @ rbi/stdlib.rbi:__LINE__
    method round () -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method taint () -> Rational @ rbi/stdlib.rbi:__LINE__
    method to_c () -> Complex @ rbi/stdlib.rbi:__LINE__
    method to_f () -> Float @ rbi/stdlib.rbi:__LINE__
    method to_i () -> Integer @ rbi/stdlib.rbi:__LINE__
    method to_r () -> Rational @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method truncate () -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method trust () -> Rational @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Rational @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Rational @ rbi/stdlib.rbi:__LINE__
    method zero? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
  class <constant:RbConfig> (<constant:BasicObject>) -> <Class:RbConfig> @ rbi/stdlib.rbi:__LINE__
    static-field <constant:CONFIG> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:DESTDIR> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MAKEFILE_CONFIG> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:TOPDIR> -> String @ rbi/stdlib.rbi:__LINE__
  class <constant:Regexp> < ::<constant:Object> () -> <Class:Regexp> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : initialize> (arg0) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp @ rbi/stdlib.rbi:__LINE__
      argument kcode<optional> @ rbi/stdlib.rbi:__LINE__
      argument options<optional> @ rbi/stdlib.rbi:__LINE__
    method == (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method === (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method =~ (str) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument str<> -> String @ rbi/stdlib.rbi:__LINE__
    method casefold? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method clone () -> Regexp @ rbi/stdlib.rbi:__LINE__
    method dup () -> Regexp @ rbi/stdlib.rbi:__LINE__
    method encoding () -> Encoding @ rbi/stdlib.rbi:__LINE__
    method eql? (other) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method fixed_encoding? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Regexp @ rbi/stdlib.rbi:__LINE__
    method hash () -> Integer @ rbi/stdlib.rbi:__LINE__
    method initialize (arg0, options, kcode) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument kcode<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument options<optional> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method match (arg0, arg1) -> MatchData | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method named_captures () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = String
        <constant:V> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = Integer
            ]
          }
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method names () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method options () -> Integer @ rbi/stdlib.rbi:__LINE__
    method source () -> String @ rbi/stdlib.rbi:__LINE__
    method taint () -> Regexp @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method trust () -> Regexp @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Regexp @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Regexp @ rbi/stdlib.rbi:__LINE__
    method ~ () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
    static-field <constant:EXTENDED> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FIXEDENCODING> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:IGNORECASE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:MULTILINE> -> Integer @ rbi/stdlib.rbi:__LINE__
    static-field <constant:NOENCODING> -> Integer @ rbi/stdlib.rbi:__LINE__
  class <constant:RegexpError> < ::<constant:StandardError> () -> <Class:RegexpError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> RegexpError @ rbi/stdlib.rbi:__LINE__
    method dup () -> RegexpError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> RegexpError @ rbi/stdlib.rbi:__LINE__
    method taint () -> RegexpError @ rbi/stdlib.rbi:__LINE__
    method trust () -> RegexpError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> RegexpError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> RegexpError @ rbi/stdlib.rbi:__LINE__
  class <constant:RubyTyper> () -> <Class:RubyTyper> @ ???
    class <constant:DynamicStruct>[<constant:Elem>] < ::<constant:Struct> () -> <Class:RubyTyper::DynamicStruct> @ rbi/ruby_typer.rbi:12
      typeMember(=) <constant:Elem> -> untyped @ rbi/ruby_typer.rbi:13
    class <constant:StubClass> < ::<constant:Object> () -> <Class:RubyTyper::StubClass> @ rbi/ruby_typer.rbi:22
    class <singleton class:<constant:DynamicStruct>> < ::<singleton class:<constant:Struct>> () @ rbi/ruby_typer.rbi:12
      method new (arg1) -> AppliedType {
        klass = ::<constant:RubyTyper>::<constant:DynamicStruct>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/ruby_typer.rbi:19
        argument arg1<repeated> -> untyped @ rbi/ruby_typer.rbi:19
    class <singleton class:<constant:StubClass>> < ::<singleton class:<constant:Object>> () @ ???
  class <constant:RubyVM> < ::<constant:Object> () -> <Class:RubyVM> @ rbi/stdlib.rbi:__LINE__
    class <constant:InstructionSequence> < ::<constant:Object> () -> <Class:RubyVM::InstructionSequence> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:InstructionSequence>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    method clone () -> RubyVM @ rbi/stdlib.rbi:__LINE__
    method dup () -> RubyVM @ rbi/stdlib.rbi:__LINE__
    method freeze () -> RubyVM @ rbi/stdlib.rbi:__LINE__
    method taint () -> RubyVM @ rbi/stdlib.rbi:__LINE__
    method trust () -> RubyVM @ rbi/stdlib.rbi:__LINE__
    method untaint () -> RubyVM @ rbi/stdlib.rbi:__LINE__
    method untrust () -> RubyVM @ rbi/stdlib.rbi:__LINE__
    static-field <constant:DEFAULT_PARAMS> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:INSTRUCTION_NAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:OPTS> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
  class <constant:RuntimeError> < ::<constant:StandardError> () -> <Class:RuntimeError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> RuntimeError @ rbi/stdlib.rbi:__LINE__
    method dup () -> RuntimeError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> RuntimeError @ rbi/stdlib.rbi:__LINE__
    method taint () -> RuntimeError @ rbi/stdlib.rbi:__LINE__
    method trust () -> RuntimeError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> RuntimeError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> RuntimeError @ rbi/stdlib.rbi:__LINE__
  class <constant:ScriptError> < ::<constant:Exception> () -> <Class:ScriptError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> ScriptError @ rbi/stdlib.rbi:__LINE__
    method dup () -> ScriptError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> ScriptError @ rbi/stdlib.rbi:__LINE__
    method taint () -> ScriptError @ rbi/stdlib.rbi:__LINE__
    method trust () -> ScriptError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> ScriptError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> ScriptError @ rbi/stdlib.rbi:__LINE__
  class <constant:SecurityError> < ::<constant:Exception> () -> <Class:SecurityError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> SecurityError @ rbi/stdlib.rbi:__LINE__
    method dup () -> SecurityError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> SecurityError @ rbi/stdlib.rbi:__LINE__
    method taint () -> SecurityError @ rbi/stdlib.rbi:__LINE__
    method trust () -> SecurityError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> SecurityError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> SecurityError @ rbi/stdlib.rbi:__LINE__
  class <constant:Set>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Set> @ rbi/stdlib.rbi:__LINE__
    method & (enum) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method + (enum) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method - (enum) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method < (set) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument set<> -> untyped @ rbi/stdlib.rbi:__LINE__
    method << (o) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method <= (set) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument set<> -> untyped @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method > (set) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument set<> -> untyped @ rbi/stdlib.rbi:__LINE__
    method >= (set) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument set<> -> untyped @ rbi/stdlib.rbi:__LINE__
    method ^ (enum) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method add (o) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method add? (o) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method classify (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Set>#<constant:Elem>)
          <constant:Arg0> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method clear () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method clone () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method collect! (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method delete (o) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method delete? (o) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method delete_if (blk) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method difference (enum) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method disjoint? (set) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument set<> -> untyped @ rbi/stdlib.rbi:__LINE__
    method dup () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method each (blk) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method empty? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method flatten () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method flatten! () -> untyped @ rbi/stdlib.rbi:__LINE__
    method freeze () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method include? (o) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method initialize (enum) -> Object @ rbi/stdlib.rbi:__LINE__
      argument enum<optional> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = BasicObject
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method intersect? (set) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument set<> -> untyped @ rbi/stdlib.rbi:__LINE__
    method intersection (enum) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method keep_if (blk) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method length () -> Integer @ rbi/stdlib.rbi:__LINE__
    method map! (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method member? (o) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method merge (enum) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method proper_subset? (set) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument set<> -> untyped @ rbi/stdlib.rbi:__LINE__
    method proper_superset? (set) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument set<> -> untyped @ rbi/stdlib.rbi:__LINE__
    method reject! (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method replace (enum) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = BasicObject
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method select! (blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method size () -> Integer @ rbi/stdlib.rbi:__LINE__
    method subset? (set) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument set<> -> untyped @ rbi/stdlib.rbi:__LINE__
    method subtract (enum) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method superset? (set) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument set<> -> untyped @ rbi/stdlib.rbi:__LINE__
    method taint () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method to_a () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method trust () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method union (enum) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method untaint () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untrust () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method | (enum) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
  class <constant:Signal> (<constant:BasicObject>) -> <Class:Signal> @ rbi/stdlib.rbi:__LINE__
  class <constant:SignalException> < ::<constant:Exception> () -> <Class:SignalException> @ rbi/stdlib.rbi:__LINE__
    method clone () -> SignalException @ rbi/stdlib.rbi:__LINE__
    method dup () -> SignalException @ rbi/stdlib.rbi:__LINE__
    method freeze () -> SignalException @ rbi/stdlib.rbi:__LINE__
    method taint () -> SignalException @ rbi/stdlib.rbi:__LINE__
    method trust () -> SignalException @ rbi/stdlib.rbi:__LINE__
    method untaint () -> SignalException @ rbi/stdlib.rbi:__LINE__
    method untrust () -> SignalException @ rbi/stdlib.rbi:__LINE__
  class <constant:SingleForwardable> (<constant:BasicObject>) -> <Class:SingleForwardable> @ rbi/stdlib.rbi:__LINE__
  class <constant:SortedSet>[<constant:Elem>] < ::<constant:Set> () -> <Class:SortedSet> @ rbi/stdlib.rbi:__LINE__
    method add (o) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument o<> -> LambdaParam(::<constant:SortedSet>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method clear () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method clone () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method delete (o) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument o<> -> LambdaParam(::<constant:SortedSet>#<constant:Elem>) @ rbi/stdlib.rbi:__LINE__
    method delete_if (blk) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:SortedSet>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method dup () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method each (blk) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:SortedSet>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method freeze () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method keep_if (blk) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:SortedSet>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method merge (enum) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:SortedSet>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method subtract (enum) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:SortedSet>#<constant:Elem>)
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method taint () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method trust () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untaint () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untrust () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:Elem> @ rbi/stdlib.rbi:__LINE__
  class <constant:StandardError> < ::<constant:Exception> () -> <Class:StandardError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> StandardError @ rbi/stdlib.rbi:__LINE__
    method dup () -> StandardError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> StandardError @ rbi/stdlib.rbi:__LINE__
    method taint () -> StandardError @ rbi/stdlib.rbi:__LINE__
    method trust () -> StandardError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> StandardError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> StandardError @ rbi/stdlib.rbi:__LINE__
  class <constant:StopIteration> < ::<constant:IndexError> () -> <Class:StopIteration> @ rbi/stdlib.rbi:__LINE__
    method clone () -> StopIteration @ rbi/stdlib.rbi:__LINE__
    method dup () -> StopIteration @ rbi/stdlib.rbi:__LINE__
    method freeze () -> StopIteration @ rbi/stdlib.rbi:__LINE__
    method taint () -> StopIteration @ rbi/stdlib.rbi:__LINE__
    method trust () -> StopIteration @ rbi/stdlib.rbi:__LINE__
    method untaint () -> StopIteration @ rbi/stdlib.rbi:__LINE__
    method untrust () -> StopIteration @ rbi/stdlib.rbi:__LINE__
  class <constant:String> < ::<constant:Object> (<constant:Comparable>) -> <Class:String> @ rbi/stdlib.rbi:__LINE__
    method % (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method * (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method + (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method << (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method <=> (other) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> String @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : []> (arg0) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = Integer
            ]
          } | Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : byteslice> (arg0) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : codepoints> (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_byte> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_char> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_codepoint> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : each_line> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : gsub!> (arg0, blk) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : gsub> (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : match> (arg0, arg1) -> MatchData @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : scan> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = AppliedType {
                klass = ::<constant:Array>
                targs = [
                  <constant:Elem> = String
                ]
              } | String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : scrub!> (arg0, blk) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : scrub> (arg0, blk) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : slice!> (arg0) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = Integer
            ]
          } | Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : slice> (arg0) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = Integer
            ]
          } | Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : split> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : sub!> (arg0, blk) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : sub> (arg0, blk) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : upto> (arg0, arg1, blk) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : []> (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : gsub!> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : gsub> (arg0, blk) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : slice!> (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : slice> (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : []> (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : gsub> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : slice!> (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : slice> (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : []> (arg0) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : gsub> (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : slice!> (arg0) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.4 : slice> (arg0) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method == (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method === (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method =~ (arg0) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method [] (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method ascii_only? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method b () -> String @ rbi/stdlib.rbi:__LINE__
    method bytes () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method bytesize () -> Integer @ rbi/stdlib.rbi:__LINE__
    method byteslice (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method capitalize () -> String @ rbi/stdlib.rbi:__LINE__
    method capitalize! () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method casecmp (arg0) -> NilClass | Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method center (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method chars () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method chomp (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method chomp! (arg0) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method chop () -> String @ rbi/stdlib.rbi:__LINE__
    method chop! () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method chr () -> String @ rbi/stdlib.rbi:__LINE__
    method clear () -> String @ rbi/stdlib.rbi:__LINE__
    method clone () -> String @ rbi/stdlib.rbi:__LINE__
    method codepoints () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method concat (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
    method count (arg0, arg1) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<repeated> -> String @ rbi/stdlib.rbi:__LINE__
    method crypt (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method delete (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<repeated> -> String @ rbi/stdlib.rbi:__LINE__
    method delete! (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<repeated> -> String @ rbi/stdlib.rbi:__LINE__
    method downcase () -> String @ rbi/stdlib.rbi:__LINE__
    method downcase! () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method dump () -> String @ rbi/stdlib.rbi:__LINE__
    method dup () -> String @ rbi/stdlib.rbi:__LINE__
    method each_byte (blk) -> String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_char (blk) -> String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_codepoint (blk) -> String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method each_line (arg0, blk) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method empty? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method encoding () -> Encoding @ rbi/stdlib.rbi:__LINE__
    method end_with? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> String @ rbi/stdlib.rbi:__LINE__
    method eql? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method force_encoding (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String | Encoding @ rbi/stdlib.rbi:__LINE__
    method freeze () -> String @ rbi/stdlib.rbi:__LINE__
    method getbyte (arg0) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method gsub (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method gsub! (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method hash () -> Integer @ rbi/stdlib.rbi:__LINE__
    method hex () -> Integer @ rbi/stdlib.rbi:__LINE__
    method include? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method index (arg0, arg1) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method initialize (str) -> Object @ rbi/stdlib.rbi:__LINE__
      argument str<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method insert (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> String @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method intern () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method length () -> Integer @ rbi/stdlib.rbi:__LINE__
    method lines (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method ljust (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method lstrip () -> String @ rbi/stdlib.rbi:__LINE__
    method lstrip! () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method match (arg0) -> MatchData @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
    method next () -> String @ rbi/stdlib.rbi:__LINE__
    method next! () -> String @ rbi/stdlib.rbi:__LINE__
    method oct () -> Integer @ rbi/stdlib.rbi:__LINE__
    method ord () -> Integer @ rbi/stdlib.rbi:__LINE__
    method partition (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
    method prepend (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method replace (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method reverse () -> String @ rbi/stdlib.rbi:__LINE__
    method rindex (arg0, arg1) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String | Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method rjust (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method rpartition (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String | Regexp @ rbi/stdlib.rbi:__LINE__
    method rstrip () -> String @ rbi/stdlib.rbi:__LINE__
    method rstrip! () -> String @ rbi/stdlib.rbi:__LINE__
    method scan (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = AppliedType {
                klass = ::<constant:Array>
                targs = [
                  <constant:Elem> = String
                ]
              } | String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method scrub (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method scrub! (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method setbyte (arg0, arg1) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method size () -> Integer @ rbi/stdlib.rbi:__LINE__
    method slice (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method slice! (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method split (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method squeeze (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method squeeze! (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method start_with? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> String @ rbi/stdlib.rbi:__LINE__
    method strip () -> String @ rbi/stdlib.rbi:__LINE__
    method strip! () -> String @ rbi/stdlib.rbi:__LINE__
    method sub (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> AppliedType {
            klass = ::<constant:Hash>
            targs = [
              <constant:K> = untyped
              <constant:V> = untyped
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method sub! (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp | String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method succ () -> String @ rbi/stdlib.rbi:__LINE__
    method sum (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method swapcase () -> String @ rbi/stdlib.rbi:__LINE__
    method swapcase! () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method taint () -> String @ rbi/stdlib.rbi:__LINE__
    method to_c () -> Complex @ rbi/stdlib.rbi:__LINE__
    method to_f () -> Float @ rbi/stdlib.rbi:__LINE__
    method to_i (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method to_r () -> Rational @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method to_str () -> String @ rbi/stdlib.rbi:__LINE__
    method to_sym () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method tr (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> String @ rbi/stdlib.rbi:__LINE__
    method tr! (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> String @ rbi/stdlib.rbi:__LINE__
    method tr_s (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> String @ rbi/stdlib.rbi:__LINE__
    method tr_s! (arg0, arg1) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> String @ rbi/stdlib.rbi:__LINE__
    method trust () -> String @ rbi/stdlib.rbi:__LINE__
    method unpack (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method untaint () -> String @ rbi/stdlib.rbi:__LINE__
    method untrust () -> String @ rbi/stdlib.rbi:__LINE__
    method upcase () -> String @ rbi/stdlib.rbi:__LINE__
    method upcase! () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method upto (arg0, arg1) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method valid_encoding? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
  class <constant:StringIO>[<constant:Elem>] < ::<constant:Data> (<constant:Enumerable>) -> <Class:StringIO> @ rbi/stdlib.rbi:__LINE__
    method clone () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method dup () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method freeze () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method taint () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method trust () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untaint () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untrust () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:Elem> -> String @ rbi/stdlib.rbi:__LINE__
  class <constant:StringScanner> < ::<constant:Object> () -> <Class:StringScanner> @ rbi/stdlib.rbi:__LINE__
    method eos? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method getch () -> String @ rbi/stdlib.rbi:__LINE__
    method scan (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp @ rbi/stdlib.rbi:__LINE__
  class <constant:Struct>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Struct> @ rbi/stdlib.rbi:__LINE__
    method clone () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method dup () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method freeze () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method taint () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method trust () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untaint () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method untrust () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    typeMember(=) <constant:Elem> -> untyped @ rbi/stdlib.rbi:__LINE__
  class <constant:Symbol> < ::<constant:Object> (<constant:Comparable>) -> <Class:Symbol> @ rbi/stdlib.rbi:__LINE__
    method <=> (other) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : []> (n) -> String @ rbi/stdlib.rbi:__LINE__
      argument idx<> @ rbi/stdlib.rbi:__LINE__
      argument n<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : slice> (n) -> String @ rbi/stdlib.rbi:__LINE__
      argument idx<> @ rbi/stdlib.rbi:__LINE__
      argument n<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : []> () -> String @ rbi/stdlib.rbi:__LINE__
      argument idx<> @ rbi/stdlib.rbi:__LINE__
      argument n<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : slice> () -> String @ rbi/stdlib.rbi:__LINE__
      argument idx<> @ rbi/stdlib.rbi:__LINE__
      argument n<optional> @ rbi/stdlib.rbi:__LINE__
    method == (obj) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method =~ (obj) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method [] (idx) -> String @ rbi/stdlib.rbi:__LINE__
      argument idx<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument n<optional> @ rbi/stdlib.rbi:__LINE__
    method capitalize () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method casecmp (other) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method clone () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method downcase () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method dup () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method empty? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method encoding () -> Encoding @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method id2name () -> String @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method intern () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method length () -> Integer @ rbi/stdlib.rbi:__LINE__
    method match (obj) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method size () -> Integer @ rbi/stdlib.rbi:__LINE__
    method slice (idx) -> String @ rbi/stdlib.rbi:__LINE__
      argument idx<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument n<optional> @ rbi/stdlib.rbi:__LINE__
    method succ () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method swapcase () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method taint () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method to_proc () -> Proc @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method to_sym () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method trust () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Symbol @ rbi/stdlib.rbi:__LINE__
    method upcase () -> Symbol @ rbi/stdlib.rbi:__LINE__
  class <constant:SyntaxError> < ::<constant:ScriptError> () -> <Class:SyntaxError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> SyntaxError @ rbi/stdlib.rbi:__LINE__
    method dup () -> SyntaxError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> SyntaxError @ rbi/stdlib.rbi:__LINE__
    method taint () -> SyntaxError @ rbi/stdlib.rbi:__LINE__
    method trust () -> SyntaxError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> SyntaxError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> SyntaxError @ rbi/stdlib.rbi:__LINE__
  class <constant:SystemCallError> < ::<constant:StandardError> () -> <Class:SystemCallError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> SystemCallError @ rbi/stdlib.rbi:__LINE__
    method dup () -> SystemCallError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> SystemCallError @ rbi/stdlib.rbi:__LINE__
    method taint () -> SystemCallError @ rbi/stdlib.rbi:__LINE__
    method trust () -> SystemCallError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> SystemCallError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> SystemCallError @ rbi/stdlib.rbi:__LINE__
  class <constant:SystemExit> < ::<constant:Exception> () -> <Class:SystemExit> @ rbi/stdlib.rbi:__LINE__
    method clone () -> SystemExit @ rbi/stdlib.rbi:__LINE__
    method dup () -> SystemExit @ rbi/stdlib.rbi:__LINE__
    method freeze () -> SystemExit @ rbi/stdlib.rbi:__LINE__
    method taint () -> SystemExit @ rbi/stdlib.rbi:__LINE__
    method trust () -> SystemExit @ rbi/stdlib.rbi:__LINE__
    method untaint () -> SystemExit @ rbi/stdlib.rbi:__LINE__
    method untrust () -> SystemExit @ rbi/stdlib.rbi:__LINE__
  class <constant:SystemStackError> < ::<constant:Exception> () -> <Class:SystemStackError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> SystemStackError @ rbi/stdlib.rbi:__LINE__
    method dup () -> SystemStackError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> SystemStackError @ rbi/stdlib.rbi:__LINE__
    method taint () -> SystemStackError @ rbi/stdlib.rbi:__LINE__
    method trust () -> SystemStackError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> SystemStackError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> SystemStackError @ rbi/stdlib.rbi:__LINE__
  class <constant:T> < ::<constant:Object> () -> <Class:T> @ ???
    class <constant:Array> () -> <Class:T::Array> @ ???
    class <constant:Enumerable> () -> <Class:T::Enumerable> @ ???
    class <constant:Generic> (<constant:BasicObject>, <constant:Helpers>) -> <Class:T::Generic> @ rbi/t.rbi:3
    class <constant:Hash> () -> <Class:T::Hash> @ ???
    class <constant:Helpers> (<constant:BasicObject>) -> <Class:T::Helpers> @ rbi/t.rbi:1
    class <constant:Proc> () -> <Class:T::Proc> @ ???
    class <singleton class:<constant:Array>> < ::<constant:Module> () @ ???
    class <singleton class:<constant:Enumerable>> < ::<constant:Module> () @ ???
    class <singleton class:<constant:Generic>> < ::<constant:Module> () @ rbi/t.rbi:3
    class <singleton class:<constant:Hash>> < ::<constant:Module> () @ ???
    class <singleton class:<constant:Helpers>> < ::<constant:Module> () @ rbi/t.rbi:1
    class <singleton class:<constant:Proc>> < ::<constant:Module> () @ ???
    method all () @ ???
    method any () @ ???
    method nilable () @ ???
    method untyped () @ ???
  class <constant:Thread> < ::<constant:Object> () -> <Class:Thread> @ rbi/stdlib.rbi:__LINE__
    class <constant:Backtrace> < ::<constant:Object> () -> <Class:Thread::Backtrace> @ rbi/stdlib.rbi:__LINE__
      class <constant:Location> < ::<constant:Object> () -> <Class:Thread::Backtrace::Location> @ rbi/stdlib.rbi:__LINE__
      class <singleton class:<constant:Location>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <constant:ConditionVariable> < ::<constant:Object> () -> <Class:Thread::ConditionVariable> @ rbi/stdlib.rbi:__LINE__
    class <constant:Mutex> < ::<constant:Object> () -> <Class:Thread::Mutex> @ rbi/stdlib.rbi:__LINE__
    class <constant:Queue> < ::<constant:Object> () -> <Class:Thread::Queue> @ rbi/stdlib.rbi:__LINE__
    class <constant:SizedQueue> < ::<constant:Thread>::<constant:Queue> () -> <Class:Thread::SizedQueue> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Backtrace>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:ConditionVariable>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Mutex>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Queue>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:SizedQueue>> < ::<constant:Thread>::<singleton class:<constant:Queue>> () @ rbi/stdlib.rbi:__LINE__
    method clone () -> Thread @ rbi/stdlib.rbi:__LINE__
    method dup () -> Thread @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Thread @ rbi/stdlib.rbi:__LINE__
    method taint () -> Thread @ rbi/stdlib.rbi:__LINE__
    method trust () -> Thread @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Thread @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Thread @ rbi/stdlib.rbi:__LINE__
  class <constant:ThreadError> < ::<constant:StandardError> () -> <Class:ThreadError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> ThreadError @ rbi/stdlib.rbi:__LINE__
    method dup () -> ThreadError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> ThreadError @ rbi/stdlib.rbi:__LINE__
    method taint () -> ThreadError @ rbi/stdlib.rbi:__LINE__
    method trust () -> ThreadError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> ThreadError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> ThreadError @ rbi/stdlib.rbi:__LINE__
  class <constant:ThreadGroup> < ::<constant:Object> () -> <Class:ThreadGroup> @ rbi/stdlib.rbi:__LINE__
    method clone () -> ThreadGroup @ rbi/stdlib.rbi:__LINE__
    method dup () -> ThreadGroup @ rbi/stdlib.rbi:__LINE__
    method freeze () -> ThreadGroup @ rbi/stdlib.rbi:__LINE__
    method taint () -> ThreadGroup @ rbi/stdlib.rbi:__LINE__
    method trust () -> ThreadGroup @ rbi/stdlib.rbi:__LINE__
    method untaint () -> ThreadGroup @ rbi/stdlib.rbi:__LINE__
    method untrust () -> ThreadGroup @ rbi/stdlib.rbi:__LINE__
  class <constant:Time> < ::<constant:Object> (<constant:Comparable>) -> <Class:Time> @ rbi/stdlib.rbi:__LINE__
    method + (arg0) -> Time @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Numeric @ rbi/stdlib.rbi:__LINE__
    method - (arg0) -> Float @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Time @ rbi/stdlib.rbi:__LINE__
    method <=> (other) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument other<> -> Time @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : -> (arg0) -> Time @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Numeric @ rbi/stdlib.rbi:__LINE__
    method asctime () -> String @ rbi/stdlib.rbi:__LINE__
    method clone () -> Time @ rbi/stdlib.rbi:__LINE__
    method ctime () -> String @ rbi/stdlib.rbi:__LINE__
    method day () -> Integer @ rbi/stdlib.rbi:__LINE__
    method dst? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method dup () -> Time @ rbi/stdlib.rbi:__LINE__
    method eql? (arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method freeze () -> Time @ rbi/stdlib.rbi:__LINE__
    method friday? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method getgm () -> Time @ rbi/stdlib.rbi:__LINE__
    method getlocal (utc_offset) -> Time @ rbi/stdlib.rbi:__LINE__
      argument utc_offset<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method getutc () -> Time @ rbi/stdlib.rbi:__LINE__
    method gmt? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method gmt_offset () -> Integer @ rbi/stdlib.rbi:__LINE__
    method gmtime () -> Time @ rbi/stdlib.rbi:__LINE__
    method gmtoff () -> Integer @ rbi/stdlib.rbi:__LINE__
    method hash () -> Integer @ rbi/stdlib.rbi:__LINE__
    method hour () -> Integer @ rbi/stdlib.rbi:__LINE__
    method initialize (year, month, day, hour, min, sec, usec_with_frac) -> Object @ rbi/stdlib.rbi:__LINE__
      argument day<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument hour<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument min<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument month<optional> -> Integer | String @ rbi/stdlib.rbi:__LINE__
      argument sec<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument usec_with_frac<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument year<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method inspect () -> String @ rbi/stdlib.rbi:__LINE__
    method isdst () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method localtime (utc_offset) -> Time @ rbi/stdlib.rbi:__LINE__
      argument utc_offset<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method mday () -> Integer @ rbi/stdlib.rbi:__LINE__
    method min () -> Integer @ rbi/stdlib.rbi:__LINE__
    method mon () -> Integer @ rbi/stdlib.rbi:__LINE__
    method monday? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method month () -> Integer @ rbi/stdlib.rbi:__LINE__
    method nsec () -> Integer @ rbi/stdlib.rbi:__LINE__
    method round (arg0) -> Time @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method saturday? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method sec () -> Integer @ rbi/stdlib.rbi:__LINE__
    method strftime (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method subsec () -> Numeric @ rbi/stdlib.rbi:__LINE__
    method succ () -> Time @ rbi/stdlib.rbi:__LINE__
    method sunday? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method taint () -> Time @ rbi/stdlib.rbi:__LINE__
    method thursday? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method to_a () -> TupleType {
      0 = Integer
      1 = Integer
      2 = Integer
      3 = Integer
      4 = Integer
      5 = Integer
      6 = Integer
      7 = Integer
      8 = TrueClass | FalseClass
      9 = String
    } @ rbi/stdlib.rbi:__LINE__
    method to_date () -> Date @ rbi/date.rbi:498
    method to_datetime () -> DateTime @ rbi/date.rbi:501
    method to_f () -> Float @ rbi/stdlib.rbi:__LINE__
    method to_i () -> Numeric @ rbi/stdlib.rbi:__LINE__
    method to_r () -> Rational @ rbi/stdlib.rbi:__LINE__
    method to_s () -> String @ rbi/stdlib.rbi:__LINE__
    method to_time () -> Time @ rbi/date.rbi:495
    method trust () -> Time @ rbi/stdlib.rbi:__LINE__
    method tuesday? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method tv_nsec () -> Numeric @ rbi/stdlib.rbi:__LINE__
    method tv_sec () -> Numeric @ rbi/stdlib.rbi:__LINE__
    method tv_usec () -> Numeric @ rbi/stdlib.rbi:__LINE__
    method untaint () -> Time @ rbi/stdlib.rbi:__LINE__
    method untrust () -> Time @ rbi/stdlib.rbi:__LINE__
    method usec () -> Numeric @ rbi/stdlib.rbi:__LINE__
    method utc () -> Time @ rbi/stdlib.rbi:__LINE__
    method utc? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method utc_offset () -> Integer @ rbi/stdlib.rbi:__LINE__
    method wday () -> Integer @ rbi/stdlib.rbi:__LINE__
    method wednesday? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method yday () -> Integer @ rbi/stdlib.rbi:__LINE__
    method year () -> Integer @ rbi/stdlib.rbi:__LINE__
    method zone () -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RFC2822_DAY_NAME> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RFC2822_MONTH_NAME> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
  class <constant:TracePoint> < ::<constant:Object> () -> <Class:TracePoint> @ rbi/stdlib.rbi:__LINE__
    method clone () -> TracePoint @ rbi/stdlib.rbi:__LINE__
    method dup () -> TracePoint @ rbi/stdlib.rbi:__LINE__
    method freeze () -> TracePoint @ rbi/stdlib.rbi:__LINE__
    method taint () -> TracePoint @ rbi/stdlib.rbi:__LINE__
    method trust () -> TracePoint @ rbi/stdlib.rbi:__LINE__
    method untaint () -> TracePoint @ rbi/stdlib.rbi:__LINE__
    method untrust () -> TracePoint @ rbi/stdlib.rbi:__LINE__
  class <constant:TrueClass> < ::<constant:Object> () -> <Class:TrueClass> @ rbi/stdlib.rbi:__LINE__
    method clone () -> TrueClass @ rbi/stdlib.rbi:__LINE__
    method dup () -> TrueClass @ rbi/stdlib.rbi:__LINE__
    method freeze () -> TrueClass @ rbi/stdlib.rbi:__LINE__
    method taint () -> TrueClass @ rbi/stdlib.rbi:__LINE__
    method trust () -> TrueClass @ rbi/stdlib.rbi:__LINE__
    method untaint () -> TrueClass @ rbi/stdlib.rbi:__LINE__
    method untrust () -> TrueClass @ rbi/stdlib.rbi:__LINE__
  class <constant:TypeError> < ::<constant:StandardError> () -> <Class:TypeError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> TypeError @ rbi/stdlib.rbi:__LINE__
    method dup () -> TypeError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> TypeError @ rbi/stdlib.rbi:__LINE__
    method taint () -> TypeError @ rbi/stdlib.rbi:__LINE__
    method trust () -> TypeError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> TypeError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> TypeError @ rbi/stdlib.rbi:__LINE__
  class <constant:URI> (<constant:BasicObject>) -> <Class:URI> @ rbi/stdlib.rbi:__LINE__
    class <constant:BadURIError> < ::<constant:URI>::<constant:Error> () -> <Class:URI::BadURIError> @ rbi/stdlib.rbi:__LINE__
    class <constant:Error> < ::<constant:StandardError> () -> <Class:URI::Error> @ rbi/stdlib.rbi:__LINE__
    class <constant:Escape> (<constant:BasicObject>) -> <Class:URI::Escape> @ rbi/stdlib.rbi:__LINE__
    class <constant:FTP> < ::<constant:URI>::<constant:Generic> () -> <Class:URI::FTP> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PORT> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ESCAPED> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FRAGMENT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HOST> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HTML5ASCIIINCOMPAT> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:OPAQUE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:PORT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:QUERY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REGISTRY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCHEME> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TYPECODE> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TYPECODE_PREFIX> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:UNSAFE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USERINFO> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USE_REGISTRY> -> FalseClass @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION_CODE> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    class <constant:Generic> < ::<constant:Object> (<constant:URI>, <constant:RFC2396_REGEXP>) -> <Class:URI::Generic> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PORT> -> NilClass @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ESCAPED> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FRAGMENT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HOST> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HTML5ASCIIINCOMPAT> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:OPAQUE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:PORT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:QUERY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REGISTRY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCHEME> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:UNSAFE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USERINFO> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USE_REGISTRY> -> FalseClass @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION_CODE> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    class <constant:HTTP> < ::<constant:URI>::<constant:Generic> () -> <Class:URI::HTTP> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PORT> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ESCAPED> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FRAGMENT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HOST> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HTML5ASCIIINCOMPAT> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:OPAQUE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:PORT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:QUERY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REGISTRY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCHEME> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:UNSAFE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USERINFO> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USE_REGISTRY> -> FalseClass @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION_CODE> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    class <constant:HTTPS> < ::<constant:URI>::<constant:HTTP> () -> <Class:URI::HTTPS> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PORT> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ESCAPED> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FRAGMENT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HOST> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HTML5ASCIIINCOMPAT> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:OPAQUE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:PORT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:QUERY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REGISTRY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCHEME> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:UNSAFE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USERINFO> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USE_REGISTRY> -> FalseClass @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION_CODE> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    class <constant:InvalidComponentError> < ::<constant:URI>::<constant:Error> () -> <Class:URI::InvalidComponentError> @ rbi/stdlib.rbi:__LINE__
    class <constant:InvalidURIError> < ::<constant:URI>::<constant:Error> () -> <Class:URI::InvalidURIError> @ rbi/stdlib.rbi:__LINE__
    class <constant:LDAP> < ::<constant:URI>::<constant:Generic> () -> <Class:URI::LDAP> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PORT> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ESCAPED> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FRAGMENT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HOST> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HTML5ASCIIINCOMPAT> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:OPAQUE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:PORT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:QUERY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REGISTRY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCHEME> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCOPE> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCOPE_BASE> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCOPE_ONE> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCOPE_SUB> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:UNSAFE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USERINFO> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USE_REGISTRY> -> FalseClass @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION_CODE> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    class <constant:LDAPS> < ::<constant:URI>::<constant:LDAP> () -> <Class:URI::LDAPS> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PORT> -> Integer @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ESCAPED> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FRAGMENT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HOST> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HTML5ASCIIINCOMPAT> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:OPAQUE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:PORT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:QUERY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REGISTRY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCHEME> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCOPE> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCOPE_BASE> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCOPE_ONE> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCOPE_SUB> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:UNSAFE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USERINFO> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USE_REGISTRY> -> FalseClass @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION_CODE> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    class <constant:MailTo> < ::<constant:URI>::<constant:Generic> () -> <Class:URI::MailTo> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ABS_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:DEFAULT_PORT> -> NilClass @ rbi/stdlib.rbi:__LINE__
      static-field <constant:EMAIL_REGEXP> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:ESCAPED> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:FRAGMENT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HEADER_REGEXP> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HOST> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:HTML5ASCIIINCOMPAT> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:OPAQUE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:PORT> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:QUERY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REGISTRY> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:REL_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser @ rbi/stdlib.rbi:__LINE__
      static-field <constant:SCHEME> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      static-field <constant:UNSAFE> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USERINFO> -> Regexp @ rbi/stdlib.rbi:__LINE__
      static-field <constant:USE_REGISTRY> -> FalseClass @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:VERSION_CODE> -> String @ rbi/stdlib.rbi:__LINE__
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    class <constant:RFC2396_Parser> < ::<constant:Object> (<constant:RFC2396_REGEXP>) -> <Class:URI::RFC2396_Parser> @ rbi/stdlib.rbi:__LINE__
    class <constant:RFC2396_REGEXP> (<constant:BasicObject>) -> <Class:URI::RFC2396_REGEXP> @ rbi/stdlib.rbi:__LINE__
      class <constant:PATTERN> (<constant:BasicObject>) -> <Class:URI::RFC2396_REGEXP::PATTERN> @ rbi/stdlib.rbi:__LINE__
        static-field <constant:ABS_PATH> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:ABS_URI> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:ALNUM> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:ALPHA> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:DOMLABEL> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:ESCAPED> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:FRAGMENT> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:HEX> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:HIER_PART> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:HOST> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:HOSTNAME> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:HOSTPORT> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:IPV4ADDR> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:IPV6ADDR> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:IPV6REF> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:NET_PATH> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:OPAQUE_PART> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:PATH_SEGMENTS> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:PORT> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:QUERY> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:REG_NAME> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:REL_PATH> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:REL_SEGMENT> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:REL_URI> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:RESERVED> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:SCHEME> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:TOPLABEL> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:UNRESERVED> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:URIC> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:URIC_NO_SLASH> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:URI_REF> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:USERINFO> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:X_ABS_URI> -> String @ rbi/stdlib.rbi:__LINE__
        static-field <constant:X_REL_URI> -> String @ rbi/stdlib.rbi:__LINE__
      class <singleton class:<constant:PATTERN>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    class <constant:RFC3986_Parser> < ::<constant:Object> () -> <Class:URI::RFC3986_Parser> @ rbi/stdlib.rbi:__LINE__
      static-field <constant:RFC3986_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
    class <constant:Util> (<constant:BasicObject>) -> <Class:URI::Util> @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:BadURIError>> < ::<constant:URI>::<singleton class:<constant:Error>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Error>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Escape>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:FTP>> < ::<constant:URI>::<singleton class:<constant:Generic>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Generic>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:HTTP>> < ::<constant:URI>::<singleton class:<constant:Generic>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:HTTPS>> < ::<constant:URI>::<singleton class:<constant:HTTP>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:InvalidComponentError>> < ::<constant:URI>::<singleton class:<constant:Error>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:InvalidURIError>> < ::<constant:URI>::<singleton class:<constant:Error>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:LDAP>> < ::<constant:URI>::<singleton class:<constant:Generic>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:LDAPS>> < ::<constant:URI>::<singleton class:<constant:LDAP>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:MailTo>> < ::<constant:URI>::<singleton class:<constant:Generic>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:RFC2396_Parser>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:RFC2396_REGEXP>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:RFC3986_Parser>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    class <singleton class:<constant:Util>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ABS_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ABS_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ABS_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser @ rbi/stdlib.rbi:__LINE__
    static-field <constant:ESCAPED> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:FRAGMENT> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:HOST> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:HTML5ASCIIINCOMPAT> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:OPAQUE> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:PORT> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:QUERY> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:REGISTRY> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:REL_PATH> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:REL_URI> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:REL_URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser @ rbi/stdlib.rbi:__LINE__
    static-field <constant:SCHEME> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    static-field <constant:UNSAFE> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:URI_REF> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:USERINFO> -> Regexp @ rbi/stdlib.rbi:__LINE__
    static-field <constant:VERSION> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:VERSION_CODE> -> String @ rbi/stdlib.rbi:__LINE__
    static-field <constant:WEB_ENCODINGS_> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
  class <constant:UnboundMethod> < ::<constant:Object> () -> <Class:UnboundMethod> @ rbi/stdlib.rbi:__LINE__
    method clone () -> UnboundMethod @ rbi/stdlib.rbi:__LINE__
    method dup () -> UnboundMethod @ rbi/stdlib.rbi:__LINE__
    method freeze () -> UnboundMethod @ rbi/stdlib.rbi:__LINE__
    method taint () -> UnboundMethod @ rbi/stdlib.rbi:__LINE__
    method trust () -> UnboundMethod @ rbi/stdlib.rbi:__LINE__
    method untaint () -> UnboundMethod @ rbi/stdlib.rbi:__LINE__
    method untrust () -> UnboundMethod @ rbi/stdlib.rbi:__LINE__
  class <constant:UncaughtThrowError> < ::<constant:ArgumentError> () -> <Class:UncaughtThrowError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> UncaughtThrowError @ rbi/stdlib.rbi:__LINE__
    method dup () -> UncaughtThrowError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> UncaughtThrowError @ rbi/stdlib.rbi:__LINE__
    method taint () -> UncaughtThrowError @ rbi/stdlib.rbi:__LINE__
    method trust () -> UncaughtThrowError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> UncaughtThrowError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> UncaughtThrowError @ rbi/stdlib.rbi:__LINE__
  class <constant:Warning> (<constant:BasicObject>) -> <Class:Warning> @ rbi/stdlib.rbi:__LINE__
  class <constant:ZeroDivisionError> < ::<constant:StandardError> () -> <Class:ZeroDivisionError> @ rbi/stdlib.rbi:__LINE__
    method clone () -> ZeroDivisionError @ rbi/stdlib.rbi:__LINE__
    method dup () -> ZeroDivisionError @ rbi/stdlib.rbi:__LINE__
    method freeze () -> ZeroDivisionError @ rbi/stdlib.rbi:__LINE__
    method taint () -> ZeroDivisionError @ rbi/stdlib.rbi:__LINE__
    method trust () -> ZeroDivisionError @ rbi/stdlib.rbi:__LINE__
    method untaint () -> ZeroDivisionError @ rbi/stdlib.rbi:__LINE__
    method untrust () -> ZeroDivisionError @ rbi/stdlib.rbi:__LINE__
  class <constant:nil> < ::<constant:Object> () -> NilClass @ ???
  class <constant:untyped> () -> untyped @ ???
  class <singleton class:<constant:<<JUNK>>>> < ::<constant:Module> () @ ???
  class <singleton class:<constant:<root>>> < ::<singleton class:<constant:Object>> () @ ???
  class <singleton class:<constant:<todo sym>>> < ::<constant:Module> () @ ???
  class <singleton class:<constant:Abbrev>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method abbrev (words) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = String
        <constant:V> = String
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument words<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:ArgumentError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Array>> < ::<singleton class:<constant:Object>> (<constant:Generic>) @ ???
    method [] (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Base64>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method decode64 (str) -> String @ rbi/stdlib.rbi:__LINE__
      argument str<> -> String @ rbi/stdlib.rbi:__LINE__
    method encode64 (bin) -> String @ rbi/stdlib.rbi:__LINE__
      argument bin<> -> String @ rbi/stdlib.rbi:__LINE__
    method strict_decode64 (str) -> String @ rbi/stdlib.rbi:__LINE__
      argument str<> -> String @ rbi/stdlib.rbi:__LINE__
    method strict_encode64 (bin) -> String @ rbi/stdlib.rbi:__LINE__
      argument bin<> -> String @ rbi/stdlib.rbi:__LINE__
    method urlsafe_decode64 (str) -> String @ rbi/stdlib.rbi:__LINE__
      argument str<> -> String @ rbi/stdlib.rbi:__LINE__
    method urlsafe_encode64 (bin) -> String @ rbi/stdlib.rbi:__LINE__
      argument bin<> -> String @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:BasicObject>> < ::<constant:Class> () @ ???
  class <singleton class:<constant:Benchmark>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method benchmark (caption, label_width, format, labels) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Benchmark::Tms
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument caption<> -> String @ rbi/stdlib.rbi:__LINE__
      argument format<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument label_width<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument labels<repeated> -> String @ rbi/stdlib.rbi:__LINE__
    method bm (label_width, labels, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Benchmark::Tms
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = NilClass
          <constant:Arg0> = Process
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument label_width<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument labels<repeated> -> String @ rbi/stdlib.rbi:__LINE__
    method bmbm (width, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Benchmark::Tms
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = NilClass
          <constant:Arg0> = Process
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument width<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method measure (label) -> Benchmark::Tms @ rbi/stdlib.rbi:__LINE__
      argument label<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method realtime (blk) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> BasicObject @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:BigDecimal>> < ::<singleton class:<constant:Numeric>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:BigMath>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method exp (arg0, arg1) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method log (arg0, arg1) -> BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg1<> -> Integer @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Binding>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:CSV>> < ::<singleton class:<constant:Object>> (<constant:Generic>) @ rbi/stdlib.rbi:__LINE__
    method foreach (path, options, blk) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument options<optional> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = Symbol
          <constant:V> = BasicObject
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument path<> -> AppliedType {
            klass = ::<constant:File>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Class>> < ::<singleton class:<constant:Module>> () @ ???
  class <singleton class:<constant:ClosedQueueError>> < ::<singleton class:<constant:StopIteration>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Comparable>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Complex>> < ::<singleton class:<constant:Numeric>> () @ ???
  class <singleton class:<constant:Coverage>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method result () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = String
        <constant:V> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = Integer | NilClass
            ]
          }
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method start () -> NilClass @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Data>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Date>> < ::<singleton class:<constant:Object>> () @ rbi/date.rbi:1
    method _httpdate (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/date.rbi:357
      argument arg0<> -> String @ rbi/date.rbi:356
    method _iso8601 (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/date.rbi:327
      argument arg0<> -> String @ rbi/date.rbi:326
    method _jisx0301 (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/date.rbi:363
      argument arg0<> -> String @ rbi/date.rbi:362
    method _load (arg0) -> untyped @ rbi/date.rbi:269
      argument arg0<> -> untyped @ rbi/date.rbi:268
    method _parse (arg0, comp) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/date.rbi:324
      argument arg0<> -> String @ rbi/date.rbi:320
      argument comp<optional> -> TrueClass | FalseClass @ rbi/date.rbi:321
    method _rfc2822 (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/date.rbi:345
      argument arg0<> -> String @ rbi/date.rbi:344
    method _rfc3339 (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/date.rbi:333
      argument arg0<> -> String @ rbi/date.rbi:332
    method _rfc822 (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/date.rbi:348
      argument arg0<> -> String @ rbi/date.rbi:347
    method _strptime (arg0) -> untyped @ rbi/date.rbi:314
      argument arg0<repeated> -> untyped @ rbi/date.rbi:313
    method _xmlschema (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/date.rbi:339
      argument arg0<> -> String @ rbi/date.rbi:338
    method civil (arg0) -> untyped @ rbi/date.rbi:308
      argument arg0<repeated> -> untyped @ rbi/date.rbi:307
    method commercial (arg0) -> untyped @ rbi/date.rbi:311
      argument arg0<repeated> -> untyped @ rbi/date.rbi:310
    method gregorian_leap? (arg0) -> untyped @ rbi/date.rbi:299
      argument arg0<> -> untyped @ rbi/date.rbi:298
    method httpdate (arg0) -> untyped @ rbi/date.rbi:360
      argument arg0<repeated> -> untyped @ rbi/date.rbi:359
    method iso8601 (arg0) -> untyped @ rbi/date.rbi:330
      argument arg0<repeated> -> untyped @ rbi/date.rbi:329
    method jd (arg0) -> untyped @ rbi/date.rbi:278
      argument arg0<repeated> -> untyped @ rbi/date.rbi:277
    method jisx0301 (arg0) -> untyped @ rbi/date.rbi:366
      argument arg0<repeated> -> untyped @ rbi/date.rbi:365
    method julian_leap? (arg0) -> untyped @ rbi/date.rbi:296
      argument arg0<> -> untyped @ rbi/date.rbi:295
    method leap? (arg0) -> untyped @ rbi/date.rbi:302
      argument arg0<> -> untyped @ rbi/date.rbi:301
    method new (arg0) -> untyped @ rbi/date.rbi:266
      argument arg0<repeated> -> untyped @ rbi/date.rbi:265
    method ordinal (arg0) -> untyped @ rbi/date.rbi:305
      argument arg0<repeated> -> untyped @ rbi/date.rbi:304
    method parse (arg0) -> untyped @ rbi/date.rbi:275
      argument arg0<repeated> -> untyped @ rbi/date.rbi:274
    method rfc2822 (arg0) -> untyped @ rbi/date.rbi:351
      argument arg0<repeated> -> untyped @ rbi/date.rbi:350
    method rfc3339 (arg0) -> untyped @ rbi/date.rbi:336
      argument arg0<repeated> -> untyped @ rbi/date.rbi:335
    method rfc822 (arg0) -> untyped @ rbi/date.rbi:354
      argument arg0<repeated> -> untyped @ rbi/date.rbi:353
    method strptime (arg0) -> untyped @ rbi/date.rbi:317
      argument arg0<repeated> -> untyped @ rbi/date.rbi:316
    method today (arg0) -> untyped @ rbi/date.rbi:272
      argument arg0<repeated> -> untyped @ rbi/date.rbi:271
    method valid_civil? (arg0) -> untyped @ rbi/date.rbi:287
      argument arg0<repeated> -> untyped @ rbi/date.rbi:286
    method valid_commercial? (arg0) -> untyped @ rbi/date.rbi:293
      argument arg0<repeated> -> untyped @ rbi/date.rbi:292
    method valid_date? (arg0) -> untyped @ rbi/date.rbi:290
      argument arg0<repeated> -> untyped @ rbi/date.rbi:289
    method valid_jd? (arg0) -> untyped @ rbi/date.rbi:281
      argument arg0<repeated> -> untyped @ rbi/date.rbi:280
    method valid_ordinal? (arg0) -> untyped @ rbi/date.rbi:284
      argument arg0<repeated> -> untyped @ rbi/date.rbi:283
    method xmlschema (arg0) -> untyped @ rbi/date.rbi:342
      argument arg0<repeated> -> untyped @ rbi/date.rbi:341
  class <singleton class:<constant:DateTime>> < ::<singleton class:<constant:Date>> () @ rbi/date.rbi:369
    method _strptime (arg0, format) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/date.rbi:466
      argument arg0<> -> String @ rbi/date.rbi:462
      argument format<optional> -> String @ rbi/date.rbi:463
    method civil (arg0) -> untyped @ rbi/date.rbi:456
      argument arg0<repeated> -> untyped @ rbi/date.rbi:455
    method commercial (arg0) -> untyped @ rbi/date.rbi:459
      argument arg0<repeated> -> untyped @ rbi/date.rbi:458
    method httpdate (arg0) -> untyped @ rbi/date.rbi:487
      argument arg0<repeated> -> untyped @ rbi/date.rbi:486
    method iso8601 (arg0) -> untyped @ rbi/date.rbi:472
      argument arg0<repeated> -> untyped @ rbi/date.rbi:471
    method jd (arg0) -> untyped @ rbi/date.rbi:450
      argument arg0<repeated> -> untyped @ rbi/date.rbi:449
    method jisx0301 (arg0) -> untyped @ rbi/date.rbi:490
      argument arg0<repeated> -> untyped @ rbi/date.rbi:489
    method new (arg0) -> untyped @ rbi/date.rbi:441
      argument arg0<repeated> -> untyped @ rbi/date.rbi:440
    method now (arg0) -> untyped @ rbi/date.rbi:444
      argument arg0<repeated> -> untyped @ rbi/date.rbi:443
    method ordinal (arg0) -> untyped @ rbi/date.rbi:453
      argument arg0<repeated> -> untyped @ rbi/date.rbi:452
    method parse (arg0) -> untyped @ rbi/date.rbi:447
      argument arg0<repeated> -> untyped @ rbi/date.rbi:446
    method rfc2822 (arg0) -> untyped @ rbi/date.rbi:481
      argument arg0<repeated> -> untyped @ rbi/date.rbi:480
    method rfc3339 (arg0) -> untyped @ rbi/date.rbi:475
      argument arg0<repeated> -> untyped @ rbi/date.rbi:474
    method rfc822 (arg0) -> untyped @ rbi/date.rbi:484
      argument arg0<repeated> -> untyped @ rbi/date.rbi:483
    method strptime (arg0) -> untyped @ rbi/date.rbi:469
      argument arg0<repeated> -> untyped @ rbi/date.rbi:468
    method xmlschema (arg0) -> untyped @ rbi/date.rbi:478
      argument arg0<repeated> -> untyped @ rbi/date.rbi:477
  class <singleton class:<constant:DidYouMean>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Dir>> < ::<singleton class:<constant:Object>> (<constant:Generic>) @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : []> (pattern, flags, blk) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument flags<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument pattern<> -> AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : chdir> (arg0, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String | Pathname @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : foreach> (dir, arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Encoding @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument dir<> -> String @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : glob> (pattern, flags, blk) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument flags<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument pattern<> -> AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : open> (arg0, arg1, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Encoding @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Dir>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method [] (pattern, flags) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument flags<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument pattern<> -> AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method chdir (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String | Pathname @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method chroot (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method delete (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method entries (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Encoding @ rbi/stdlib.rbi:__LINE__
    method exist? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method foreach (dir, arg0, blk) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Encoding @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument dir<> -> String @ rbi/stdlib.rbi:__LINE__
    method getwd () -> String @ rbi/stdlib.rbi:__LINE__
    method glob (pattern, flags) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument flags<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument pattern<> -> AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method home (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method mkdir (arg0, arg1) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method open (arg0, arg1) -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Encoding @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method pwd () -> String @ rbi/stdlib.rbi:__LINE__
    method rmdir (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method unlink (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:EOFError>> < ::<singleton class:<constant:IOError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Encoding>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : default_external=> (arg0) -> Encoding @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Encoding @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : default_internal=> (arg0) -> Encoding | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Encoding @ rbi/stdlib.rbi:__LINE__
    method aliases () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = String
        <constant:V> = String
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method compatible? (obj1, obj2) -> Encoding | NilClass @ rbi/stdlib.rbi:__LINE__
      argument obj1<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument obj2<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method default_external () -> Encoding @ rbi/stdlib.rbi:__LINE__
    method default_external= (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method default_internal () -> Encoding @ rbi/stdlib.rbi:__LINE__
    method default_internal= (arg0) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method find (arg0) -> Encoding @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String | Encoding @ rbi/stdlib.rbi:__LINE__
    method list () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Encoding
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method name_list () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:EncodingError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Enumerable>> < ::<constant:Module> (<constant:Generic>) @ ???
  class <singleton class:<constant:Enumerator>> < ::<singleton class:<constant:Object>> (<constant:Generic>) @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Errno>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Exception>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:FalseClass>> < ::<singleton class:<constant:Object>> () @ ???
  class <singleton class:<constant:Fiber>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:FiberError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:File>> < ::<singleton class:<constant:IO>> (<constant:Generic>) @ ???
    method <overload N.1 : binread> (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : open> (file, modearg, perm, opt, mode, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:File>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument file<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument modearg<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument opt<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument perm<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : binread> (arg0, arg1, arg2) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method absolute_path (file, dir) -> String @ rbi/stdlib.rbi:__LINE__
      argument dir<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method atime (file) -> Time @ rbi/stdlib.rbi:__LINE__
      argument file<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method basename (file, suffix) -> String @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
      argument suffix<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method binread (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method birthtime (file) -> Time @ rbi/stdlib.rbi:__LINE__
      argument file<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method blockdev? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method chardev? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method chmod (mode, files) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument files<repeated> -> String @ rbi/stdlib.rbi:__LINE__
      argument mode<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method chown (owner, group, files) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument files<repeated> -> String @ rbi/stdlib.rbi:__LINE__
      argument group<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument owner<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method ctime (file) -> Time @ rbi/stdlib.rbi:__LINE__
      argument file<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method delete (files) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument files<repeated> -> String @ rbi/stdlib.rbi:__LINE__
    method directory? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method dirname (file) -> String @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method executable? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method executable_real? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method exist? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method expand_path (file, dir) -> String @ rbi/stdlib.rbi:__LINE__
      argument dir<optional> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument file<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method extname (path) -> String @ rbi/stdlib.rbi:__LINE__
      argument path<> -> String @ rbi/stdlib.rbi:__LINE__
    method file? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method fnmatch (pattern, path, flags) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument flags<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument path<> -> String @ rbi/stdlib.rbi:__LINE__
      argument pattern<> -> String @ rbi/stdlib.rbi:__LINE__
    method fnmatch? (pattern, path, flags) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument flags<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument path<> -> String @ rbi/stdlib.rbi:__LINE__
      argument pattern<> -> String @ rbi/stdlib.rbi:__LINE__
    method ftype (file) -> String @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method grpowned? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method identical? (file_1, file_2) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file_1<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
      argument file_2<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method join (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method lchmod (mode, files) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument files<repeated> -> String @ rbi/stdlib.rbi:__LINE__
      argument mode<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method lchown (owner, group, files) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument files<repeated> -> String @ rbi/stdlib.rbi:__LINE__
      argument group<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument owner<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method link (old, new) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument new<> -> String @ rbi/stdlib.rbi:__LINE__
      argument old<> -> String @ rbi/stdlib.rbi:__LINE__
    method lstat (file) -> File::Stat @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method mtime (file) -> Time @ rbi/stdlib.rbi:__LINE__
      argument file<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method open (file, modearg, perm, opt, mode, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument file<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument modearg<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument opt<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument perm<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method owned? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method path (path) -> String @ rbi/stdlib.rbi:__LINE__
      argument path<> -> String @ rbi/stdlib.rbi:__LINE__
    method pipe? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method readable? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method readable_real? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method readlink (link) -> String @ rbi/stdlib.rbi:__LINE__
      argument link<> -> String @ rbi/stdlib.rbi:__LINE__
    method realdirpath (pathname, dir) -> String @ rbi/stdlib.rbi:__LINE__
      argument dir<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument pathname<> -> String @ rbi/stdlib.rbi:__LINE__
    method realpath (pathname, dir) -> String @ rbi/stdlib.rbi:__LINE__
      argument dir<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument pathname<> -> String @ rbi/stdlib.rbi:__LINE__
    method rename (old, new) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument new<> -> String @ rbi/stdlib.rbi:__LINE__
      argument old<> -> String @ rbi/stdlib.rbi:__LINE__
    method setgid? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method setuid? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method size (file) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method size? (file) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method socket? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method split (file) -> TupleType {
      0 = String
      1 = String
    } @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method stat (file) -> File::Stat @ rbi/stdlib.rbi:__LINE__
      argument file<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method sticky? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method symlink (old, new) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument new<> -> String @ rbi/stdlib.rbi:__LINE__
      argument old<> -> String @ rbi/stdlib.rbi:__LINE__
    method symlink? (file) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method truncate (file, arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method umask (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method unlink (files) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument files<repeated> -> String @ rbi/stdlib.rbi:__LINE__
    method utime (atime, mtime, files) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument atime<> -> Time @ rbi/stdlib.rbi:__LINE__
      argument files<repeated> -> String @ rbi/stdlib.rbi:__LINE__
      argument mtime<> -> Time @ rbi/stdlib.rbi:__LINE__
    method world_readable? (file) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method world_writable? (file) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
    method writable? (file) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method writable_real? (file) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> String @ rbi/stdlib.rbi:__LINE__
    method zero? (file) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:FileTest>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:FileUtils>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method cp_r (src, dest, preserve) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument dest<> -> String | Pathname @ rbi/stdlib.rbi:__LINE__
      argument preserve<optional> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = Symbol
          <constant:V> = TrueClass | FalseClass
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument src<> -> String | Pathname @ rbi/stdlib.rbi:__LINE__
    method mkdir_p (list, mode) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument list<> -> String | Pathname @ rbi/stdlib.rbi:__LINE__
      argument mode<optional> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = Symbol
          <constant:V> = TrueClass | FalseClass
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Float>> < ::<singleton class:<constant:Numeric>> () @ ???
  class <singleton class:<constant:FloatDomainError>> < ::<singleton class:<constant:RangeError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Forwardable>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:GC>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method count () -> Integer @ rbi/stdlib.rbi:__LINE__
    method disable () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method enable () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method start (full_mark, immediate_sweep) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument full_mark<optional, keyword> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument immediate_sweep<optional, keyword> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method stat (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = Symbol
        <constant:V> = Integer
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> AppliedType {
            klass = ::<constant:Hash>
            targs = [
              <constant:K> = untyped
              <constant:V> = untyped
              <constant:Elem> = untyped
            ]
          } | Symbol @ rbi/stdlib.rbi:__LINE__
    method stress () -> Integer | TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Gem>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method bin_path (name, args, requirements) -> String @ rbi/stdlib.rbi:__LINE__
      argument args<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument name<> -> String @ rbi/stdlib.rbi:__LINE__
      argument requirements<repeated> -> Gem::Requirement @ rbi/stdlib.rbi:__LINE__
    method binary_mode () -> String @ rbi/stdlib.rbi:__LINE__
    method bindir (install_dir) -> String @ rbi/stdlib.rbi:__LINE__
      argument install_dir<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method clear_default_specs () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method clear_paths () -> NilClass @ rbi/stdlib.rbi:__LINE__
    method config_file () -> String @ rbi/stdlib.rbi:__LINE__
    method configuration () -> Gem::ConfigFile @ rbi/stdlib.rbi:__LINE__
    method configuration= (config) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument config<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method datadir (gem_name) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument gem_name<> -> String @ rbi/stdlib.rbi:__LINE__
    method default_bindir () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method default_cert_path () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method default_dir () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method default_exec_format () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method default_key_path () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method default_path () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method default_rubygems_dirs () -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass @ rbi/stdlib.rbi:__LINE__
    method default_sources () -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Hash>> < ::<singleton class:<constant:Object>> (<constant:Generic>) @ ???
    method [] (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:IO>> < ::<singleton class:<constant:Object>> (<constant:Generic>) @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : foreach> (name, sep, limit, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument name<> -> String @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : open> (fd, modearg, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument fd<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument modearg<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : pipe> (int_enc, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> TupleType {
      0 = AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = String
            ]
          }
      1 = AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = String
            ]
          }
    } @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument ext_or_ext_int_enc<optional> @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument int_enc<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : pipe> (ext_or_ext_int_enc, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = TupleType {
              0 = AppliedType {
                    klass = ::<constant:IO>
                    targs = [
                      <constant:Elem> = String
                    ]
                  }
              1 = AppliedType {
                    klass = ::<constant:IO>
                    targs = [
                      <constant:Elem> = String
                    ]
                  }
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument ext_or_ext_int_enc<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument int_enc<optional> @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : pipe> (int_enc, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode, blk) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = TupleType {
              0 = AppliedType {
                    klass = ::<constant:IO>
                    targs = [
                      <constant:Elem> = String
                    ]
                  }
              1 = AppliedType {
                    klass = ::<constant:IO>
                    targs = [
                      <constant:Elem> = String
                    ]
                  }
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument ext_or_ext_int_enc<optional> @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument int_enc<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method binread (name, length, offset) -> String @ rbi/stdlib.rbi:__LINE__
      argument length<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument name<> -> String @ rbi/stdlib.rbi:__LINE__
      argument offset<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method binwrite (name, arg0, offset, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument name<> -> String @ rbi/stdlib.rbi:__LINE__
      argument offset<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method copy_stream (src, dst, copy_length, src_offset) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument copy_length<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument dst<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = String
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
      argument src<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = String
            ]
          } | String @ rbi/stdlib.rbi:__LINE__
      argument src_offset<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method for_fd (fd, mode, opt) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument fd<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument mode<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument opt<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method foreach (name, sep, limit, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode, blk) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument name<> -> String @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method open (fd, modearg, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument fd<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument modearg<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method pipe (ext_or_ext_int_enc, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> TupleType {
      0 = AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = String
            ]
          }
      1 = AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = String
            ]
          }
    } @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument ext_or_ext_int_enc<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument int_enc<optional> @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method read (name, length, offset, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> String @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument length<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument name<> -> String @ rbi/stdlib.rbi:__LINE__
      argument offset<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method readlines (name, sep, limit, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument name<> -> String @ rbi/stdlib.rbi:__LINE__
      argument sep<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method select (read_array, write_array, error_array, timeout) -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = AppliedType {
                klass = ::<constant:IO>
                targs = [
                  <constant:Elem> = String
                ]
              }
          ]
        } | NilClass @ rbi/stdlib.rbi:__LINE__
      argument error_array<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument read_array<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument timeout<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument write_array<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method sysopen (path, mode, perm) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument mode<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument path<> -> String @ rbi/stdlib.rbi:__LINE__
      argument perm<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method try_convert (arg0) -> AppliedType {
          klass = ::<constant:IO>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method write (name, arg0, offset, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument autoclose<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument binmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument external_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument internal_encoding<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument mode<optional, keyword> -> String @ rbi/stdlib.rbi:__LINE__
      argument name<> -> String @ rbi/stdlib.rbi:__LINE__
      argument offset<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument textmode<optional, keyword> -> BasicObject @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:IOError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:IndexError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Integer>> < ::<singleton class:<constant:Numeric>> () @ ???
  class <singleton class:<constant:Interrupt>> < ::<singleton class:<constant:SignalException>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Kernel>> < ::<constant:Module> () @ ???
    method <overload N.1 : Complex> (x) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument x<> -> String @ rbi/stdlib.rbi:__LINE__
      argument y<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : Rational> (x) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Object @ rbi/stdlib.rbi:__LINE__
      argument y<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : caller> () -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass @ rbi/stdlib.rbi:__LINE__
      argument length<optional> @ rbi/stdlib.rbi:__LINE__
      argument start<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : caller_locations> () -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass @ rbi/stdlib.rbi:__LINE__
      argument length<optional> @ rbi/stdlib.rbi:__LINE__
      argument start<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : exit> (status) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument status<optional> -> Integer | TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : fail> (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : raise> (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : fail> (arg0, arg1) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Class @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : raise> (arg0, arg1, arg2) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Class @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : fail> (arg0, arg1, arg2) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Class @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method <overload N.3 : raise> (arg0, arg1, arg2) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Exception @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method Array (x) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Object @ rbi/stdlib.rbi:__LINE__
    method Complex (x, y) -> Complex @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument y<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
    method Float (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Numeric @ rbi/stdlib.rbi:__LINE__
    method Hash (x) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Object @ rbi/stdlib.rbi:__LINE__
    method Integer (arg, base) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg<> -> Numeric | String @ rbi/stdlib.rbi:__LINE__
      argument base<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method Rational (x, y) -> Rational @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument y<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
    method String (x) -> String @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Object @ rbi/stdlib.rbi:__LINE__
    method __callee__ () -> Symbol | NilClass @ rbi/stdlib.rbi:__LINE__
    method __dir__ () -> String | NilClass @ rbi/stdlib.rbi:__LINE__
    method __method__ () -> Symbol | NilClass @ rbi/stdlib.rbi:__LINE__
    method ` (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method abort (msg) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument msg<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method at_exit (blk) -> Proc @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc0>
        targs = [
          <constant:Return> = BasicObject
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method autoload (_module, filename) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument _module<> -> String | Symbol @ rbi/stdlib.rbi:__LINE__
      argument filename<> -> String @ rbi/stdlib.rbi:__LINE__
    method autoload? (name) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument name<> -> Symbol | String @ rbi/stdlib.rbi:__LINE__
    method binding () -> Binding @ rbi/stdlib.rbi:__LINE__
    method block_given? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method caller (start, length) -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass @ rbi/stdlib.rbi:__LINE__
      argument length<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument start<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method caller_locations (start, length) -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass @ rbi/stdlib.rbi:__LINE__
      argument length<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument start<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method eval (arg0, arg1, filename, lineno) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Binding @ rbi/stdlib.rbi:__LINE__
      argument filename<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument lineno<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method exit () -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument status<optional> @ rbi/stdlib.rbi:__LINE__
    method exit! (status) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument status<> -> Integer | TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method fail () -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method format (format, args) -> String @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument format<> -> String @ rbi/stdlib.rbi:__LINE__
    method gets (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method global_variables () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method iterator? () -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
    method load (filename, arg0) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument filename<> -> String @ rbi/stdlib.rbi:__LINE__
    method local_variables () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method open (name, rest, block) -> AppliedType {
          klass = ::<constant:IO>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass @ rbi/stdlib.rbi:__LINE__
      argument block<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument name<> -> String @ rbi/stdlib.rbi:__LINE__
      argument rest<optional> -> String | Integer @ rbi/stdlib.rbi:__LINE__
    method printf (arg0, arg1, arg2) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> AppliedType {
        klass = ::<constant:IO>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg2<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method proc (blk) -> Proc @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method putc (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method puts (arg0) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method raise () -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method rand (max) -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument max<> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = untyped
            ]
          } | Integer @ rbi/stdlib.rbi:__LINE__
    method readline (arg0, arg1) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method readlines (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method require (name) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument name<> -> String @ rbi/stdlib.rbi:__LINE__
    method require_relative (name) -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
      argument name<> -> String @ rbi/stdlib.rbi:__LINE__
    method select (read, write, error, timeout) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument error<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument read<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument timeout<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument write<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method sleep (duration) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument duration<> -> Numeric @ rbi/stdlib.rbi:__LINE__
    method sprintf (format, args) -> String @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument format<> -> String @ rbi/stdlib.rbi:__LINE__
    method srand (number) -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument number<> -> Numeric @ rbi/stdlib.rbi:__LINE__
    method syscall (num, args) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument args<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument num<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method test (cmd, file1, file2) -> TrueClass | FalseClass | Time @ rbi/stdlib.rbi:__LINE__
      argument cmd<> -> String @ rbi/stdlib.rbi:__LINE__
      argument file1<> -> String @ rbi/stdlib.rbi:__LINE__
      argument file2<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method warn (msg) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument msg<repeated> -> String @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:KeyError>> < ::<singleton class:<constant:IndexError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:LoadError>> < ::<singleton class:<constant:ScriptError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:LocalJumpError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Marshal>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : dump> (arg0, arg1) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> @ rbi/stdlib.rbi:__LINE__
    method dump (arg0, arg1, arg2) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> AppliedType {
        klass = ::<constant:IO>
        targs = [
          <constant:Elem> = String
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument arg2<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method load (arg0, arg1) -> Object @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> Proc @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:MatchData>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Math>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method acos (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method acosh (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method asin (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method asinh (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method atan (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method atan2 (y, x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument y<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method atanh (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method cbrt (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method cos (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method cosh (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method erf (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method erfc (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method exp (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method frexp (x) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    } @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method gamma (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method hypot (x, y) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument y<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method ldexp (fraction, exponent) -> Float @ rbi/stdlib.rbi:__LINE__
      argument exponent<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument fraction<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method lgamma (x) -> Integer | Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method log (x, base) -> Float @ rbi/stdlib.rbi:__LINE__
      argument base<optional> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method log10 (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method log2 (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method sin (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method sinh (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method sqrt (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method tan (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
    method tanh (x) -> Float @ rbi/stdlib.rbi:__LINE__
      argument x<> -> Integer | Float | Rational | BigDecimal @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Method>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Module>> < ::<singleton class:<constant:Object>> () @ ???
    method constants () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method nesting () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Module
      ]
    } @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Monitor>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:MonitorMixin>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:NameError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:NilClass>> < ::<singleton class:<constant:Object>> () @ ???
  class <singleton class:<constant:NoMemoryError>> < ::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:NoMethodError>> < ::<singleton class:<constant:NameError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:NotImplementedError>> < ::<singleton class:<constant:ScriptError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Numeric>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Object>> < ::<singleton class:<constant:BasicObject>> () @ ???
  class <singleton class:<constant:ObjectSpace>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Opus>> < ::<constant:Module> () @ ???
  class <singleton class:<constant:Pathname>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    method getwd () -> Pathname @ rbi/stdlib.rbi:__LINE__
    method glob (p1, p2) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Pathname
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument p1<> -> String @ rbi/stdlib.rbi:__LINE__
      argument p2<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method pwd () -> Pathname @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Proc0>> < ::<singleton class:<constant:Proc>> () @ ???
  class <singleton class:<constant:Proc10>> < ::<singleton class:<constant:Proc>> () @ ???
  class <singleton class:<constant:Proc1>> < ::<singleton class:<constant:Proc>> () @ ???
  class <singleton class:<constant:Proc2>> < ::<singleton class:<constant:Proc>> () @ ???
  class <singleton class:<constant:Proc3>> < ::<singleton class:<constant:Proc>> () @ ???
  class <singleton class:<constant:Proc4>> < ::<singleton class:<constant:Proc>> () @ ???
  class <singleton class:<constant:Proc5>> < ::<singleton class:<constant:Proc>> () @ ???
  class <singleton class:<constant:Proc6>> < ::<singleton class:<constant:Proc>> () @ ???
  class <singleton class:<constant:Proc7>> < ::<singleton class:<constant:Proc>> () @ ???
  class <singleton class:<constant:Proc8>> < ::<singleton class:<constant:Proc>> () @ ???
  class <singleton class:<constant:Proc9>> < ::<singleton class:<constant:Proc>> () @ ???
  class <singleton class:<constant:Proc>> < ::<singleton class:<constant:Object>> () @ ???
  class <singleton class:<constant:Process>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : fork> (blk) -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc0>
        targs = [
          <constant:Return> = BasicObject
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method abort (msg) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument msg<optional> -> String @ rbi/stdlib.rbi:__LINE__
    method argv0 () -> String @ rbi/stdlib.rbi:__LINE__
    method clock_getres (clock_id, unit) -> Float | Integer @ rbi/stdlib.rbi:__LINE__
      argument clock_id<> -> Symbol | Integer @ rbi/stdlib.rbi:__LINE__
      argument unit<optional> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method clock_gettime (clock_id, unit) -> Float | Integer @ rbi/stdlib.rbi:__LINE__
      argument clock_id<> -> Symbol | Integer @ rbi/stdlib.rbi:__LINE__
      argument unit<optional> -> Symbol @ rbi/stdlib.rbi:__LINE__
    method daemon (nochdir, noclose) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument nochdir<optional> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument noclose<optional> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method detach (pid) -> Thread @ rbi/stdlib.rbi:__LINE__
      argument pid<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method egid () -> Integer @ rbi/stdlib.rbi:__LINE__
    method egid= (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method euid () -> Integer @ rbi/stdlib.rbi:__LINE__
    method euid= (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method exit (status) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument status<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method exit! (status) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument status<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method fork () -> Integer | NilClass @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
    method getpgid (pid) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument pid<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method getpgrp () -> Integer @ rbi/stdlib.rbi:__LINE__
    method getpriority (kind, arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument kind<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method getrlimit (resource) -> TupleType {
      0 = Integer
      1 = Integer
    } @ rbi/stdlib.rbi:__LINE__
      argument resource<> -> Symbol | String | Integer @ rbi/stdlib.rbi:__LINE__
    method getsid (pid) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument pid<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method gid () -> Integer @ rbi/stdlib.rbi:__LINE__
    method gid= (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method groups () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method groups= (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method initgroups (username, gid) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument gid<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument username<> -> String @ rbi/stdlib.rbi:__LINE__
    method kill (signal, pids) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument pids<repeated> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument signal<> -> Integer | Symbol | String @ rbi/stdlib.rbi:__LINE__
    method maxgroups () -> Integer @ rbi/stdlib.rbi:__LINE__
    method maxgroups= (arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method pid () -> Integer @ rbi/stdlib.rbi:__LINE__
    method ppid () -> Integer @ rbi/stdlib.rbi:__LINE__
    method setpgid (pid, arg0) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument pid<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method setpriority (kind, arg0, priority) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument kind<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument priority<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method setproctitle (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
    method setrlimit (resource, cur_limit, max_limit) -> NilClass @ rbi/stdlib.rbi:__LINE__
      argument cur_limit<> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument max_limit<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument resource<> -> Symbol | String | Integer @ rbi/stdlib.rbi:__LINE__
    method setsid () -> Integer @ rbi/stdlib.rbi:__LINE__
    method times () -> Process::Tms @ rbi/stdlib.rbi:__LINE__
    method uid () -> Integer @ rbi/stdlib.rbi:__LINE__
    method uid= (user) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument user<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method wait (pid, flags) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument flags<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument pid<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method wait2 (pid, flags) -> TupleType {
      0 = Integer
      1 = Integer
    } @ rbi/stdlib.rbi:__LINE__
      argument flags<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument pid<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method waitall () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = TupleType {
            0 = Integer
            1 = Integer
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method waitpid (pid, flags) -> Integer @ rbi/stdlib.rbi:__LINE__
      argument flags<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument pid<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method waitpid2 (pid, flags) -> TupleType {
      0 = Integer
      1 = Integer
    } @ rbi/stdlib.rbi:__LINE__
      argument flags<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument pid<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Random>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    method new_seed () -> Integer @ rbi/stdlib.rbi:__LINE__
    method rand (max) -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument max<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method srand (number) -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument number<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Range>> < ::<singleton class:<constant:Object>> (<constant:Generic>) @ ???
  class <singleton class:<constant:RangeError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Rational>> < ::<singleton class:<constant:Numeric>> () @ ???
  class <singleton class:<constant:RbConfig>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Regexp>> < ::<singleton class:<constant:Object>> () @ ???
    method <overload N.1 : compile> (arg0) -> Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Regexp @ rbi/stdlib.rbi:__LINE__
      argument kcode<optional> @ rbi/stdlib.rbi:__LINE__
      argument options<optional> @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : last_match> (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
    method compile (arg0, options, kcode) -> Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument kcode<optional> -> String @ rbi/stdlib.rbi:__LINE__
      argument options<optional> -> BasicObject @ rbi/stdlib.rbi:__LINE__
    method escape (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String | Symbol @ rbi/stdlib.rbi:__LINE__
    method last_match () -> MatchData @ rbi/stdlib.rbi:__LINE__
      argument arg0<optional> @ rbi/stdlib.rbi:__LINE__
    method quote (arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String | Symbol @ rbi/stdlib.rbi:__LINE__
    method try_convert (obj) -> Regexp | NilClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> BasicObject @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:RegexpError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:RubyTyper>> < ::<constant:Module> () @ ???
  class <singleton class:<constant:RubyVM>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:RuntimeError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:ScriptError>> < ::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:SecurityError>> < ::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Set>> < ::<singleton class:<constant:Object>> (<constant:Generic>) @ ???
    method [] (ary) -> untyped @ rbi/stdlib.rbi:__LINE__
      argument ary<repeated> -> BasicObject @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Signal>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : trap> (arg0, blk) -> String | Proc @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method list () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = String
        <constant:V> = Integer
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method signame (arg0) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method trap (arg0) -> String | Proc @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> Integer | String @ rbi/stdlib.rbi:__LINE__
      argument blk<block> @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:SignalException>> < ::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:SingleForwardable>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:SortedSet>> < ::<singleton class:<constant:Set>> (<constant:Generic>) @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:StandardError>> < ::<singleton class:<constant:Exception>> () @ ???
  class <singleton class:<constant:StopIteration>> < ::<singleton class:<constant:IndexError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:String>> < ::<singleton class:<constant:Object>> () @ ???
    method try_convert (obj) -> String | NilClass @ rbi/stdlib.rbi:__LINE__
      argument obj<> -> Object @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:StringIO>> < ::<singleton class:<constant:Data>> (<constant:Generic>) @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:StringScanner>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
    method new (arg0, arg1) -> StringScanner @ rbi/stdlib.rbi:__LINE__
      argument arg0<> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg1<optional> -> TrueClass | FalseClass @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Struct>> < ::<singleton class:<constant:Object>> (<constant:Generic>) @ ???
    method new (arg0, arg1) -> <Class:RubyTyper::DynamicStruct> @ rbi/ruby_typer.rbi:9
      argument arg0<> -> Symbol | String @ rbi/ruby_typer.rbi:5
      argument arg1<repeated> -> Symbol | String @ rbi/ruby_typer.rbi:6
  class <singleton class:<constant:Symbol>> < ::<singleton class:<constant:Object>> () @ ???
    method all_symbols () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    } @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:SyntaxError>> < ::<singleton class:<constant:ScriptError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:SystemCallError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:SystemExit>> < ::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:SystemStackError>> < ::<singleton class:<constant:Exception>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:T>> < ::<singleton class:<constant:Object>> () @ ???
  class <singleton class:<constant:Thread>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:ThreadError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:ThreadGroup>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Time>> < ::<singleton class:<constant:Object>> () @ rbi/date.rbi:493
    method <overload N.1 : at> () -> Time @ rbi/stdlib.rbi:__LINE__
      argument microseconds_with_frac<optional> @ rbi/stdlib.rbi:__LINE__
      argument seconds<> @ rbi/stdlib.rbi:__LINE__
    method <overload N.2 : at> (seconds, microseconds_with_frac) -> Time @ rbi/stdlib.rbi:__LINE__
      argument microseconds_with_frac<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument seconds<> -> Numeric @ rbi/stdlib.rbi:__LINE__
    method at (seconds) -> Time @ rbi/stdlib.rbi:__LINE__
      argument microseconds_with_frac<optional> @ rbi/stdlib.rbi:__LINE__
      argument seconds<> -> Time @ rbi/stdlib.rbi:__LINE__
    method gm (year, month, day, hour, min, sec, usec_with_frac) -> Time @ rbi/stdlib.rbi:__LINE__
      argument day<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument hour<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument min<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument month<optional> -> Integer | String @ rbi/stdlib.rbi:__LINE__
      argument sec<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument usec_with_frac<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument year<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method local (year, month, day, hour, min, sec, usec_with_frac) -> Time @ rbi/stdlib.rbi:__LINE__
      argument day<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument hour<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument min<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument month<optional> -> Integer | String @ rbi/stdlib.rbi:__LINE__
      argument sec<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument usec_with_frac<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument year<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method mktime (year, month, day, hour, min, sec, usec_with_frac) -> Time @ rbi/stdlib.rbi:__LINE__
      argument day<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument hour<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument min<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument month<optional> -> Integer | String @ rbi/stdlib.rbi:__LINE__
      argument sec<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument usec_with_frac<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument year<> -> Integer @ rbi/stdlib.rbi:__LINE__
    method now () -> Time @ rbi/stdlib.rbi:__LINE__
    method utc (year, month, day, hour, min, sec, usec_with_frac) -> Time @ rbi/stdlib.rbi:__LINE__
      argument day<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument hour<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument min<optional> -> Integer @ rbi/stdlib.rbi:__LINE__
      argument month<optional> -> Integer | String @ rbi/stdlib.rbi:__LINE__
      argument sec<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument usec_with_frac<optional> -> Numeric @ rbi/stdlib.rbi:__LINE__
      argument year<> -> Integer @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:TracePoint>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:TrueClass>> < ::<singleton class:<constant:Object>> () @ ???
  class <singleton class:<constant:TypeError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:URI>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : encode> (arg, arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg<> -> String @ rbi/stdlib.rbi:__LINE__
    method <overload N.1 : escape> (arg, arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> String @ rbi/stdlib.rbi:__LINE__
      argument arg<> -> String @ rbi/stdlib.rbi:__LINE__
    method decode (arg) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg<repeated> -> String @ rbi/stdlib.rbi:__LINE__
    method decode_www_form_component (str, enc) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = TupleType {
            0 = String
            1 = String
          }
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument enc<optional> -> Encoding @ rbi/stdlib.rbi:__LINE__
      argument str<> -> String @ rbi/stdlib.rbi:__LINE__
    method encode (arg, arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg<> -> String @ rbi/stdlib.rbi:__LINE__
    method escape (arg, arg0) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg0<repeated> -> Regexp @ rbi/stdlib.rbi:__LINE__
      argument arg<> -> String @ rbi/stdlib.rbi:__LINE__
    method extract (str, schemes, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument blk<block> -> BasicObject @ rbi/stdlib.rbi:__LINE__
      argument schemes<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
      argument str<> -> String @ rbi/stdlib.rbi:__LINE__
    method join (str) -> URI::HTTP @ rbi/stdlib.rbi:__LINE__
      argument str<repeated> -> String @ rbi/stdlib.rbi:__LINE__
    method parse (uri) -> URI::HTTP @ rbi/stdlib.rbi:__LINE__
      argument uri<> -> String @ rbi/stdlib.rbi:__LINE__
    method regexp (schemes) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument schemes<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      } @ rbi/stdlib.rbi:__LINE__
    method scheme_list () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = String
        <constant:V> = Class
        <constant:Elem> = untyped
      ]
    } @ rbi/stdlib.rbi:__LINE__
    method split (uri) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String | NilClass
      ]
    } @ rbi/stdlib.rbi:__LINE__
      argument uri<> -> String @ rbi/stdlib.rbi:__LINE__
    method unescape (arg) -> String @ rbi/stdlib.rbi:__LINE__
      argument arg<repeated> -> String @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:UnboundMethod>> < ::<singleton class:<constant:Object>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:UncaughtThrowError>> < ::<singleton class:<constant:ArgumentError>> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:Warning>> < ::<constant:Module> () @ rbi/stdlib.rbi:__LINE__
  class <singleton class:<constant:ZeroDivisionError>> < ::<singleton class:<constant:StandardError>> () @ rbi/stdlib.rbi:__LINE__
  method <static-init>$1 () @ bazel-out/host/genfiles/rbi/procs.rbi:1
  method <static-init>$3 () @ rbi/date.rbi:1
  method <static-init>$4 () @ rbi/ruby_typer.rbi:3
  method <static-init>$5 () @ rbi/stdlib.rbi:__LINE__
  method <static-init>$6 () @ rbi/t.rbi:1
  method <static-init>$7 () @ -e:1
  method <static-init>$8 () @ -e:1
  static-field <constant:M> -> AliasType { symbol = ::<constant:Opus>::<constant:DB>::<constant:Model> } @ ???

class <emptyTree><<constant:<root>>> < ()
  def self.<static-init><<static-init>$8>()
    1
  end
end
ClassDef{
  name = EmptyTree<<constant:<root>>>
  ancestors = []
  rhs = [
    MethodDef{
      self = 1
      name = <static-init><<static-init>$8>
      args = []
      rhs = IntLit{ value = 1 }
    }
  ]
}
digraph "-e"{
subgraph "cluster_#<static-init>$8" {
    label = "#<static-init>$8";
    color = blue;
    "bb#<static-init>$8_0" [shape = invhouse];
    "bb#<static-init>$8_1" [shape = parallelogram];

    "bb#<static-init>$8_0" [label = "block[id=0]()
<returnMethodTemp>$2 = 1 : Integer(1)
<finalReturn> = return <returnMethodTemp>$2 : <bottom>
<unconditional>"];

    "bb#<static-init>$8_0" -> "bb#<static-init>$8_1" [style="bold"];
    "bb#<static-init>$8_1" [label = "block[id=1]()
<unconditional>"];

    "bb#<static-init>$8_1" -> "bb#<static-init>$8_1" [style="bold"];
}

}

digraph "-e"{
subgraph "cluster_#<static-init>$8" {
    label = "#<static-init>$8";
    color = blue;
    "bb#<static-init>$8_0" [shape = invhouse];
    "bb#<static-init>$8_1" [shape = parallelogram];

    "bb#<static-init>$8_0" [label = "block[id=0]()
<returnMethodTemp>$2 = 1 : Integer(1)
<finalReturn> = return <returnMethodTemp>$2 : <bottom>
<returnMethodTemp>$2: Integer(1)

<finalReturn>: <bottom>

<unconditional>"];

    "bb#<static-init>$8_0" -> "bb#<static-init>$8_1" [style="bold"];
    "bb#<static-init>$8_1" [label = "block[id=1]()
<unconditional>"];

    "bb#<static-init>$8_1" -> "bb#<static-init>$8_1" [style="bold"];
}

}

1
# <returnMethodTemp>$2: Integer(1)
#
# <finalReturn>: <bottom>