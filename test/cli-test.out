Integer {
  val = "1"
}
{
  "type" : "Integer",
  "val" : "1"
}
class <emptyTree><<constant:<root>>> < ()
  1
end
ClassDef{
  name = EmptyTree<<constant:<root>>>
  ancestors = []
  rhs = [
    IntLit{ value = 1 }
  ]
}
class <emptyTree><<constant:<root>>> < ()
  1
end
ClassDef{
  name = EmptyTree<<constant:<root>>>
  ancestors = []
  rhs = [
    IntLit{ value = 1 }
  ]
}
class <constant:<root>> < ::<constant:Object> () -> <Class:<root>>
  method <static-init>$8 ()

class <constant:<root>> < ::<constant:Object> () -> <Class:<root>>
  class <constant:<<JUNK>>> () -> <Class:<<JUNK>>>
  class <constant:<<RESERVED>>0> < ::<constant:Object> ()
  class <constant:<<RESERVED>>10> < ::<constant:Object> ()
  class <constant:<<RESERVED>>11> < ::<constant:Object> ()
  class <constant:<<RESERVED>>12> < ::<constant:Object> ()
  class <constant:<<RESERVED>>13> < ::<constant:Object> ()
  class <constant:<<RESERVED>>14> < ::<constant:Object> ()
  class <constant:<<RESERVED>>15> < ::<constant:Object> ()
  class <constant:<<RESERVED>>16> < ::<constant:Object> ()
  class <constant:<<RESERVED>>17> < ::<constant:Object> ()
  class <constant:<<RESERVED>>18> < ::<constant:Object> ()
  class <constant:<<RESERVED>>19> < ::<constant:Object> ()
  class <constant:<<RESERVED>>1> < ::<constant:Object> ()
  class <constant:<<RESERVED>>20> < ::<constant:Object> ()
  class <constant:<<RESERVED>>21> < ::<constant:Object> ()
  class <constant:<<RESERVED>>22> < ::<constant:Object> ()
  class <constant:<<RESERVED>>23> < ::<constant:Object> ()
  class <constant:<<RESERVED>>24> < ::<constant:Object> ()
  class <constant:<<RESERVED>>25> < ::<constant:Object> ()
  class <constant:<<RESERVED>>26> < ::<constant:Object> ()
  class <constant:<<RESERVED>>27> < ::<constant:Object> ()
  class <constant:<<RESERVED>>28> < ::<constant:Object> ()
  class <constant:<<RESERVED>>29> < ::<constant:Object> ()
  class <constant:<<RESERVED>>2> < ::<constant:Object> ()
  class <constant:<<RESERVED>>30> < ::<constant:Object> ()
  class <constant:<<RESERVED>>31> < ::<constant:Object> ()
  class <constant:<<RESERVED>>32> < ::<constant:Object> ()
  class <constant:<<RESERVED>>33> < ::<constant:Object> ()
  class <constant:<<RESERVED>>34> < ::<constant:Object> ()
  class <constant:<<RESERVED>>35> < ::<constant:Object> ()
  class <constant:<<RESERVED>>36> < ::<constant:Object> ()
  class <constant:<<RESERVED>>37> < ::<constant:Object> ()
  class <constant:<<RESERVED>>38> < ::<constant:Object> ()
  class <constant:<<RESERVED>>39> < ::<constant:Object> ()
  class <constant:<<RESERVED>>3> < ::<constant:Object> ()
  class <constant:<<RESERVED>>40> < ::<constant:Object> ()
  class <constant:<<RESERVED>>41> < ::<constant:Object> ()
  class <constant:<<RESERVED>>42> < ::<constant:Object> ()
  class <constant:<<RESERVED>>43> < ::<constant:Object> ()
  class <constant:<<RESERVED>>44> < ::<constant:Object> ()
  class <constant:<<RESERVED>>45> < ::<constant:Object> ()
  class <constant:<<RESERVED>>46> < ::<constant:Object> ()
  class <constant:<<RESERVED>>47> < ::<constant:Object> ()
  class <constant:<<RESERVED>>48> < ::<constant:Object> ()
  class <constant:<<RESERVED>>49> < ::<constant:Object> ()
  class <constant:<<RESERVED>>4> < ::<constant:Object> ()
  class <constant:<<RESERVED>>50> < ::<constant:Object> ()
  class <constant:<<RESERVED>>51> < ::<constant:Object> ()
  class <constant:<<RESERVED>>52> < ::<constant:Object> ()
  class <constant:<<RESERVED>>53> < ::<constant:Object> ()
  class <constant:<<RESERVED>>54> < ::<constant:Object> ()
  class <constant:<<RESERVED>>55> < ::<constant:Object> ()
  class <constant:<<RESERVED>>56> < ::<constant:Object> ()
  class <constant:<<RESERVED>>57> < ::<constant:Object> ()
  class <constant:<<RESERVED>>58> < ::<constant:Object> ()
  class <constant:<<RESERVED>>59> < ::<constant:Object> ()
  class <constant:<<RESERVED>>5> < ::<constant:Object> ()
  class <constant:<<RESERVED>>60> < ::<constant:Object> ()
  class <constant:<<RESERVED>>61> < ::<constant:Object> ()
  class <constant:<<RESERVED>>62> < ::<constant:Object> ()
  class <constant:<<RESERVED>>63> < ::<constant:Object> ()
  class <constant:<<RESERVED>>64> < ::<constant:Object> ()
  class <constant:<<RESERVED>>65> < ::<constant:Object> ()
  class <constant:<<RESERVED>>66> < ::<constant:Object> ()
  class <constant:<<RESERVED>>67> < ::<constant:Object> ()
  class <constant:<<RESERVED>>68> < ::<constant:Object> ()
  class <constant:<<RESERVED>>69> < ::<constant:Object> ()
  class <constant:<<RESERVED>>6> < ::<constant:Object> ()
  class <constant:<<RESERVED>>70> < ::<constant:Object> ()
  class <constant:<<RESERVED>>71> < ::<constant:Object> ()
  class <constant:<<RESERVED>>72> < ::<constant:Object> ()
  class <constant:<<RESERVED>>73> < ::<constant:Object> ()
  class <constant:<<RESERVED>>74> < ::<constant:Object> ()
  class <constant:<<RESERVED>>75> < ::<constant:Object> ()
  class <constant:<<RESERVED>>76> < ::<constant:Object> ()
  class <constant:<<RESERVED>>77> < ::<constant:Object> ()
  class <constant:<<RESERVED>>78> < ::<constant:Object> ()
  class <constant:<<RESERVED>>79> < ::<constant:Object> ()
  class <constant:<<RESERVED>>7> < ::<constant:Object> ()
  class <constant:<<RESERVED>>80> < ::<constant:Object> ()
  class <constant:<<RESERVED>>81> < ::<constant:Object> ()
  class <constant:<<RESERVED>>82> < ::<constant:Object> ()
  class <constant:<<RESERVED>>83> < ::<constant:Object> ()
  class <constant:<<RESERVED>>84> < ::<constant:Object> ()
  class <constant:<<RESERVED>>85> < ::<constant:Object> ()
  class <constant:<<RESERVED>>86> < ::<constant:Object> ()
  class <constant:<<RESERVED>>87> < ::<constant:Object> ()
  class <constant:<<RESERVED>>88> < ::<constant:Object> ()
  class <constant:<<RESERVED>>89> < ::<constant:Object> ()
  class <constant:<<RESERVED>>8> < ::<constant:Object> ()
  class <constant:<<RESERVED>>90> < ::<constant:Object> ()
  class <constant:<<RESERVED>>91> < ::<constant:Object> ()
  class <constant:<<RESERVED>>92> < ::<constant:Object> ()
  class <constant:<<RESERVED>>93> < ::<constant:Object> ()
  class <constant:<<RESERVED>>94> < ::<constant:Object> ()
  class <constant:<<RESERVED>>95> < ::<constant:Object> ()
  class <constant:<<RESERVED>>96> < ::<constant:Object> ()
  class <constant:<<RESERVED>>97> < ::<constant:Object> ()
  class <constant:<<RESERVED>>9> < ::<constant:Object> ()
  class <constant:<Magic>> < ::<constant:Object> () -> <Magic>
    method <build-array> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument arg0<repeated> -> Object
    method <build-hash> (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument arg0<repeated> -> Object
    method <splat> (arg0) -> untyped
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
  class <constant:<bottom>> ()
  class <constant:<none>> ()
  class <constant:<todo sym>> () -> <Class:<todo sym>>
  class <constant:<top>> ()
  class <constant:Abbrev> (<constant:BasicObject>) -> <Class:Abbrev>
  class <constant:ArgumentError> < ::<constant:StandardError> () -> <Class:ArgumentError>
    method clone () -> ArgumentError
    method dup () -> ArgumentError
    method freeze () -> ArgumentError
    method taint () -> ArgumentError
    method trust () -> ArgumentError
    method untaint () -> ArgumentError
    method untrust () -> ArgumentError
  class <constant:Array>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Array>
    method & (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method * (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
    method + (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method - (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method << (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> LambdaParam(::<constant:Array>#<constant:Elem>)
    method <overload N.1 : *> (arg0) -> String
      argument arg0<> -> String
    method <overload N.1 : +> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method <overload N.1 : []=> (arg0, arg1, arg2) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<> -> Integer
      argument arg1<> -> Integer
      argument arg2<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>)
    method <overload N.1 : []> (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<> -> Integer | Float
      argument arg1<optional>
    method <overload N.1 : collect> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : combination> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
      argument blk<block>
    method <overload N.1 : count> (arg0) -> Integer
      argument arg0<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument blk<block>
    method <overload N.1 : cycle> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
      argument blk<block>
    method <overload N.1 : delete> (blk) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc0>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method <overload N.1 : delete_if> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : drop_while> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : each> (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method <overload N.1 : each_index> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : fetch> (arg0, arg1) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<> -> Integer
      argument arg1<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument blk<block>
    method <overload N.1 : fill> (arg0, arg1, arg2) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg1<optional> -> Integer
      argument arg2<optional> -> Integer
      argument blk<block>
    method <overload N.1 : first> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
    method <overload N.1 : index> (blk) -> Integer
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method <overload N.1 : initialize> (arg0) -> Object
      argument arg0<optional> -> Integer
      argument arg1<optional>
    method <overload N.1 : last> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
    method <overload N.1 : map!> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : map> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : permutation> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
              ]
            }
        ]
      }
    method <overload N.1 : pop> () -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<optional>
    method <overload N.1 : reject!> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : reject> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : repeated_combination> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
      argument blk<block>
    method <overload N.1 : repeated_permutation> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
      argument blk<block>
    method <overload N.1 : reverse_each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : rindex> (blk) -> Integer
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method <overload N.1 : sample> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
    method <overload N.1 : select!> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : select> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : shift> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
    method <overload N.1 : slice!> (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
      argument arg1<optional> -> Integer
    method <overload N.1 : slice> (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<> -> Integer | Float
      argument arg1<optional>
    method <overload N.1 : sort!> (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method <overload N.1 : sort> (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method <overload N.1 : sort_by!> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : take_while> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.2 : []=> (arg0, arg1) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      }
      argument arg1<> -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg2<optional>
    method <overload N.2 : []> (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
      argument arg1<optional> -> Integer
    method <overload N.2 : count> (blk) -> Integer
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method <overload N.2 : fetch> (arg0, blk) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<> -> Integer
      argument arg1<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Array>#<constant:Elem>)
          <constant:Arg0> = Integer
        ]
      }
    method <overload N.2 : fill> (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg1<optional> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      }
      argument arg2<optional>
      argument blk<block>
    method <overload N.2 : index> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional>
      argument blk<block>
    method <overload N.2 : initialize> (arg0, arg1) -> Object
      argument arg0<optional> -> Integer
      argument arg1<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>)
    method <overload N.2 : rindex> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional>
      argument blk<block>
    method <overload N.2 : slice!> (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<> -> Integer | Float
      argument arg1<optional>
    method <overload N.2 : slice> (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
      argument arg1<optional> -> Integer
    method <overload N.3 : fill> (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional>
      argument arg1<optional>
      argument arg2<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Array>#<constant:Elem>)
          <constant:Arg0> = Integer
        ]
      }
    method <overload N.4 : fill> (arg0, arg1, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
      argument arg1<optional> -> Integer
      argument arg2<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Array>#<constant:Elem>)
          <constant:Arg0> = Integer
        ]
      }
    method <overload N.5 : fill> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      }
      argument arg1<optional>
      argument arg2<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Array>#<constant:Elem>)
          <constant:Arg0> = Integer
        ]
      }
    method [] (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      }
      argument arg1<optional>
    method []= (arg0, arg1) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<> -> Integer
      argument arg1<> -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg2<optional>
    method assoc (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> LambdaParam(::<constant:Array>#<constant:Elem>)
    method at (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<> -> Integer
    method clear () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
    method clone () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method collect (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method combination (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
              ]
            }
        ]
      }
    method compact () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
    method compact! () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
    method concat (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method count () -> Integer
      argument arg0<optional>
      argument blk<block>
    method cycle (arg0, blk) -> untyped
      argument arg0<optional> -> Integer
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method delete (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument blk<block>
    method delete_at (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
    method delete_if (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method drop (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
    method drop_while (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method dup () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method each () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method each_index (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method empty? () -> TrueClass | FalseClass
    method fetch (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<> -> Integer
      argument arg1<optional>
      argument blk<block>
    method fill (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg1<optional>
      argument arg2<optional>
      argument blk<block>
    method first () -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<optional>
    method flatten () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method freeze () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method include? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method index (arg0) -> Integer
      argument arg0<optional> -> BasicObject
      argument blk<block>
    method initialize () -> Object
      argument arg0<optional>
      argument arg1<optional>
    method insert (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
      argument arg1<repeated> -> LambdaParam(::<constant:Array>#<constant:Elem>)
    method inspect () -> String
    method join (arg0) -> String
      argument arg0<optional> -> String
    method keep_if (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method last () -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<optional>
    method length () -> Integer
    method map (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method map! (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method member? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> LambdaParam(::<constant:Array>#<constant:Elem>)
    method permutation (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
      argument blk<block>
    method pop (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
    method product (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = untyped
            ]
          }
      ]
    }
      argument arg0<repeated> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = BasicObject
        ]
      }
    method push (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<repeated> -> LambdaParam(::<constant:Array>#<constant:Elem>)
    method rassoc (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<> -> BasicObject
    method reject (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method reject! (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method repeated_combination (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
              ]
            }
        ]
      }
    method repeated_permutation (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
              ]
            }
        ]
      }
    method reverse () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
    method reverse! () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
    method reverse_each (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method rindex (arg0) -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<optional> -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument blk<block>
    method rotate (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
    method rotate! (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
    method sample () -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<optional>
    method select (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method select! (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method shift () -> LambdaParam(::<constant:Array>#<constant:Elem>)
      argument arg0<optional>
    method shuffle () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
    method shuffle! () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
    method size () -> Integer
    method slice (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      }
      argument arg1<optional>
    method slice! (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      }
      argument arg1<optional>
    method sort () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method sort! () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method sort_by! (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method taint () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method take (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> Integer
    method take_while (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    method to_a () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
    method to_ary () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
    method to_s () -> String
    method transpose () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
    method trust () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method uniq () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
    method uniq! () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
    method unshift (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<repeated> -> LambdaParam(::<constant:Array>#<constant:Elem>)
    method untaint () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method untrust () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method values_at (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<repeated> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = Integer
            ]
          } | Integer
    method zip (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = untyped
            ]
          }
      ]
    }
      argument arg0<repeated> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = BasicObject
        ]
      }
    method | (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
      ]
    }
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Array>#<constant:Elem>)
        ]
      }
    typeMember(=) <constant:Elem>
  class <constant:Base64> (<constant:BasicObject>) -> <Class:Base64>
  class <constant:BasicObject> () -> <Class:BasicObject>
    method ! () -> TrueClass | FalseClass
    method != (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method <overload N.1 : instance_eval> (blk) -> untyped
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc0>
        targs = [
          <constant:Return> = BasicObject
        ]
      }
      argument filename<optional>
      argument lineno<optional>
    method == (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method __id__ () -> Integer
    method __send__ (arg0, arg1) -> untyped
      argument arg0<> -> Symbol
      argument arg1<repeated> -> BasicObject
    method equal? (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method instance_eval (arg0, filename, lineno) -> untyped
      argument arg0<optional> -> String
      argument blk<block>
      argument filename<optional> -> String
      argument lineno<optional> -> Integer
    method instance_exec (args, blk) -> untyped
      argument args<repeated> -> BasicObject
      argument blk<block> -> BasicObject
  class <constant:Benchmark> (<constant:BasicObject>) -> <Class:Benchmark>
    class <constant:Job> < ::<constant:Object> () -> <Class:Benchmark::Job>
    class <constant:Report> < ::<constant:Object> () -> <Class:Benchmark::Report>
    class <constant:Tms> < ::<constant:Object> () -> <Class:Benchmark::Tms>
      static-field <constant:CAPTION> -> String
      static-field <constant:FORMAT> -> String
    class <singleton class:<constant:Job>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:Report>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:Tms>> < ::<singleton class:<constant:Object>> ()
    static-field <constant:BENCHMARK_VERSION> -> String
    static-field <constant:CAPTION> -> String
    static-field <constant:FORMAT> -> String
  class <constant:BigDecimal> < ::<constant:Numeric> () -> <Class:BigDecimal>
    method % (arg0) -> BigDecimal
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method * (arg0) -> BigDecimal
      argument arg0<> -> Integer
    method ** (arg0) -> BigDecimal
      argument arg0<> -> Integer
    method + (arg0) -> BigDecimal
      argument arg0<> -> Integer
    method +@ () -> BigDecimal
    method - (arg0) -> BigDecimal
      argument arg0<> -> Integer
    method -@ () -> BigDecimal
    method / (arg0) -> BigDecimal
      argument arg0<> -> Integer
    method < (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method <= (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method <=> (arg0) -> Object
      argument arg0<> -> Integer
    method <overload N.1 : **> (arg0) -> BigDecimal
      argument arg0<> -> Float
    method <overload N.1 : *> (arg0) -> BigDecimal
      argument arg0<> -> Float
    method <overload N.1 : +> (arg0) -> BigDecimal
      argument arg0<> -> Float
    method <overload N.1 : -> (arg0) -> BigDecimal
      argument arg0<> -> Float
    method <overload N.1 : /> (arg0) -> BigDecimal
      argument arg0<> -> Float
    method <overload N.1 : <=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : <=>> (arg0) -> Object
      argument arg0<> -> Float
    method <overload N.1 : <> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : >=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : >> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : div> (arg0) -> Integer
      argument arg0<> -> Float
    method <overload N.1 : fdiv> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : power> (arg0) -> BigDecimal
      argument arg0<> -> Float
    method <overload N.1 : quo> (arg0) -> BigDecimal
      argument arg0<> -> Float
    method <overload N.1 : round> (arg0) -> BigDecimal
      argument arg0<optional> -> Integer
    method <overload N.1 : truncate> (arg0) -> Rational
      argument arg0<optional> -> Integer
    method <overload N.2 : **> (arg0) -> BigDecimal
      argument arg0<> -> Rational
    method <overload N.2 : *> (arg0) -> BigDecimal
      argument arg0<> -> Rational
    method <overload N.2 : +> (arg0) -> BigDecimal
      argument arg0<> -> Rational
    method <overload N.2 : -> (arg0) -> BigDecimal
      argument arg0<> -> Rational
    method <overload N.2 : /> (arg0) -> BigDecimal
      argument arg0<> -> Rational
    method <overload N.2 : <=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : <=>> (arg0) -> Object
      argument arg0<> -> Rational
    method <overload N.2 : <> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : >=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : >> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : div> (arg0) -> Integer
      argument arg0<> -> Rational
    method <overload N.2 : fdiv> (arg0) -> Float
      argument arg0<> -> Rational
    method <overload N.2 : power> (arg0) -> BigDecimal
      argument arg0<> -> Rational
    method <overload N.2 : quo> (arg0) -> BigDecimal
      argument arg0<> -> Rational
    method <overload N.3 : **> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : *> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : +> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : -> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : /> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : <=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : <=>> (arg0) -> Object
      argument arg0<> -> BigDecimal
    method <overload N.3 : <> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : >=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : >> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : div> (arg0) -> Integer
      argument arg0<> -> BigDecimal
    method <overload N.3 : fdiv> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : power> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : quo> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.4 : *> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : +> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : -> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : /> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : fdiv> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : quo> (arg0) -> Complex
      argument arg0<> -> Complex
    method == (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method === (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method > (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method >= (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method _dump () -> String
    method abs () -> BigDecimal
    method abs2 () -> BigDecimal
    method add (arg0, arg1) -> BigDecimal
      argument arg0<> -> Integer | Float | Rational | BigDecimal
      argument arg1<> -> Integer
    method angle () -> Integer | Float | Rational | BigDecimal | Complex
    method arg () -> Integer | Float | Rational | BigDecimal | Complex
    method ceil () -> Integer
    method clone () -> BigDecimal
    method coerce (arg0) -> TupleType {
      0 = BigDecimal
      1 = BigDecimal
    }
      argument arg0<> -> Integer | Float | Rational | BigDecimal
    method conj () -> BigDecimal
    method conjugate () -> BigDecimal
    method denominator () -> Integer
    method div (arg0) -> Integer
      argument arg0<> -> Integer
    method divmod (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    }
      argument arg0<> -> Integer | Float | Rational | BigDecimal
    method dup () -> BigDecimal
    method eql? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method equal? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method exponent () -> Integer
    method fdiv (arg0) -> Float
      argument arg0<> -> Integer
    method finite? () -> TrueClass | FalseClass
    method fix () -> BigDecimal
    method floor () -> Integer
    method frac () -> BigDecimal
    method freeze () -> BigDecimal
    method hash () -> Integer
    method imag () -> Integer
    method imaginary () -> Integer
    method infinite? () -> NilClass | Integer
    method inspect () -> String
    method magnitude () -> BigDecimal
    method modulo (arg0) -> BigDecimal
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method mult (arg0, arg1) -> BigDecimal
      argument arg0<> -> Integer | Float | Rational | BigDecimal
      argument arg1<> -> Integer
    method nan? () -> TrueClass | FalseClass
    method nonzero? () -> Object
    method numerator () -> Integer
    method phase () -> Integer | Float | Rational | BigDecimal | Complex
    method power (arg0) -> BigDecimal
      argument arg0<> -> Integer
    method precs () -> TupleType {
      0 = Integer
      1 = Integer
    }
    method quo (arg0) -> BigDecimal
      argument arg0<> -> Integer
    method real () -> BigDecimal
    method real? () -> TrueClass
    method remainder (arg0) -> BigDecimal
      argument arg0<> -> Integer | Float | Rational | BigDecimal
    method round () -> Integer
      argument arg0<optional>
    method sign () -> Integer
    method split () -> TupleType {
      0 = Integer
      1 = String
      2 = Integer
      3 = Integer
    }
    method sqrt (arg0) -> BigDecimal
      argument arg0<> -> Integer
    method sub (arg0, arg1) -> BigDecimal
      argument arg0<> -> Integer | Float | Rational | BigDecimal
      argument arg1<> -> Integer
    method taint () -> BigDecimal
    method to_c () -> Complex
    method to_f () -> Float
    method to_i () -> Integer
    method to_int () -> Integer
    method to_r () -> Rational
    method to_s () -> String
    method truncate () -> Integer
      argument arg0<optional>
    method trust () -> BigDecimal
    method untaint () -> BigDecimal
    method untrust () -> BigDecimal
    method zero? () -> TrueClass | FalseClass
    static-field <constant:BASE> -> Integer
    static-field <constant:EXCEPTION_ALL> -> Integer
    static-field <constant:EXCEPTION_INFINITY> -> Integer
    static-field <constant:EXCEPTION_OVERFLOW> -> Integer
    static-field <constant:EXCEPTION_UNDERFLOW> -> Integer
    static-field <constant:EXCEPTION_ZERODIVIDE> -> Integer
    static-field <constant:INFINITY> -> BigDecimal
    static-field <constant:NAN> -> BigDecimal
    static-field <constant:ROUND_CEILING> -> Integer
    static-field <constant:ROUND_DOWN> -> Integer
    static-field <constant:ROUND_FLOOR> -> Integer
    static-field <constant:ROUND_HALF_DOWN> -> Integer
    static-field <constant:ROUND_HALF_EVEN> -> Integer
    static-field <constant:ROUND_HALF_UP> -> Integer
    static-field <constant:ROUND_MODE> -> Integer
    static-field <constant:ROUND_UP> -> Integer
    static-field <constant:SIGN_NEGATIVE_FINITE> -> Integer
    static-field <constant:SIGN_NEGATIVE_INFINITE> -> Integer
    static-field <constant:SIGN_NEGATIVE_ZERO> -> Integer
    static-field <constant:SIGN_POSITIVE_FINITE> -> Integer
    static-field <constant:SIGN_POSITIVE_INFINITE> -> Integer
    static-field <constant:SIGN_POSITIVE_ZERO> -> Integer
  class <constant:BigMath> (<constant:BasicObject>) -> <Class:BigMath>
    method E (prec) -> BigDecimal
      argument prec<> -> Integer
    method PI (prec) -> BigDecimal
      argument prec<> -> Integer
    method atan (x, prec) -> BigDecimal
      argument prec<> -> Integer
      argument x<> -> Integer
    method cos (x, prec) -> BigDecimal
      argument prec<> -> Integer
      argument x<> -> Integer
    method sin (x, prec) -> BigDecimal
      argument prec<> -> Integer
      argument x<> -> Integer
    method sqrt (x, prec) -> BigDecimal
      argument prec<> -> Integer
      argument x<> -> Integer
  class <constant:Binding> < ::<constant:Object> () -> <Class:Binding>
    method clone () -> Binding
    method dup () -> Binding
    method freeze () -> Binding
    method taint () -> Binding
    method trust () -> Binding
    method untaint () -> Binding
    method untrust () -> Binding
  class <constant:CSV>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:CSV>
    class <constant:FieldInfo>[<constant:Elem>] < ::<constant:Struct> () -> <Class:CSV::FieldInfo>
      typeMember(=) <constant:Elem>
    class <constant:MalformedCSVError> < ::<constant:RuntimeError> () -> <Class:CSV::MalformedCSVError>
    class <constant:Row>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:CSV::Row>
      typeMember(=) <constant:Elem>
    class <constant:Table>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:CSV::Table>
      typeMember(=) <constant:Elem>
    class <singleton class:<constant:FieldInfo>> < ::<singleton class:<constant:Struct>> ()
    class <singleton class:<constant:MalformedCSVError>> < ::<singleton class:<constant:RuntimeError>> ()
    class <singleton class:<constant:Row>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:Table>> < ::<singleton class:<constant:Object>> ()
    method clone () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    }
    method dup () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    }
    method freeze () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    }
    method taint () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    }
    method trust () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    }
    method untaint () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    }
    method untrust () -> AppliedType {
      klass = ::<constant:CSV>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          }
      ]
    }
    static-field <constant:DEFAULT_OPTIONS> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:VERSION> -> String
    typeMember(=) <constant:Elem> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
  class <constant:Class> < ::<constant:Module> () -> <Class:Class>
    method <overload N.1 : superclass> () -> Class
    method allocate () -> untyped
    method clone () -> Class
    method dup () -> Class
    method freeze () -> Class
    method include (arg0) -> Class
      argument arg0<repeated> -> Module
    method inherited (arg0) -> untyped
      argument arg0<> -> Class
    method instance_methods (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
      argument arg0<optional> -> TrueClass | FalseClass
    method name () -> String
    method prepend (arg0) -> Class
      argument arg0<repeated> -> Module
    method private_class_method (arg0) -> Class
      argument arg0<repeated> -> Symbol | String
    method private_constant (arg0) -> Class
      argument arg0<repeated> -> Symbol
    method public_class_method (arg0) -> Class
      argument arg0<repeated> -> Symbol | String
    method public_constant (arg0) -> Class
      argument arg0<repeated> -> Symbol
    method superclass () -> Class | NilClass
    method taint () -> Class
    method trust () -> Class
    method untaint () -> Class
    method untrust () -> Class
  class <constant:ClosedQueueError> < ::<constant:StopIteration> () -> <Class:ClosedQueueError>
    method clone () -> ClosedQueueError
    method dup () -> ClosedQueueError
    method freeze () -> ClosedQueueError
    method taint () -> ClosedQueueError
    method trust () -> ClosedQueueError
    method untaint () -> ClosedQueueError
    method untrust () -> ClosedQueueError
  class <constant:Comparable> (<constant:BasicObject>) -> <Class:Comparable>
  class <constant:Complex> < ::<constant:Numeric> () -> <Class:Complex>
    method * (arg0) -> Complex
      argument arg0<> -> Integer
    method ** (arg0) -> Complex
      argument arg0<> -> Integer
    method + (arg0) -> Complex
      argument arg0<> -> Integer
    method +@ () -> Complex
    method - (arg0) -> Complex
      argument arg0<> -> Integer
    method -@ () -> Complex
    method / (arg0) -> Complex
      argument arg0<> -> Integer
    method <overload N.1 : **> (arg0) -> Complex
      argument arg0<> -> Float
    method <overload N.1 : *> (arg0) -> Complex
      argument arg0<> -> Float
    method <overload N.1 : +> (arg0) -> Complex
      argument arg0<> -> Float
    method <overload N.1 : -> (arg0) -> Complex
      argument arg0<> -> Float
    method <overload N.1 : /> (arg0) -> Complex
      argument arg0<> -> Float
    method <overload N.1 : quo> (arg0) -> Complex
      argument arg0<> -> Float
    method <overload N.1 : rationalize> (arg0) -> Rational
      argument arg0<optional> -> Integer | Float | Rational | BigDecimal | Complex
    method <overload N.2 : **> (arg0) -> Complex
      argument arg0<> -> Rational
    method <overload N.2 : *> (arg0) -> Complex
      argument arg0<> -> Rational
    method <overload N.2 : +> (arg0) -> Complex
      argument arg0<> -> Rational
    method <overload N.2 : -> (arg0) -> Complex
      argument arg0<> -> Rational
    method <overload N.2 : /> (arg0) -> Complex
      argument arg0<> -> Rational
    method <overload N.2 : quo> (arg0) -> Complex
      argument arg0<> -> Rational
    method <overload N.3 : **> (arg0) -> Complex
      argument arg0<> -> BigDecimal
    method <overload N.3 : *> (arg0) -> Complex
      argument arg0<> -> BigDecimal
    method <overload N.3 : +> (arg0) -> Complex
      argument arg0<> -> BigDecimal
    method <overload N.3 : -> (arg0) -> Complex
      argument arg0<> -> BigDecimal
    method <overload N.3 : /> (arg0) -> Complex
      argument arg0<> -> BigDecimal
    method <overload N.3 : quo> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.4 : **> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : *> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : +> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : -> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : /> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : quo> (arg0) -> Complex
      argument arg0<> -> Complex
    method == (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method abs () -> Integer | Float | Rational | BigDecimal | Complex
    method abs2 () -> Integer | Float | Rational | BigDecimal | Complex
    method angle () -> Float
    method arg () -> Float
    method clone () -> Complex
    method coerce (arg0) -> TupleType {
      0 = Complex
      1 = Complex
    }
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method conj () -> Complex
    method conjugate () -> Complex
    method denominator () -> Integer
    method dup () -> Complex
    method eql? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method equal? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method fdiv (arg0) -> Complex
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method freeze () -> Complex
    method hash () -> Integer
    method imag () -> Integer | Float | Rational | BigDecimal
    method imaginary () -> Integer | Float | Rational | BigDecimal
    method inspect () -> String
    method magnitude () -> Integer | Float | Rational | BigDecimal
    method numerator () -> Complex
    method phase () -> Float
    method polar () -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    }
    method quo (arg0) -> Complex
      argument arg0<> -> Integer
    method rationalize () -> Rational
      argument arg0<optional>
    method real () -> Integer | Float | Rational | BigDecimal
    method real? () -> FalseClass
    method rect () -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    }
    method rectangular () -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    }
    method taint () -> Complex
    method to_c () -> Complex
    method to_f () -> Float
    method to_i () -> Integer
    method to_r () -> Rational
    method to_s () -> String
    method trust () -> Complex
    method untaint () -> Complex
    method untrust () -> Complex
    method zero? () -> TrueClass | FalseClass
    static-field <constant:I> -> Complex
  class <constant:Coverage> (<constant:BasicObject>) -> <Class:Coverage>
  class <constant:Data> < ::<constant:Object> () -> <Class:Data>
    method clone () -> Data
    method dup () -> Data
    method freeze () -> Data
    method taint () -> Data
    method trust () -> Data
    method untaint () -> Data
    method untrust () -> Data
  class <constant:Date> < ::<constant:Object> (<constant:Comparable>) -> <Class:Date>
    class <constant:Infinity> < ::<constant:Numeric> () -> <Class:Date::Infinity>
      method +@ () -> Date::Infinity
      method -@ () -> Date::Infinity
      method <=> (other) -> Integer | NilClass
        argument other<> -> untyped
      method abs () -> Date::Infinity
      method coerce (other) -> Numeric
        argument other<> -> untyped
      method d () -> TrueClass | FalseClass
      method finite? () -> TrueClass | FalseClass
      method infinite? () -> TrueClass | FalseClass
      method nan? () -> TrueClass | FalseClass
      method to_f () -> Float
      method zero? () -> TrueClass | FalseClass
    class <singleton class:<constant:Infinity>> < ::<singleton class:<constant:Numeric>> ()
    method + (arg0) -> untyped
      argument arg0<> -> untyped
    method - (arg0) -> untyped
      argument arg0<> -> untyped
    method << (arg0) -> untyped
      argument arg0<> -> untyped
    method <=> (arg0) -> untyped
      argument arg0<> -> untyped
    method === (arg0) -> untyped
      argument arg0<> -> untyped
    method >> (arg0) -> untyped
      argument arg0<> -> untyped
    method ajd () -> untyped
    method amjd () -> untyped
    method asctime () -> untyped
    method blank? () -> untyped
    method clone () -> Date
    method ctime () -> untyped
    method cwday () -> untyped
    method cweek () -> untyped
    method cwyear () -> untyped
    method day () -> untyped
    method day_fraction () -> untyped
    method downto (arg0) -> untyped
      argument arg0<> -> untyped
    method dup () -> Date
    method england () -> untyped
    method eql? (arg0) -> untyped
      argument arg0<> -> untyped
    method freeze () -> Date
    method friday? () -> untyped
    method gregorian () -> untyped
    method gregorian? () -> untyped
    method hash () -> untyped
    method httpdate () -> untyped
    method initialize (arg0, arg1, arg2, arg3) -> Object
      argument arg0<optional> -> Integer
      argument arg1<optional> -> Integer
      argument arg2<optional> -> Integer
      argument arg3<optional> -> Integer
    method inspect () -> untyped
    method iso8601 () -> untyped
    method italy () -> untyped
    method jd () -> untyped
    method jisx0301 () -> untyped
    method julian () -> untyped
    method julian? () -> untyped
    method ld () -> untyped
    method leap? () -> untyped
    method localize (locale, options) -> untyped
      argument locale<optional> -> untyped
      argument options<optional> -> untyped
    method marshal_dump () -> untyped
    method marshal_load (arg0) -> untyped
      argument arg0<> -> untyped
    method mday () -> untyped
    method mjd () -> untyped
    method mon () -> untyped
    method monday? () -> untyped
    method month () -> untyped
    method new_start (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method next () -> untyped
    method next_day (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method next_month (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method next_year (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method pretty_date () -> untyped
    method prev_day (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method prev_month (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method prev_year (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method rfc2822 () -> untyped
    method rfc3339 () -> untyped
    method rfc822 () -> untyped
    method saturday? () -> untyped
    method start () -> untyped
    method step (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method strftime (arg0) -> String
      argument arg0<> -> String
    method strftime$1 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method succ () -> untyped
    method sunday? () -> untyped
    method taint () -> Date
    method thursday? () -> untyped
    method to_date () -> Date
    method to_datetime () -> DateTime
    method to_s () -> untyped
    method to_time () -> Time
    method to_utc_time () -> untyped
    method trust () -> Date
    method tuesday? () -> untyped
    method untaint () -> Date
    method untrust () -> Date
    method upto (arg0) -> untyped
      argument arg0<> -> untyped
    method wday () -> untyped
    method wednesday? () -> untyped
    method xmlschema () -> untyped
    method yday () -> untyped
    method year () -> untyped
    static-field <constant:ABBR_DAYNAMES> -> untyped
    static-field <constant:ABBR_MONTHNAMES> -> untyped
    static-field <constant:DAYNAMES> -> untyped
    static-field <constant:ENGLAND> -> untyped
    static-field <constant:GREGORIAN> -> untyped
    static-field <constant:ITALY> -> untyped
    static-field <constant:JULIAN> -> untyped
    static-field <constant:MONTHNAMES> -> untyped
  class <constant:DateTime> < ::<constant:Date> () -> <Class:DateTime>
    method blank? () -> untyped
    method clone () -> DateTime
    method dup () -> DateTime
    method freeze () -> DateTime
    method hour () -> untyped
    method iso8601 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method jisx0301 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method localize (locale, options) -> untyped
      argument locale<optional> -> untyped
      argument options<optional> -> untyped
    method min () -> untyped
    method minute () -> untyped
    method new_offset (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method offset () -> untyped
    method rfc3339 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method sec () -> untyped
    method sec_fraction () -> untyped
    method second () -> untyped
    method second_fraction () -> untyped
    method strftime (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method taint () -> DateTime
    method to_date () -> Date
    method to_datetime () -> DateTime
    method to_s () -> untyped
    method to_time () -> Time
    method to_utc_time () -> untyped
    method trust () -> DateTime
    method untaint () -> DateTime
    method untrust () -> DateTime
    method xmlschema (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method zone () -> untyped
    static-field <constant:ABBR_DAYNAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:ABBR_MONTHNAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:DAYNAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:ENGLAND> -> Integer
    static-field <constant:GREGORIAN> -> Float
    static-field <constant:ITALY> -> Integer
    static-field <constant:JULIAN> -> Float
    static-field <constant:MONTHNAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
  class <constant:DidYouMean> (<constant:BasicObject>) -> <Class:DidYouMean>
    class <constant:ClassNameChecker> < ::<constant:Object> () -> <Class:DidYouMean::ClassNameChecker>
      class <constant:ClassName> () -> <Class:DidYouMean::ClassNameChecker::ClassName>
        static-field <constant:RUBYGEMS_ACTIVATION_MONITOR> -> Monitor
      class <singleton class:<constant:ClassName>> < ::<constant:Module> ()
    class <constant:Correctable> (<constant:BasicObject>) -> <Class:DidYouMean::Correctable>
    class <constant:Formatter> < ::<constant:Object> () -> <Class:DidYouMean::Formatter>
    class <constant:Jaro> (<constant:BasicObject>) -> <Class:DidYouMean::Jaro>
    class <constant:JaroWinkler> (<constant:BasicObject>) -> <Class:DidYouMean::JaroWinkler>
      static-field <constant:THRESHOLD> -> Float
      static-field <constant:WEIGHT> -> Float
    class <constant:Levenshtein> (<constant:BasicObject>) -> <Class:DidYouMean::Levenshtein>
    class <constant:MethodNameChecker> < ::<constant:Object> () -> <Class:DidYouMean::MethodNameChecker>
      static-field <constant:NAMES_TO_EXCLUDE> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
    class <constant:NameErrorCheckers> (<constant:BasicObject>) -> <Class:DidYouMean::NameErrorCheckers>
    class <constant:NullChecker> < ::<constant:Object> () -> <Class:DidYouMean::NullChecker>
    class <constant:SpellChecker> < ::<constant:Object> () -> <Class:DidYouMean::SpellChecker>
    class <constant:VariableNameChecker> < ::<constant:Object> () -> <Class:DidYouMean::VariableNameChecker>
      static-field <constant:NAMES_TO_EXCLUDE> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
    class <singleton class:<constant:ClassNameChecker>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:Correctable>> < ::<constant:Module> ()
    class <singleton class:<constant:Formatter>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:Jaro>> < ::<constant:Module> ()
    class <singleton class:<constant:JaroWinkler>> < ::<constant:Module> ()
    class <singleton class:<constant:Levenshtein>> < ::<constant:Module> ()
    class <singleton class:<constant:MethodNameChecker>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:NameErrorCheckers>> < ::<constant:Module> ()
    class <singleton class:<constant:NullChecker>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:SpellChecker>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:VariableNameChecker>> < ::<singleton class:<constant:Object>> ()
    static-field <constant:IGNORED_CALLERS> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:SPELL_CHECKERS> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:VERSION> -> String
  class <constant:Dir>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Dir>
    method <overload N.1 : each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block>
    method clone () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    }
    method close () -> NilClass
    method dup () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    }
    method each (blk) -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
    method fileno () -> Integer
    method freeze () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    }
    method initialize (arg0, arg1) -> Object
      argument arg0<> -> String
      argument arg1<optional> -> Encoding
    method inspect () -> String
    method path () -> String | NilClass
    method pos () -> Integer
    method pos= (arg0) -> Integer
      argument arg0<> -> Integer
    method read () -> String | NilClass
    method rewind () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    }
    method seek (arg0) -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<> -> Integer
    method taint () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    }
    method tell () -> Integer
    method to_path () -> String | NilClass
    method trust () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    }
    method untaint () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    }
    method untrust () -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    }
    typeMember(=) <constant:Elem> -> String
  class <constant:EOFError> < ::<constant:IOError> () -> <Class:EOFError>
    method clone () -> EOFError
    method dup () -> EOFError
    method freeze () -> EOFError
    method taint () -> EOFError
    method trust () -> EOFError
    method untaint () -> EOFError
    method untrust () -> EOFError
  class <constant:Encoding> < ::<constant:Object> () -> <Class:Encoding>
    class <constant:CompatibilityError> < ::<constant:EncodingError> () -> <Class:Encoding::CompatibilityError>
    class <constant:Converter> < ::<constant:Data> () -> <Class:Encoding::Converter>
      static-field <constant:AFTER_OUTPUT> -> Integer
      static-field <constant:CRLF_NEWLINE_DECORATOR> -> Integer
      static-field <constant:CR_NEWLINE_DECORATOR> -> Integer
      static-field <constant:INVALID_MASK> -> Integer
      static-field <constant:INVALID_REPLACE> -> Integer
      static-field <constant:PARTIAL_INPUT> -> Integer
      static-field <constant:UNDEF_HEX_CHARREF> -> Integer
      static-field <constant:UNDEF_MASK> -> Integer
      static-field <constant:UNDEF_REPLACE> -> Integer
      static-field <constant:UNIVERSAL_NEWLINE_DECORATOR> -> Integer
      static-field <constant:XML_ATTR_CONTENT_DECORATOR> -> Integer
      static-field <constant:XML_ATTR_QUOTE_DECORATOR> -> Integer
      static-field <constant:XML_TEXT_DECORATOR> -> Integer
    class <constant:ConverterNotFoundError> < ::<constant:EncodingError> () -> <Class:Encoding::ConverterNotFoundError>
    class <constant:InvalidByteSequenceError> < ::<constant:EncodingError> () -> <Class:Encoding::InvalidByteSequenceError>
    class <constant:UndefinedConversionError> < ::<constant:EncodingError> () -> <Class:Encoding::UndefinedConversionError>
    class <singleton class:<constant:CompatibilityError>> < ::<singleton class:<constant:EncodingError>> ()
    class <singleton class:<constant:Converter>> < ::<singleton class:<constant:Data>> ()
    class <singleton class:<constant:ConverterNotFoundError>> < ::<singleton class:<constant:EncodingError>> ()
    class <singleton class:<constant:InvalidByteSequenceError>> < ::<singleton class:<constant:EncodingError>> ()
    class <singleton class:<constant:UndefinedConversionError>> < ::<singleton class:<constant:EncodingError>> ()
    method ascii_compatible? () -> TrueClass | FalseClass
    method clone () -> Encoding
    method dummy? () -> TrueClass | FalseClass
    method dup () -> Encoding
    method freeze () -> Encoding
    method inspect () -> String
    method name () -> String
    method names () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
    method replicate (name) -> Encoding
      argument name<> -> String
    method taint () -> Encoding
    method to_s () -> String
    method trust () -> Encoding
    method untaint () -> Encoding
    method untrust () -> Encoding
    static-field <constant:ANSI_X3_4_1968> -> Encoding
    static-field <constant:ASCII> -> Encoding
    static-field <constant:ASCII_8BIT> -> Encoding
    static-field <constant:BIG5> -> Encoding
    static-field <constant:BIG5_HKSCS> -> Encoding
    static-field <constant:BIG5_HKSCS_2008> -> Encoding
    static-field <constant:BIG5_UAO> -> Encoding
    static-field <constant:BINARY> -> Encoding
    static-field <constant:CP1250> -> Encoding
    static-field <constant:CP1251> -> Encoding
    static-field <constant:CP1252> -> Encoding
    static-field <constant:CP1253> -> Encoding
    static-field <constant:CP1254> -> Encoding
    static-field <constant:CP1255> -> Encoding
    static-field <constant:CP1256> -> Encoding
    static-field <constant:CP1257> -> Encoding
    static-field <constant:CP1258> -> Encoding
    static-field <constant:CP437> -> Encoding
    static-field <constant:CP50220> -> Encoding
    static-field <constant:CP50221> -> Encoding
    static-field <constant:CP51932> -> Encoding
    static-field <constant:CP65000> -> Encoding
    static-field <constant:CP65001> -> Encoding
    static-field <constant:CP737> -> Encoding
    static-field <constant:CP775> -> Encoding
    static-field <constant:CP850> -> Encoding
    static-field <constant:CP852> -> Encoding
    static-field <constant:CP855> -> Encoding
    static-field <constant:CP857> -> Encoding
    static-field <constant:CP860> -> Encoding
    static-field <constant:CP861> -> Encoding
    static-field <constant:CP862> -> Encoding
    static-field <constant:CP863> -> Encoding
    static-field <constant:CP864> -> Encoding
    static-field <constant:CP865> -> Encoding
    static-field <constant:CP866> -> Encoding
    static-field <constant:CP869> -> Encoding
    static-field <constant:CP874> -> Encoding
    static-field <constant:CP878> -> Encoding
    static-field <constant:CP932> -> Encoding
    static-field <constant:CP936> -> Encoding
    static-field <constant:CP949> -> Encoding
    static-field <constant:CP950> -> Encoding
    static-field <constant:CP951> -> Encoding
    static-field <constant:CSWINDOWS31J> -> Encoding
    static-field <constant:EBCDIC_CP_US> -> Encoding
    static-field <constant:EMACS_MULE> -> Encoding
    static-field <constant:EUCCN> -> Encoding
    static-field <constant:EUCJP> -> Encoding
    static-field <constant:EUCJP_MS> -> Encoding
    static-field <constant:EUCKR> -> Encoding
    static-field <constant:EUCTW> -> Encoding
    static-field <constant:EUC_CN> -> Encoding
    static-field <constant:EUC_JISX0213> -> Encoding
    static-field <constant:EUC_JIS_2004> -> Encoding
    static-field <constant:EUC_JP> -> Encoding
    static-field <constant:EUC_JP_MS> -> Encoding
    static-field <constant:EUC_KR> -> Encoding
    static-field <constant:EUC_TW> -> Encoding
    static-field <constant:GB12345> -> Encoding
    static-field <constant:GB18030> -> Encoding
    static-field <constant:GB1988> -> Encoding
    static-field <constant:GB2312> -> Encoding
    static-field <constant:GBK> -> Encoding
    static-field <constant:IBM037> -> Encoding
    static-field <constant:IBM437> -> Encoding
    static-field <constant:IBM737> -> Encoding
    static-field <constant:IBM775> -> Encoding
    static-field <constant:IBM850> -> Encoding
    static-field <constant:IBM852> -> Encoding
    static-field <constant:IBM855> -> Encoding
    static-field <constant:IBM857> -> Encoding
    static-field <constant:IBM860> -> Encoding
    static-field <constant:IBM861> -> Encoding
    static-field <constant:IBM862> -> Encoding
    static-field <constant:IBM863> -> Encoding
    static-field <constant:IBM864> -> Encoding
    static-field <constant:IBM865> -> Encoding
    static-field <constant:IBM866> -> Encoding
    static-field <constant:IBM869> -> Encoding
    static-field <constant:ISO2022_JP2> -> Encoding
    static-field <constant:ISO2022_JP> -> Encoding
    static-field <constant:ISO8859_10> -> Encoding
    static-field <constant:ISO8859_11> -> Encoding
    static-field <constant:ISO8859_13> -> Encoding
    static-field <constant:ISO8859_14> -> Encoding
    static-field <constant:ISO8859_15> -> Encoding
    static-field <constant:ISO8859_16> -> Encoding
    static-field <constant:ISO8859_1> -> Encoding
    static-field <constant:ISO8859_2> -> Encoding
    static-field <constant:ISO8859_3> -> Encoding
    static-field <constant:ISO8859_4> -> Encoding
    static-field <constant:ISO8859_5> -> Encoding
    static-field <constant:ISO8859_6> -> Encoding
    static-field <constant:ISO8859_7> -> Encoding
    static-field <constant:ISO8859_8> -> Encoding
    static-field <constant:ISO8859_9> -> Encoding
    static-field <constant:ISO_2022_JP> -> Encoding
    static-field <constant:ISO_2022_JP_2> -> Encoding
    static-field <constant:ISO_2022_JP_KDDI> -> Encoding
    static-field <constant:ISO_8859_10> -> Encoding
    static-field <constant:ISO_8859_11> -> Encoding
    static-field <constant:ISO_8859_13> -> Encoding
    static-field <constant:ISO_8859_14> -> Encoding
    static-field <constant:ISO_8859_15> -> Encoding
    static-field <constant:ISO_8859_16> -> Encoding
    static-field <constant:ISO_8859_1> -> Encoding
    static-field <constant:ISO_8859_2> -> Encoding
    static-field <constant:ISO_8859_3> -> Encoding
    static-field <constant:ISO_8859_4> -> Encoding
    static-field <constant:ISO_8859_5> -> Encoding
    static-field <constant:ISO_8859_6> -> Encoding
    static-field <constant:ISO_8859_7> -> Encoding
    static-field <constant:ISO_8859_8> -> Encoding
    static-field <constant:ISO_8859_9> -> Encoding
    static-field <constant:KOI8_R> -> Encoding
    static-field <constant:KOI8_U> -> Encoding
    static-field <constant:MACCENTEURO> -> Encoding
    static-field <constant:MACCROATIAN> -> Encoding
    static-field <constant:MACCYRILLIC> -> Encoding
    static-field <constant:MACGREEK> -> Encoding
    static-field <constant:MACICELAND> -> Encoding
    static-field <constant:MACJAPAN> -> Encoding
    static-field <constant:MACJAPANESE> -> Encoding
    static-field <constant:MACROMAN> -> Encoding
    static-field <constant:MACROMANIA> -> Encoding
    static-field <constant:MACTHAI> -> Encoding
    static-field <constant:MACTURKISH> -> Encoding
    static-field <constant:MACUKRAINE> -> Encoding
    static-field <constant:PCK> -> Encoding
    static-field <constant:SHIFT_JIS> -> Encoding
    static-field <constant:SJIS> -> Encoding
    static-field <constant:SJIS_DOCOMO> -> Encoding
    static-field <constant:SJIS_KDDI> -> Encoding
    static-field <constant:SJIS_SOFTBANK> -> Encoding
    static-field <constant:STATELESS_ISO_2022_JP> -> Encoding
    static-field <constant:STATELESS_ISO_2022_JP_KDDI> -> Encoding
    static-field <constant:TIS_620> -> Encoding
    static-field <constant:UCS_2BE> -> Encoding
    static-field <constant:UCS_4BE> -> Encoding
    static-field <constant:UCS_4LE> -> Encoding
    static-field <constant:US_ASCII> -> Encoding
    static-field <constant:UTF8_DOCOMO> -> Encoding
    static-field <constant:UTF8_KDDI> -> Encoding
    static-field <constant:UTF8_MAC> -> Encoding
    static-field <constant:UTF8_SOFTBANK> -> Encoding
    static-field <constant:UTF_16> -> Encoding
    static-field <constant:UTF_16BE> -> Encoding
    static-field <constant:UTF_16LE> -> Encoding
    static-field <constant:UTF_32> -> Encoding
    static-field <constant:UTF_32BE> -> Encoding
    static-field <constant:UTF_32LE> -> Encoding
    static-field <constant:UTF_7> -> Encoding
    static-field <constant:UTF_8> -> Encoding
    static-field <constant:UTF_8_HFS> -> Encoding
    static-field <constant:UTF_8_MAC> -> Encoding
    static-field <constant:WINDOWS_1250> -> Encoding
    static-field <constant:WINDOWS_1251> -> Encoding
    static-field <constant:WINDOWS_1252> -> Encoding
    static-field <constant:WINDOWS_1253> -> Encoding
    static-field <constant:WINDOWS_1254> -> Encoding
    static-field <constant:WINDOWS_1255> -> Encoding
    static-field <constant:WINDOWS_1256> -> Encoding
    static-field <constant:WINDOWS_1257> -> Encoding
    static-field <constant:WINDOWS_1258> -> Encoding
    static-field <constant:WINDOWS_31J> -> Encoding
    static-field <constant:WINDOWS_874> -> Encoding
  class <constant:EncodingError> < ::<constant:StandardError> () -> <Class:EncodingError>
    method clone () -> EncodingError
    method dup () -> EncodingError
    method freeze () -> EncodingError
    method taint () -> EncodingError
    method trust () -> EncodingError
    method untaint () -> EncodingError
    method untrust () -> EncodingError
  class <constant:Enumerable>[<constant:Elem>] (<constant:BasicObject>) -> <Class:Enumerable>
    method <overload N.1 : all?> (blk) -> TrueClass | FalseClass
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.1 : any?> (blk) -> TrueClass | FalseClass
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.1 : collect> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : count> (arg0) -> Integer
      argument arg0<optional> -> BasicObject
      argument blk<block>
    method <overload N.1 : cycle> (n) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
      argument n<optional> -> Integer
    method <overload N.1 : detect> (ifnone) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
      argument ifnone<optional> -> Proc
    method <overload N.1 : drop_while> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : each_cons> (n) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
      argument n<> -> Integer
    method <overload N.1 : each_slice> (n) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
      argument n<> -> Integer
    method <overload N.1 : each_with_index> () -> AppliedType {
      klass = ::<constant:Enumerable>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : find> (ifnone) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
      argument ifnone<optional> -> Proc
    method <overload N.1 : find_all> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : find_index> (blk) -> Integer | NilClass
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
      argument value<optional>
    method <overload N.1 : first> (n) -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          ]
        } | NilClass
      argument n<optional> -> Integer
    method <overload N.1 : grep> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> BasicObject
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.1 : group_by> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : inject> (arg0) -> untyped
      argument arg0<optional> -> Symbol
      argument blk<block>
      argument initial<optional>
    method <overload N.1 : map> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : max> (blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.1 : max_by> (blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.1 : min> (blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.1 : min_by> (blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.1 : minmax> (blk) -> TupleType {
      0 = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      1 = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.1 : minmax_by> (blk) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.1 : none?> (blk) -> TrueClass | FalseClass
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.1 : one?> (blk) -> TrueClass | FalseClass
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.1 : partition> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : reduce> (arg0) -> untyped
      argument arg0<optional> -> Symbol
      argument blk<block>
      argument initial<optional>
    method <overload N.1 : reject> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : reverse_each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : select> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : sort> (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.1 : sort_by> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : take_while> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.2 : count> (blk) -> Integer
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.2 : find_index> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
      argument value<optional>
    method <overload N.2 : inject> (initial, blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
      argument initial<optional> -> LambdaParam(::<constant:Enumerable>#<constant:Elem>)
    method <overload N.2 : max> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
      argument blk<block>
    method <overload N.2 : max_by> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
      argument blk<block>
    method <overload N.2 : min> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
      argument blk<block>
    method <overload N.2 : min_by> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
      argument blk<block>
    method <overload N.2 : reduce> (initial, blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
      argument initial<optional> -> LambdaParam(::<constant:Enumerable>#<constant:Elem>)
    method <overload N.3 : inject> (blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
      argument initial<optional>
    method <overload N.3 : max> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.3 : max_by> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.3 : min> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.3 : min_by> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument arg0<optional> -> Integer
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method <overload N.3 : reduce> (blk) -> LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      argument arg0<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
      argument initial<optional>
    method all? () -> TrueClass | FalseClass
      argument blk<block>
    method any? () -> TrueClass | FalseClass
      argument blk<block>
    method collect (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method collect_concat (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = AppliedType {
              klass = ::<constant:Enumerator>
              targs = [
                <constant:Elem> = BasicObject
              ]
            }
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method count () -> Integer
      argument arg0<optional>
      argument blk<block>
    method cycle (n, blk) -> NilClass
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
      argument n<optional> -> Integer
    method detect (ifnone, blk) -> NilClass | LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
      argument ifnone<optional> -> Proc
    method drop (n) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument n<> -> Integer
    method drop_while (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method each_cons (n, blk) -> NilClass
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
              ]
            }
        ]
      }
      argument n<> -> Integer
    method each_slice (n, blk) -> NilClass
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
              ]
            }
        ]
      }
      argument n<> -> Integer
    method each_with_index (blk) -> AppliedType {
      klass = ::<constant:Enumerable>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          <constant:Arg1> = Integer
        ]
      }
    method entries () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
    method find (ifnone, blk) -> NilClass | LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
      argument ifnone<optional> -> Proc
    method find_all (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method find_index (value) -> Integer | NilClass
      argument blk<block>
      argument value<optional> -> BasicObject
    method first () -> NilClass | LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      argument n<optional>
    method flat_map (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = AppliedType {
              klass = ::<constant:Enumerator>
              targs = [
                <constant:Elem> = BasicObject
              ]
            }
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method grep (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument arg0<> -> BasicObject
      argument blk<block>
    method group_by (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
            ]
          }
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method include? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method inject (initial, arg0) -> untyped
      argument arg0<optional> -> Symbol
      argument blk<block>
      argument initial<optional> -> BasicObject
    method map (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method max () -> LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      argument arg0<optional>
      argument blk<block>
    method max_by () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument arg0<optional>
      argument blk<block>
    method member? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method min () -> LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      argument arg0<optional>
      argument blk<block>
    method min_by () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument arg0<optional>
      argument blk<block>
    method minmax () -> TupleType {
      0 = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      1 = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
    }
      argument blk<block>
    method minmax_by () -> TupleType {
      0 = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      1 = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
    }
      argument blk<block>
    method none? () -> TrueClass | FalseClass
      argument blk<block>
    method one? () -> TrueClass | FalseClass
      argument blk<block>
    method partition (blk) -> TupleType {
      0 = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
            ]
          }
      1 = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
            ]
          }
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method reduce (initial, arg0) -> untyped
      argument arg0<optional> -> Symbol
      argument blk<block>
      argument initial<optional> -> BasicObject
    method reject (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method reverse_each (blk) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method select (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method sort () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method sort_by (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method take (n) -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
          ]
        } | NilClass
      argument n<> -> Integer
    method take_while (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        ]
      }
    method to_a () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
      ]
    }
    method to_h () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        <constant:V> = LambdaParam(::<constant:Enumerable>#<constant:Elem>)
        <constant:Elem> = untyped
      ]
    }
    typeMember(=) <constant:Elem>
  class <constant:Enumerator>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Enumerator>
    class <constant:Generator>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Enumerator::Generator>
      typeMember(=) <constant:Elem>
    class <constant:Lazy>[<constant:Elem>] < ::<constant:Enumerator> () -> <Class:Enumerator::Lazy>
      typeMember(=) <constant:Elem>
    class <constant:Yielder> < ::<constant:Object> () -> <Class:Enumerator::Yielder>
    class <singleton class:<constant:Generator>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:Lazy>> < ::<singleton class:<constant:Enumerator>> ()
    class <singleton class:<constant:Yielder>> < ::<singleton class:<constant:Object>> ()
    method <overload N.1 : each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block>
    method <overload N.1 : each_with_index> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
            1 = Integer
          }
      ]
    }
      argument blk<block>
    method <overload N.1 : each_with_object> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
            1 = untyped
          }
      ]
    }
      argument arg0<> -> BasicObject
      argument blk<block>
    method <overload N.1 : initialize> (arg0, blk) -> Object
      argument arg0<optional> -> Proc
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = untyped
              ]
            }
        ]
      }
    method <overload N.1 : with_index> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
            1 = Integer
          }
      ]
    }
      argument blk<block>
    method <overload N.1 : with_object> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
            1 = untyped
          }
      ]
    }
      argument arg0<> -> BasicObject
      argument blk<block>
    method clone () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method dup () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method each (blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
        ]
      }
    method each_with_index (blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
          <constant:Arg1> = Integer
        ]
      }
    method each_with_object (arg0, blk) -> untyped
      argument arg0<> -> BasicObject
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
          <constant:Arg1> = untyped
        ]
      }
    method feed (arg0) -> NilClass
      argument arg0<> -> LambdaParam(::<constant:Enumerator>#<constant:Elem>)
    method freeze () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method initialize (arg0, blk) -> Object
      argument arg0<optional> -> Integer
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = untyped
              ]
            }
        ]
      }
    method inspect () -> String
    method next () -> LambdaParam(::<constant:Enumerator>#<constant:Elem>)
    method next_values () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
      ]
    }
    method peek () -> LambdaParam(::<constant:Enumerator>#<constant:Elem>)
    method peek_values () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
      ]
    }
    method rewind () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method size () -> Integer | Float | NilClass
    method taint () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method trust () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method untaint () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method untrust () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method with_index (blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
          <constant:Arg1> = Integer
        ]
      }
    method with_object (arg0, blk) -> untyped
      argument arg0<> -> BasicObject
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Enumerator>#<constant:Elem>)
          <constant:Arg1> = untyped
        ]
      }
    typeMember(=) <constant:Elem>
  class <constant:Errno> (<constant:BasicObject>) -> <Class:Errno>
    class <constant:E2BIG> < ::<constant:SystemCallError> () -> <Class:Errno::E2BIG>
    class <constant:EACCES> < ::<constant:SystemCallError> () -> <Class:Errno::EACCES>
    class <constant:EADDRINUSE> < ::<constant:SystemCallError> () -> <Class:Errno::EADDRINUSE>
    class <constant:EADDRNOTAVAIL> < ::<constant:SystemCallError> () -> <Class:Errno::EADDRNOTAVAIL>
    class <constant:EADV> < ::<constant:SystemCallError> () -> <Class:Errno::EADV>
    class <constant:EAFNOSUPPORT> < ::<constant:SystemCallError> () -> <Class:Errno::EAFNOSUPPORT>
    class <constant:EAGAIN> < ::<constant:SystemCallError> () -> <Class:Errno::EAGAIN>
    class <constant:EALREADY> < ::<constant:SystemCallError> () -> <Class:Errno::EALREADY>
    class <constant:EBADE> < ::<constant:SystemCallError> () -> <Class:Errno::EBADE>
    class <constant:EBADF> < ::<constant:SystemCallError> () -> <Class:Errno::EBADF>
    class <constant:EBADFD> < ::<constant:SystemCallError> () -> <Class:Errno::EBADFD>
    class <constant:EBADMSG> < ::<constant:SystemCallError> () -> <Class:Errno::EBADMSG>
    class <constant:EBADR> < ::<constant:SystemCallError> () -> <Class:Errno::EBADR>
    class <constant:EBADRQC> < ::<constant:SystemCallError> () -> <Class:Errno::EBADRQC>
    class <constant:EBADSLT> < ::<constant:SystemCallError> () -> <Class:Errno::EBADSLT>
    class <constant:EBFONT> < ::<constant:SystemCallError> () -> <Class:Errno::EBFONT>
    class <constant:EBUSY> < ::<constant:SystemCallError> () -> <Class:Errno::EBUSY>
    class <constant:ECANCELED> < ::<constant:SystemCallError> () -> <Class:Errno::ECANCELED>
    class <constant:ECHILD> < ::<constant:SystemCallError> () -> <Class:Errno::ECHILD>
    class <constant:ECHRNG> < ::<constant:SystemCallError> () -> <Class:Errno::ECHRNG>
    class <constant:ECOMM> < ::<constant:SystemCallError> () -> <Class:Errno::ECOMM>
    class <constant:ECONNABORTED> < ::<constant:SystemCallError> () -> <Class:Errno::ECONNABORTED>
    class <constant:ECONNREFUSED> < ::<constant:SystemCallError> () -> <Class:Errno::ECONNREFUSED>
    class <constant:ECONNRESET> < ::<constant:SystemCallError> () -> <Class:Errno::ECONNRESET>
    class <constant:EDEADLK> < ::<constant:SystemCallError> () -> <Class:Errno::EDEADLK>
    class <constant:EDESTADDRREQ> < ::<constant:SystemCallError> () -> <Class:Errno::EDESTADDRREQ>
    class <constant:EDOM> < ::<constant:SystemCallError> () -> <Class:Errno::EDOM>
    class <constant:EDOTDOT> < ::<constant:SystemCallError> () -> <Class:Errno::EDOTDOT>
    class <constant:EDQUOT> < ::<constant:SystemCallError> () -> <Class:Errno::EDQUOT>
    class <constant:EEXIST> < ::<constant:SystemCallError> () -> <Class:Errno::EEXIST>
    class <constant:EFAULT> < ::<constant:SystemCallError> () -> <Class:Errno::EFAULT>
    class <constant:EFBIG> < ::<constant:SystemCallError> () -> <Class:Errno::EFBIG>
    class <constant:EHOSTDOWN> < ::<constant:SystemCallError> () -> <Class:Errno::EHOSTDOWN>
    class <constant:EHOSTUNREACH> < ::<constant:SystemCallError> () -> <Class:Errno::EHOSTUNREACH>
    class <constant:EHWPOISON> < ::<constant:SystemCallError> () -> <Class:Errno::EHWPOISON>
    class <constant:EIDRM> < ::<constant:SystemCallError> () -> <Class:Errno::EIDRM>
    class <constant:EILSEQ> < ::<constant:SystemCallError> () -> <Class:Errno::EILSEQ>
    class <constant:EINPROGRESS> < ::<constant:SystemCallError> () -> <Class:Errno::EINPROGRESS>
    class <constant:EINTR> < ::<constant:SystemCallError> () -> <Class:Errno::EINTR>
    class <constant:EINVAL> < ::<constant:SystemCallError> () -> <Class:Errno::EINVAL>
    class <constant:EIO> < ::<constant:SystemCallError> () -> <Class:Errno::EIO>
    class <constant:EISCONN> < ::<constant:SystemCallError> () -> <Class:Errno::EISCONN>
    class <constant:EISDIR> < ::<constant:SystemCallError> () -> <Class:Errno::EISDIR>
    class <constant:EISNAM> < ::<constant:SystemCallError> () -> <Class:Errno::EISNAM>
    class <constant:EKEYEXPIRED> < ::<constant:SystemCallError> () -> <Class:Errno::EKEYEXPIRED>
    class <constant:EKEYREJECTED> < ::<constant:SystemCallError> () -> <Class:Errno::EKEYREJECTED>
    class <constant:EKEYREVOKED> < ::<constant:SystemCallError> () -> <Class:Errno::EKEYREVOKED>
    class <constant:EL2HLT> < ::<constant:SystemCallError> () -> <Class:Errno::EL2HLT>
    class <constant:EL2NSYNC> < ::<constant:SystemCallError> () -> <Class:Errno::EL2NSYNC>
    class <constant:EL3HLT> < ::<constant:SystemCallError> () -> <Class:Errno::EL3HLT>
    class <constant:EL3RST> < ::<constant:SystemCallError> () -> <Class:Errno::EL3RST>
    class <constant:ELIBACC> < ::<constant:SystemCallError> () -> <Class:Errno::ELIBACC>
    class <constant:ELIBBAD> < ::<constant:SystemCallError> () -> <Class:Errno::ELIBBAD>
    class <constant:ELIBEXEC> < ::<constant:SystemCallError> () -> <Class:Errno::ELIBEXEC>
    class <constant:ELIBMAX> < ::<constant:SystemCallError> () -> <Class:Errno::ELIBMAX>
    class <constant:ELIBSCN> < ::<constant:SystemCallError> () -> <Class:Errno::ELIBSCN>
    class <constant:ELNRNG> < ::<constant:SystemCallError> () -> <Class:Errno::ELNRNG>
    class <constant:ELOOP> < ::<constant:SystemCallError> () -> <Class:Errno::ELOOP>
    class <constant:EMEDIUMTYPE> < ::<constant:SystemCallError> () -> <Class:Errno::EMEDIUMTYPE>
    class <constant:EMFILE> < ::<constant:SystemCallError> () -> <Class:Errno::EMFILE>
    class <constant:EMLINK> < ::<constant:SystemCallError> () -> <Class:Errno::EMLINK>
    class <constant:EMSGSIZE> < ::<constant:SystemCallError> () -> <Class:Errno::EMSGSIZE>
    class <constant:EMULTIHOP> < ::<constant:SystemCallError> () -> <Class:Errno::EMULTIHOP>
    class <constant:ENAMETOOLONG> < ::<constant:SystemCallError> () -> <Class:Errno::ENAMETOOLONG>
    class <constant:ENAVAIL> < ::<constant:SystemCallError> () -> <Class:Errno::ENAVAIL>
    class <constant:ENETDOWN> < ::<constant:SystemCallError> () -> <Class:Errno::ENETDOWN>
    class <constant:ENETRESET> < ::<constant:SystemCallError> () -> <Class:Errno::ENETRESET>
    class <constant:ENETUNREACH> < ::<constant:SystemCallError> () -> <Class:Errno::ENETUNREACH>
    class <constant:ENFILE> < ::<constant:SystemCallError> () -> <Class:Errno::ENFILE>
    class <constant:ENOANO> < ::<constant:SystemCallError> () -> <Class:Errno::ENOANO>
    class <constant:ENOBUFS> < ::<constant:SystemCallError> () -> <Class:Errno::ENOBUFS>
    class <constant:ENOCSI> < ::<constant:SystemCallError> () -> <Class:Errno::ENOCSI>
    class <constant:ENODATA> < ::<constant:SystemCallError> () -> <Class:Errno::ENODATA>
    class <constant:ENODEV> < ::<constant:SystemCallError> () -> <Class:Errno::ENODEV>
    class <constant:ENOENT> < ::<constant:SystemCallError> () -> <Class:Errno::ENOENT>
    class <constant:ENOEXEC> < ::<constant:SystemCallError> () -> <Class:Errno::ENOEXEC>
    class <constant:ENOKEY> < ::<constant:SystemCallError> () -> <Class:Errno::ENOKEY>
    class <constant:ENOLCK> < ::<constant:SystemCallError> () -> <Class:Errno::ENOLCK>
    class <constant:ENOLINK> < ::<constant:SystemCallError> () -> <Class:Errno::ENOLINK>
    class <constant:ENOMEDIUM> < ::<constant:SystemCallError> () -> <Class:Errno::ENOMEDIUM>
    class <constant:ENOMEM> < ::<constant:SystemCallError> () -> <Class:Errno::ENOMEM>
    class <constant:ENOMSG> < ::<constant:SystemCallError> () -> <Class:Errno::ENOMSG>
    class <constant:ENONET> < ::<constant:SystemCallError> () -> <Class:Errno::ENONET>
    class <constant:ENOPKG> < ::<constant:SystemCallError> () -> <Class:Errno::ENOPKG>
    class <constant:ENOPROTOOPT> < ::<constant:SystemCallError> () -> <Class:Errno::ENOPROTOOPT>
    class <constant:ENOSPC> < ::<constant:SystemCallError> () -> <Class:Errno::ENOSPC>
    class <constant:ENOSR> < ::<constant:SystemCallError> () -> <Class:Errno::ENOSR>
    class <constant:ENOSTR> < ::<constant:SystemCallError> () -> <Class:Errno::ENOSTR>
    class <constant:ENOSYS> < ::<constant:SystemCallError> () -> <Class:Errno::ENOSYS>
    class <constant:ENOTBLK> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTBLK>
    class <constant:ENOTCONN> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTCONN>
    class <constant:ENOTDIR> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTDIR>
    class <constant:ENOTEMPTY> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTEMPTY>
    class <constant:ENOTNAM> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTNAM>
    class <constant:ENOTRECOVERABLE> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTRECOVERABLE>
    class <constant:ENOTSOCK> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTSOCK>
    class <constant:ENOTTY> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTTY>
    class <constant:ENOTUNIQ> < ::<constant:SystemCallError> () -> <Class:Errno::ENOTUNIQ>
    class <constant:ENXIO> < ::<constant:SystemCallError> () -> <Class:Errno::ENXIO>
    class <constant:EOPNOTSUPP> < ::<constant:SystemCallError> () -> <Class:Errno::EOPNOTSUPP>
    class <constant:EOVERFLOW> < ::<constant:SystemCallError> () -> <Class:Errno::EOVERFLOW>
    class <constant:EOWNERDEAD> < ::<constant:SystemCallError> () -> <Class:Errno::EOWNERDEAD>
    class <constant:EPERM> < ::<constant:SystemCallError> () -> <Class:Errno::EPERM>
    class <constant:EPFNOSUPPORT> < ::<constant:SystemCallError> () -> <Class:Errno::EPFNOSUPPORT>
    class <constant:EPIPE> < ::<constant:SystemCallError> () -> <Class:Errno::EPIPE>
    class <constant:EPROTO> < ::<constant:SystemCallError> () -> <Class:Errno::EPROTO>
    class <constant:EPROTONOSUPPORT> < ::<constant:SystemCallError> () -> <Class:Errno::EPROTONOSUPPORT>
    class <constant:EPROTOTYPE> < ::<constant:SystemCallError> () -> <Class:Errno::EPROTOTYPE>
    class <constant:ERANGE> < ::<constant:SystemCallError> () -> <Class:Errno::ERANGE>
    class <constant:EREMCHG> < ::<constant:SystemCallError> () -> <Class:Errno::EREMCHG>
    class <constant:EREMOTE> < ::<constant:SystemCallError> () -> <Class:Errno::EREMOTE>
    class <constant:EREMOTEIO> < ::<constant:SystemCallError> () -> <Class:Errno::EREMOTEIO>
    class <constant:ERESTART> < ::<constant:SystemCallError> () -> <Class:Errno::ERESTART>
    class <constant:ERFKILL> < ::<constant:SystemCallError> () -> <Class:Errno::ERFKILL>
    class <constant:EROFS> < ::<constant:SystemCallError> () -> <Class:Errno::EROFS>
    class <constant:ESHUTDOWN> < ::<constant:SystemCallError> () -> <Class:Errno::ESHUTDOWN>
    class <constant:ESOCKTNOSUPPORT> < ::<constant:SystemCallError> () -> <Class:Errno::ESOCKTNOSUPPORT>
    class <constant:ESPIPE> < ::<constant:SystemCallError> () -> <Class:Errno::ESPIPE>
    class <constant:ESRCH> < ::<constant:SystemCallError> () -> <Class:Errno::ESRCH>
    class <constant:ESRMNT> < ::<constant:SystemCallError> () -> <Class:Errno::ESRMNT>
    class <constant:ESTALE> < ::<constant:SystemCallError> () -> <Class:Errno::ESTALE>
    class <constant:ESTRPIPE> < ::<constant:SystemCallError> () -> <Class:Errno::ESTRPIPE>
    class <constant:ETIME> < ::<constant:SystemCallError> () -> <Class:Errno::ETIME>
    class <constant:ETIMEDOUT> < ::<constant:SystemCallError> () -> <Class:Errno::ETIMEDOUT>
    class <constant:ETOOMANYREFS> < ::<constant:SystemCallError> () -> <Class:Errno::ETOOMANYREFS>
    class <constant:ETXTBSY> < ::<constant:SystemCallError> () -> <Class:Errno::ETXTBSY>
    class <constant:EUCLEAN> < ::<constant:SystemCallError> () -> <Class:Errno::EUCLEAN>
    class <constant:EUNATCH> < ::<constant:SystemCallError> () -> <Class:Errno::EUNATCH>
    class <constant:EUSERS> < ::<constant:SystemCallError> () -> <Class:Errno::EUSERS>
    class <constant:EXDEV> < ::<constant:SystemCallError> () -> <Class:Errno::EXDEV>
    class <constant:EXFULL> < ::<constant:SystemCallError> () -> <Class:Errno::EXFULL>
    class <constant:NOERROR> < ::<constant:SystemCallError> () -> <Class:Errno::NOERROR>
    class <singleton class:<constant:E2BIG>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EACCES>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EADDRINUSE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EADDRNOTAVAIL>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EADV>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EAFNOSUPPORT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EAGAIN>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EALREADY>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EBADE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EBADF>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EBADFD>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EBADMSG>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EBADR>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EBADRQC>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EBADSLT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EBFONT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EBUSY>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ECANCELED>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ECHILD>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ECHRNG>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ECOMM>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ECONNABORTED>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ECONNREFUSED>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ECONNRESET>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EDEADLK>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EDESTADDRREQ>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EDOM>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EDOTDOT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EDQUOT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EEXIST>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EFAULT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EFBIG>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EHOSTDOWN>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EHOSTUNREACH>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EHWPOISON>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EIDRM>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EILSEQ>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EINPROGRESS>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EINTR>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EINVAL>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EIO>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EISCONN>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EISDIR>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EISNAM>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EKEYEXPIRED>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EKEYREJECTED>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EKEYREVOKED>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EL2HLT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EL2NSYNC>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EL3HLT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EL3RST>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ELIBACC>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ELIBBAD>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ELIBEXEC>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ELIBMAX>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ELIBSCN>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ELNRNG>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ELOOP>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EMEDIUMTYPE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EMFILE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EMLINK>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EMSGSIZE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EMULTIHOP>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENAMETOOLONG>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENAVAIL>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENETDOWN>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENETRESET>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENETUNREACH>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENFILE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOANO>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOBUFS>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOCSI>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENODATA>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENODEV>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOENT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOEXEC>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOKEY>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOLCK>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOLINK>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOMEDIUM>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOMEM>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOMSG>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENONET>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOPKG>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOPROTOOPT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOSPC>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOSR>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOSTR>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOSYS>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOTBLK>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOTCONN>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOTDIR>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOTEMPTY>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOTNAM>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOTRECOVERABLE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOTSOCK>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOTTY>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENOTUNIQ>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ENXIO>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EOPNOTSUPP>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EOVERFLOW>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EOWNERDEAD>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EPERM>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EPFNOSUPPORT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EPIPE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EPROTO>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EPROTONOSUPPORT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EPROTOTYPE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ERANGE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EREMCHG>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EREMOTE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EREMOTEIO>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ERESTART>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ERFKILL>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EROFS>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ESHUTDOWN>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ESOCKTNOSUPPORT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ESPIPE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ESRCH>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ESRMNT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ESTALE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ESTRPIPE>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ETIME>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ETIMEDOUT>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ETOOMANYREFS>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:ETXTBSY>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EUCLEAN>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EUNATCH>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EUSERS>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EXDEV>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:EXFULL>> < ::<singleton class:<constant:SystemCallError>> ()
    class <singleton class:<constant:NOERROR>> < ::<singleton class:<constant:SystemCallError>> ()
  class <constant:Exception> < ::<constant:Object> () -> <Class:Exception>
    method == (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method backtrace () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
    method backtrace_locations () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Thread::Backtrace::Location
      ]
    }
    method cause () -> NilClass
    method clone () -> Exception
    method dup () -> Exception
    method exception (arg0) -> Exception
      argument arg0<optional> -> String
    method freeze () -> Exception
    method initialize (arg0) -> Object
      argument arg0<optional> -> String
    method inspect () -> String
    method message () -> String
    method set_backtrace (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<> -> AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          } | String
    method taint () -> Exception
    method to_s () -> String
    method trust () -> Exception
    method untaint () -> Exception
    method untrust () -> Exception
  class <constant:FalseClass> < ::<constant:Object> () -> <Class:FalseClass>
    method clone () -> FalseClass
    method dup () -> FalseClass
    method freeze () -> FalseClass
    method taint () -> FalseClass
    method trust () -> FalseClass
    method untaint () -> FalseClass
    method untrust () -> FalseClass
  class <constant:Fiber> < ::<constant:Object> () -> <Class:Fiber>
    method clone () -> Fiber
    method dup () -> Fiber
    method freeze () -> Fiber
    method taint () -> Fiber
    method trust () -> Fiber
    method untaint () -> Fiber
    method untrust () -> Fiber
  class <constant:FiberError> < ::<constant:StandardError> () -> <Class:FiberError>
    method clone () -> FiberError
    method dup () -> FiberError
    method freeze () -> FiberError
    method taint () -> FiberError
    method trust () -> FiberError
    method untaint () -> FiberError
    method untrust () -> FiberError
  class <constant:File>[<constant:Elem>] < ::<constant:IO> () -> <Class:File>
    class <constant:Constants> (<constant:BasicObject>) -> <Class:File::Constants>
      static-field <constant:APPEND> -> Integer
      static-field <constant:BINARY> -> Integer
      static-field <constant:CREAT> -> Integer
      static-field <constant:DIRECT> -> Integer
      static-field <constant:DSYNC> -> Integer
      static-field <constant:EXCL> -> Integer
      static-field <constant:FNM_CASEFOLD> -> Integer
      static-field <constant:FNM_DOTMATCH> -> Integer
      static-field <constant:FNM_EXTGLOB> -> Integer
      static-field <constant:FNM_NOESCAPE> -> Integer
      static-field <constant:FNM_PATHNAME> -> Integer
      static-field <constant:FNM_SHORTNAME> -> Integer
      static-field <constant:FNM_SYSCASE> -> Integer
      static-field <constant:LOCK_EX> -> Integer
      static-field <constant:LOCK_NB> -> Integer
      static-field <constant:LOCK_SH> -> Integer
      static-field <constant:LOCK_UN> -> Integer
      static-field <constant:NOATIME> -> Integer
      static-field <constant:NOCTTY> -> Integer
      static-field <constant:NOFOLLOW> -> Integer
      static-field <constant:NONBLOCK> -> Integer
      static-field <constant:NULL> -> String
      static-field <constant:RDONLY> -> Integer
      static-field <constant:RDWR> -> Integer
      static-field <constant:RSYNC> -> Integer
      static-field <constant:SHARE_DELETE> -> Integer
      static-field <constant:SYNC> -> Integer
      static-field <constant:TMPFILE> -> Integer
      static-field <constant:TRUNC> -> Integer
      static-field <constant:WRONLY> -> Integer
    class <constant:Stat> < ::<constant:Object> (<constant:Comparable>) -> <Class:File::Stat>
      method <=> (other) -> Integer | NilClass
        argument other<> -> File::Stat
      method atime () -> Time
      method birthtime () -> Time
      method blksize () -> Integer | NilClass
      method blockdev? () -> TrueClass | FalseClass
      method blocks () -> Integer | NilClass
      method chardev? () -> TrueClass | FalseClass
      method ctime () -> Time
      method dev () -> Integer
      method dev_major () -> Integer
      method dev_minor () -> Integer
      method directory? () -> TrueClass | FalseClass
      method executable? () -> TrueClass | FalseClass
      method executable_real? () -> TrueClass | FalseClass
      method file? () -> TrueClass | FalseClass
      method ftype () -> String
      method gid () -> Integer
      method grpowned? () -> TrueClass | FalseClass
      method initialize (file) -> Object
        argument file<> -> String
      method ino () -> Integer
      method inspect () -> String
      method mode () -> Integer
      method mtime () -> Time
      method nlink () -> Integer
      method owned? () -> TrueClass | FalseClass
      method pipe? () -> TrueClass | FalseClass
      method rdev () -> Integer | NilClass
      method rdev_major () -> Integer
      method rdev_minor () -> Integer
      method readable? () -> TrueClass | FalseClass
      method readable_real? () -> TrueClass | FalseClass
      method setgid? () -> TrueClass | FalseClass
      method setuid? () -> TrueClass | FalseClass
      method size () -> Integer
      method socket? () -> TrueClass | FalseClass
      method sticky? () -> TrueClass | FalseClass
      method symlink? () -> TrueClass | FalseClass
      method uid () -> Integer
      method world_readable? () -> Integer | NilClass
      method world_writable? () -> Integer | NilClass
      method writable? () -> TrueClass | FalseClass
      method writable_real? () -> TrueClass | FalseClass
      method zero? () -> TrueClass | FalseClass
    class <singleton class:<constant:Constants>> < ::<constant:Module> ()
    class <singleton class:<constant:Stat>> < ::<singleton class:<constant:Object>> ()
    method << (arg0) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<> -> BasicObject
    method <overload N.1 : set_encoding> (int_enc) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument ext_or_ext_int_enc<optional>
      argument int_enc<optional> -> String | Encoding
    method atime () -> Time
    method binmode () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
    method birthtime () -> Time
    method chmod (mode) -> Integer
      argument mode<> -> Integer
    method chown (owner, group) -> Integer
      argument group<> -> Integer
      argument owner<> -> Integer
    method clone () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
    method ctime () -> Time
    method dup () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
    method each (sep, limit, blk) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
      argument limit<optional> -> Integer
      argument sep<optional> -> String
    method each_byte (blk) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method each_char (blk) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
    method each_codepoint (blk) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method flock (arg0) -> Integer | TrueClass | FalseClass
      argument arg0<> -> Integer
    method flush () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
    method freeze () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
    method initialize (file, mode, perm, opt) -> Object
      argument file<> -> String
      argument mode<optional> -> String
      argument opt<optional> -> Integer
      argument perm<optional> -> String
    method lstat () -> File::Stat
    method mtime () -> Time
    method path () -> String
    method set_encoding (ext_or_ext_int_enc) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument ext_or_ext_int_enc<optional> -> String | Encoding
      argument int_enc<optional>
    method size () -> Integer
    method taint () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
    method to_io () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
    method to_path () -> String
    method truncate (arg0) -> Integer
      argument arg0<> -> Integer
    method trust () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
    method untaint () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
    method untrust () -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
    static-field <constant:ALT_SEPARATOR> -> NilClass
    static-field <constant:APPEND> -> Integer
    static-field <constant:BINARY> -> Integer
    static-field <constant:CREAT> -> Integer
    static-field <constant:DIRECT> -> Integer
    static-field <constant:DSYNC> -> Integer
    static-field <constant:EXCL> -> Integer
    static-field <constant:FNM_CASEFOLD> -> Integer
    static-field <constant:FNM_DOTMATCH> -> Integer
    static-field <constant:FNM_EXTGLOB> -> Integer
    static-field <constant:FNM_NOESCAPE> -> Integer
    static-field <constant:FNM_PATHNAME> -> Integer
    static-field <constant:FNM_SHORTNAME> -> Integer
    static-field <constant:FNM_SYSCASE> -> Integer
    static-field <constant:LOCK_EX> -> Integer
    static-field <constant:LOCK_NB> -> Integer
    static-field <constant:LOCK_SH> -> Integer
    static-field <constant:LOCK_UN> -> Integer
    static-field <constant:NOATIME> -> Integer
    static-field <constant:NOCTTY> -> Integer
    static-field <constant:NOFOLLOW> -> Integer
    static-field <constant:NONBLOCK> -> Integer
    static-field <constant:NULL> -> String
    static-field <constant:PATH_SEPARATOR> -> String
    static-field <constant:RDONLY> -> Integer
    static-field <constant:RDWR> -> Integer
    static-field <constant:RSYNC> -> Integer
    static-field <constant:SEEK_CUR> -> Integer
    static-field <constant:SEEK_DATA> -> Integer
    static-field <constant:SEEK_END> -> Integer
    static-field <constant:SEEK_HOLE> -> Integer
    static-field <constant:SEEK_SET> -> Integer
    static-field <constant:SEPARATOR> -> String
    static-field <constant:SHARE_DELETE> -> Integer
    static-field <constant:SYNC> -> Integer
    static-field <constant:TMPFILE> -> Integer
    static-field <constant:TRUNC> -> Integer
    static-field <constant:WRONLY> -> Integer
    typeMember(=) <constant:Elem> -> String
  class <constant:FileTest> (<constant:BasicObject>) -> <Class:FileTest>
  class <constant:FileUtils> (<constant:BasicObject>) -> <Class:FileUtils>
  class <constant:Float> < ::<constant:Numeric> () -> <Class:Float>
    method % (arg0) -> Float
      argument arg0<> -> Integer
    method * (arg0) -> Float
      argument arg0<> -> Integer
    method ** (arg0) -> Float
      argument arg0<> -> Integer
    method + (arg0) -> Float
      argument arg0<> -> Integer
    method +@ () -> Float
    method - (arg0) -> Float
      argument arg0<> -> Integer
    method -@ () -> Float
    method / (arg0) -> Float
      argument arg0<> -> Integer
    method < (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method <= (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method <=> (arg0) -> Object
      argument arg0<> -> Integer
    method <overload N.1 : %> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : **> (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Float
    method <overload N.1 : *> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : +> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : -> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : /> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : <=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : <=>> (arg0) -> Object
      argument arg0<> -> Float
    method <overload N.1 : <> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : >=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : >> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : coerce> (arg0) -> TupleType {
      0 = Float
      1 = Float
    }
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method <overload N.1 : div> (arg0) -> Integer
      argument arg0<> -> Float
    method <overload N.1 : fdiv> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : modulo> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : quo> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : rationalize> (arg0) -> Rational
      argument arg0<optional> -> Integer | Float | Rational | BigDecimal | Complex
    method <overload N.1 : round> (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<optional> -> Integer | Float | Rational | BigDecimal | Complex
    method <overload N.2 : %> (arg0) -> Float
      argument arg0<> -> Rational
    method <overload N.2 : **> (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Rational
    method <overload N.2 : *> (arg0) -> Float
      argument arg0<> -> Rational
    method <overload N.2 : +> (arg0) -> Float
      argument arg0<> -> Rational
    method <overload N.2 : -> (arg0) -> Float
      argument arg0<> -> Rational
    method <overload N.2 : /> (arg0) -> Float
      argument arg0<> -> Rational
    method <overload N.2 : <=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : <=>> (arg0) -> Object
      argument arg0<> -> Rational
    method <overload N.2 : <> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : >=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : >> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : div> (arg0) -> Integer
      argument arg0<> -> Rational
    method <overload N.2 : fdiv> (arg0) -> Float
      argument arg0<> -> Rational
    method <overload N.2 : modulo> (arg0) -> Float
      argument arg0<> -> Rational
    method <overload N.2 : quo> (arg0) -> Float
      argument arg0<> -> Rational
    method <overload N.3 : %> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : **> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : *> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : +> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : -> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : /> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : <=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : <=>> (arg0) -> Object
      argument arg0<> -> BigDecimal
    method <overload N.3 : <> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : >=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : >> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : div> (arg0) -> Integer
      argument arg0<> -> BigDecimal
    method <overload N.3 : fdiv> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : modulo> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : quo> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.4 : **> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : *> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : +> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : -> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : /> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : fdiv> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : quo> (arg0) -> Complex
      argument arg0<> -> Complex
    method == (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method === (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method > (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method >= (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method abs () -> Float
    method abs2 () -> Float
    method angle () -> Integer | Float | Rational | BigDecimal | Complex
    method arg () -> Integer | Float | Rational | BigDecimal | Complex
    method ceil () -> Integer
    method clone () -> Float
    method coerce (arg0) -> TupleType {
      0 = Float
      1 = Float
    }
      argument arg0<> -> Integer | Float | Rational | BigDecimal
    method conj () -> Float
    method conjugate () -> Float
    method denominator () -> Integer
    method div (arg0) -> Integer
      argument arg0<> -> Integer
    method divmod (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    }
      argument arg0<> -> Integer | Float | Rational | BigDecimal
    method dup () -> Float
    method eql? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method equal? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method fdiv (arg0) -> Float
      argument arg0<> -> Integer
    method finite? () -> TrueClass | FalseClass
    method floor () -> Integer
    method freeze () -> Float
    method hash () -> Integer
    method imag () -> Integer
    method imaginary () -> Integer
    method infinite? () -> Object
    method inspect () -> String
    method magnitude () -> Float
    method modulo (arg0) -> Float
      argument arg0<> -> Integer
    method nan? () -> TrueClass | FalseClass
    method next_float () -> Float
    method numerator () -> Integer
    method phase () -> Integer | Float | Rational | BigDecimal | Complex
    method prev_float () -> Float
    method quo (arg0) -> Float
      argument arg0<> -> Integer
    method rationalize () -> Rational
      argument arg0<optional>
    method real () -> Float
    method real? () -> TrueClass
    method round () -> Integer
      argument arg0<optional>
    method taint () -> Float
    method to_c () -> Complex
    method to_f () -> Float
    method to_i () -> Integer
    method to_int () -> Integer
    method to_r () -> Rational
    method to_s () -> String
    method truncate () -> Integer
    method trust () -> Float
    method untaint () -> Float
    method untrust () -> Float
    method zero? () -> TrueClass | FalseClass
    static-field <constant:DIG> -> Integer
    static-field <constant:EPSILON> -> Float
    static-field <constant:INFINITY> -> Float
    static-field <constant:MANT_DIG> -> Integer
    static-field <constant:MAX> -> Float
    static-field <constant:MAX_10_EXP> -> Integer
    static-field <constant:MAX_EXP> -> Integer
    static-field <constant:MIN> -> Float
    static-field <constant:MIN_10_EXP> -> Integer
    static-field <constant:MIN_EXP> -> Integer
    static-field <constant:NAN> -> Float
    static-field <constant:RADIX> -> Integer
    static-field <constant:ROUNDS> -> Integer
  class <constant:FloatDomainError> < ::<constant:RangeError> () -> <Class:FloatDomainError>
    method clone () -> FloatDomainError
    method dup () -> FloatDomainError
    method freeze () -> FloatDomainError
    method taint () -> FloatDomainError
    method trust () -> FloatDomainError
    method untaint () -> FloatDomainError
    method untrust () -> FloatDomainError
  class <constant:Forwardable> (<constant:BasicObject>) -> <Class:Forwardable>
    static-field <constant:FILTER_EXCEPTION> -> String
    static-field <constant:FORWARDABLE_VERSION> -> String
  class <constant:GC> (<constant:BasicObject>) -> <Class:GC>
    class <constant:Profiler> (<constant:BasicObject>) -> <Class:GC::Profiler>
    class <singleton class:<constant:Profiler>> < ::<constant:Module> ()
    static-field <constant:INTERNAL_CONSTANTS> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:OPTS> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
  class <constant:Gem> (<constant:BasicObject>) -> <Class:Gem>
    class <constant:BasicSpecification> < ::<constant:Object> () -> <Class:Gem::BasicSpecification>
    class <constant:CommandLineError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::CommandLineError>
    class <constant:ConfigFile> () -> untyped
    class <constant:ConflictError> < ::<constant:Gem>::<constant:LoadError> () -> <Class:Gem::ConflictError>
    class <constant:Dependency> < ::<constant:Object> () -> <Class:Gem::Dependency>
      static-field <constant:TYPES> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
    class <constant:DependencyError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::DependencyError>
    class <constant:DependencyRemovalException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::DependencyRemovalException>
    class <constant:DependencyResolutionError> < ::<constant:Gem>::<constant:DependencyError> () -> <Class:Gem::DependencyResolutionError>
    class <constant:Deprecate> (<constant:BasicObject>) -> <Class:Gem::Deprecate>
    class <constant:DocumentError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::DocumentError>
    class <constant:EndOfYAMLException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::EndOfYAMLException>
    class <constant:ErrorReason> < ::<constant:Object> () -> <Class:Gem::ErrorReason>
    class <constant:Exception> < ::<constant:RuntimeError> () -> <Class:Gem::Exception>
    class <constant:FilePermissionError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::FilePermissionError>
    class <constant:FormatException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::FormatException>
    class <constant:GemNotFoundException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::GemNotFoundException>
    class <constant:GemNotInHomeException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::GemNotInHomeException>
    class <constant:ImpossibleDependenciesError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::ImpossibleDependenciesError>
    class <constant:InstallError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::InstallError>
    class <constant:InvalidSpecificationException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::InvalidSpecificationException>
    class <constant:List>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Gem::List>
      typeMember(=) <constant:Elem>
    class <constant:LoadError> < ::<constant:LoadError> () -> <Class:Gem::LoadError>
    class <constant:MissingSpecError> < ::<constant:Gem>::<constant:LoadError> () -> <Class:Gem::MissingSpecError>
    class <constant:MissingSpecVersionError> < ::<constant:Gem>::<constant:MissingSpecError> () -> <Class:Gem::MissingSpecVersionError>
    class <constant:OperationNotSupportedError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::OperationNotSupportedError>
    class <constant:PathSupport> < ::<constant:Object> () -> <Class:Gem::PathSupport>
    class <constant:Platform> < ::<constant:Object> () -> <Class:Gem::Platform>
      static-field <constant:CURRENT> -> String
      static-field <constant:RUBY> -> String
    class <constant:PlatformMismatch> < ::<constant:Gem>::<constant:ErrorReason> () -> <Class:Gem::PlatformMismatch>
    class <constant:RemoteError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::RemoteError>
    class <constant:RemoteInstallationCancelled> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::RemoteInstallationCancelled>
    class <constant:RemoteInstallationSkipped> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::RemoteInstallationSkipped>
    class <constant:RemoteSourceException> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::RemoteSourceException>
    class <constant:Requirement> < ::<constant:Object> () -> <Class:Gem::Requirement>
      class <constant:BadRequirementError> < ::<constant:ArgumentError> () -> <Class:Gem::Requirement::BadRequirementError>
      class <singleton class:<constant:BadRequirementError>> < ::<singleton class:<constant:ArgumentError>> ()
      static-field <constant:OPS> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:PATTERN> -> Regexp
      static-field <constant:PATTERN_RAW> -> String
      static-field <constant:SOURCE_SET_REQUIREMENT> -> Object
    class <constant:RubyVersionMismatch> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::RubyVersionMismatch>
    class <constant:SourceFetchProblem> < ::<constant:Gem>::<constant:ErrorReason> () -> <Class:Gem::SourceFetchProblem>
    class <constant:SpecificGemNotFoundException> < ::<constant:Gem>::<constant:GemNotFoundException> () -> <Class:Gem::SpecificGemNotFoundException>
    class <constant:Specification> < ::<constant:Gem>::<constant:BasicSpecification> () -> <Class:Gem::Specification>
      static-field <constant:CURRENT_SPECIFICATION_VERSION> -> Integer
      static-field <constant:EMPTY> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:MARSHAL_FIELDS> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:NONEXISTENT_SPECIFICATION_VERSION> -> Integer
      static-field <constant:NOT_FOUND> -> Object
      static-field <constant:SPECIFICATION_VERSION_HISTORY> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:TODAY> -> Time
      static-field <constant:VALID_NAME_PATTERN> -> Regexp
    class <constant:StubSpecification> < ::<constant:Gem>::<constant:BasicSpecification> () -> <Class:Gem::StubSpecification>
      class <constant:StubLine> < ::<constant:Object> () -> <Class:Gem::StubSpecification::StubLine>
        static-field <constant:NO_EXTENSIONS> -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = untyped
          ]
        }
        static-field <constant:REQUIRE_PATHS> -> AppliedType {
          klass = ::<constant:Hash>
          targs = [
            <constant:K> = untyped
            <constant:V> = untyped
            <constant:Elem> = untyped
          ]
        }
        static-field <constant:REQUIRE_PATH_LIST> -> AppliedType {
          klass = ::<constant:Hash>
          targs = [
            <constant:K> = untyped
            <constant:V> = untyped
            <constant:Elem> = untyped
          ]
        }
      class <singleton class:<constant:StubLine>> < ::<singleton class:<constant:Object>> ()
      static-field <constant:OPEN_MODE> -> String
      static-field <constant:PREFIX> -> String
    class <constant:SystemExitException> < ::<constant:SystemExit> () -> <Class:Gem::SystemExitException>
    class <constant:UnsatisfiableDependencyError> < ::<constant:Gem>::<constant:DependencyError> () -> <Class:Gem::UnsatisfiableDependencyError>
    class <constant:VerificationError> < ::<constant:Gem>::<constant:Exception> () -> <Class:Gem::VerificationError>
    class <constant:Version> < ::<constant:Object> (<constant:Comparable>) -> <Class:Gem::Version>
      static-field <constant:ANCHORED_VERSION_PATTERN> -> Regexp
      static-field <constant:VERSION_PATTERN> -> String
    class <singleton class:<constant:BasicSpecification>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:CommandLineError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:ConflictError>> < ::<constant:Gem>::<singleton class:<constant:LoadError>> ()
    class <singleton class:<constant:Dependency>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:DependencyError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:DependencyRemovalException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:DependencyResolutionError>> < ::<constant:Gem>::<singleton class:<constant:DependencyError>> ()
    class <singleton class:<constant:Deprecate>> < ::<constant:Module> ()
    class <singleton class:<constant:DocumentError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:EndOfYAMLException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:ErrorReason>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:Exception>> < ::<singleton class:<constant:RuntimeError>> ()
    class <singleton class:<constant:FilePermissionError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:FormatException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:GemNotFoundException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:GemNotInHomeException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:ImpossibleDependenciesError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:InstallError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:InvalidSpecificationException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:List>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:LoadError>> < ::<singleton class:<constant:LoadError>> ()
    class <singleton class:<constant:MissingSpecError>> < ::<constant:Gem>::<singleton class:<constant:LoadError>> ()
    class <singleton class:<constant:MissingSpecVersionError>> < ::<constant:Gem>::<singleton class:<constant:MissingSpecError>> ()
    class <singleton class:<constant:OperationNotSupportedError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:PathSupport>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:Platform>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:PlatformMismatch>> < ::<constant:Gem>::<singleton class:<constant:ErrorReason>> ()
    class <singleton class:<constant:RemoteError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:RemoteInstallationCancelled>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:RemoteInstallationSkipped>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:RemoteSourceException>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:Requirement>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:RubyVersionMismatch>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:SourceFetchProblem>> < ::<constant:Gem>::<singleton class:<constant:ErrorReason>> ()
    class <singleton class:<constant:SpecificGemNotFoundException>> < ::<constant:Gem>::<singleton class:<constant:GemNotFoundException>> ()
    class <singleton class:<constant:Specification>> < ::<constant:Gem>::<singleton class:<constant:BasicSpecification>> ()
    class <singleton class:<constant:StubSpecification>> < ::<constant:Gem>::<singleton class:<constant:BasicSpecification>> ()
    class <singleton class:<constant:SystemExitException>> < ::<singleton class:<constant:SystemExit>> ()
    class <singleton class:<constant:UnsatisfiableDependencyError>> < ::<constant:Gem>::<singleton class:<constant:DependencyError>> ()
    class <singleton class:<constant:VerificationError>> < ::<constant:Gem>::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:Version>> < ::<singleton class:<constant:Object>> ()
    static-field <constant:DEFAULT_HOST> -> String
    static-field <constant:GEM_DEP_FILES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:GEM_PRELUDE_SUCKAGE> -> NilClass
    static-field <constant:LOADED_SPECS_MUTEX> -> Thread::Mutex
    static-field <constant:MARSHAL_SPEC_DIR> -> String
    static-field <constant:READ_BINARY_ERRORS> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:REPOSITORY_DEFAULT_GEM_SUBDIRECTORIES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:REPOSITORY_SUBDIRECTORIES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:RUBYGEMS_DIR> -> String
    static-field <constant:VERSION> -> String
    static-field <constant:WIN_PATTERNS> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:WRITE_BINARY_ERRORS> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
  class <constant:Hash>[<constant:K>, <constant:V>, <constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Hash>
    method <overload N.1 : default> (arg0, blk) -> LambdaParam(::<constant:Hash>#<constant:V>)
      argument arg0<optional> -> LambdaParam(::<constant:Hash>#<constant:K>)
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Hash>#<constant:V>)
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
        ]
      }
    method <overload N.1 : delete> (arg0, blk) -> untyped
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>)
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
        ]
      }
    method <overload N.1 : delete_if> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    }
      argument blk<block>
    method <overload N.1 : each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    }
      argument blk<block>
    method <overload N.1 : each_key> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    }
      argument blk<block>
    method <overload N.1 : each_pair> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    }
      argument blk<block>
    method <overload N.1 : each_value> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    }
      argument blk<block>
    method <overload N.1 : fetch> (arg0, arg1) -> LambdaParam(::<constant:Hash>#<constant:V>)
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>)
      argument arg1<optional> -> LambdaParam(::<constant:Hash>#<constant:V>)
      argument blk<block>
    method <overload N.1 : keep_if> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    }
      argument blk<block>
    method <overload N.1 : merge> (arg0, blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = BasicObject
          <constant:V> = BasicObject
          <constant:Elem> = untyped
        ]
      }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc3>
        targs = [
          <constant:Return> = BasicObject | LambdaParam(::<constant:Hash>#<constant:V>)
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
          <constant:Arg2> = untyped
        ]
      }
    method <overload N.1 : reject> (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      }
    method <overload N.2 : fetch> (arg0, blk) -> LambdaParam(::<constant:Hash>#<constant:V>)
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>)
      argument arg1<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Hash>#<constant:V>)
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
        ]
      }
    method [] (arg0) -> LambdaParam(::<constant:Hash>#<constant:V>)
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>)
    method []= (arg0, arg1) -> LambdaParam(::<constant:Hash>#<constant:V>)
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>)
      argument arg1<> -> LambdaParam(::<constant:Hash>#<constant:V>)
    method assoc (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:K>) | LambdaParam(::<constant:Hash>#<constant:V>)
      ]
    }
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>)
    method clear () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
    method clone () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    method compare_by_identity () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
    method compare_by_identity? () -> TrueClass | FalseClass
    method default (arg0) -> LambdaParam(::<constant:Hash>#<constant:V>)
      argument arg0<optional> -> LambdaParam(::<constant:Hash>#<constant:K>)
      argument blk<block>
    method default= (arg0) -> LambdaParam(::<constant:Hash>#<constant:V>)
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:V>)
    method delete (arg0) -> LambdaParam(::<constant:Hash>#<constant:V>)
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>)
      argument blk<block>
    method delete_if (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      }
    method dup () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    method each (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      }
    method each_key (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
        ]
      }
    method each_pair (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      }
    method each_value (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      }
    method empty? () -> TrueClass | FalseClass
    method fetch (arg0) -> LambdaParam(::<constant:Hash>#<constant:V>)
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>)
      argument arg1<optional>
      argument blk<block>
    method freeze () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    method has_key? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method has_value? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method inspect () -> String
    method invert () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:Elem> = untyped
      ]
    }
    method keep_if (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      }
    method key (arg0) -> LambdaParam(::<constant:Hash>#<constant:K>)
      argument arg0<> -> BasicObject
    method key? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method keys () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:K>)
      ]
    }
    method length () -> Integer
    method member? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method merge (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = BasicObject
          <constant:V> = BasicObject
          <constant:Elem> = untyped
        ]
      }
      argument blk<block>
    method rassoc (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:K>) | LambdaParam(::<constant:Hash>#<constant:V>)
      ]
    }
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>)
    method rehash () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
    method reject () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = TupleType {
            0 = LambdaParam(::<constant:Hash>#<constant:K>)
            1 = LambdaParam(::<constant:Hash>#<constant:V>)
          }
      ]
    }
      argument blk<block>
    method reject! (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      }
    method select (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      }
    method select! (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Hash>#<constant:K>)
          <constant:Arg1> = LambdaParam(::<constant:Hash>#<constant:V>)
        ]
      }
    method shift () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:K>) | LambdaParam(::<constant:Hash>#<constant:V>)
      ]
    }
    method size () -> Integer
    method store (arg0, arg1) -> LambdaParam(::<constant:Hash>#<constant:V>)
      argument arg0<> -> LambdaParam(::<constant:Hash>#<constant:K>)
      argument arg1<> -> LambdaParam(::<constant:Hash>#<constant:V>)
    method taint () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    method to_a () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:K>) | LambdaParam(::<constant:Hash>#<constant:V>)
            ]
          }
      ]
    }
    method to_hash () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = LambdaParam(::<constant:Hash>#<constant:K>)
        <constant:V> = LambdaParam(::<constant:Hash>#<constant:V>)
        <constant:Elem> = untyped
      ]
    }
    method to_s () -> String
    method trust () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    method untaint () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    method untrust () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    method value? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method values () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:V>)
      ]
    }
    method values_at (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Hash>#<constant:V>)
      ]
    }
      argument arg0<repeated> -> LambdaParam(::<constant:Hash>#<constant:K>)
    typeMember(=) <constant:Elem>
    typeMember(=) <constant:K>
    typeMember(=) <constant:V>
  class <constant:IO>[<constant:Elem>] < ::<constant:Object> (<constant:Constants>, <constant:Enumerable>) -> <Class:IO>
    class <constant:EAGAINWaitReadable> < ::<constant:Errno>::<constant:EAGAIN> (<constant:WaitReadable>) -> <Class:IO::EAGAINWaitReadable>
    class <constant:EAGAINWaitWritable> < ::<constant:Errno>::<constant:EAGAIN> (<constant:WaitWritable>) -> <Class:IO::EAGAINWaitWritable>
    class <constant:EINPROGRESSWaitReadable> < ::<constant:Errno>::<constant:EINPROGRESS> (<constant:WaitReadable>) -> <Class:IO::EINPROGRESSWaitReadable>
    class <constant:EINPROGRESSWaitWritable> < ::<constant:Errno>::<constant:EINPROGRESS> (<constant:WaitWritable>) -> <Class:IO::EINPROGRESSWaitWritable>
    class <constant:WaitReadable> (<constant:BasicObject>) -> <Class:IO::WaitReadable>
    class <constant:WaitWritable> (<constant:BasicObject>) -> <Class:IO::WaitWritable>
    class <singleton class:<constant:EAGAINWaitReadable>> < ::<constant:Errno>::<singleton class:<constant:EAGAIN>> ()
    class <singleton class:<constant:EAGAINWaitWritable>> < ::<constant:Errno>::<singleton class:<constant:EAGAIN>> ()
    class <singleton class:<constant:EINPROGRESSWaitReadable>> < ::<constant:Errno>::<singleton class:<constant:EINPROGRESS>> ()
    class <singleton class:<constant:EINPROGRESSWaitWritable>> < ::<constant:Errno>::<singleton class:<constant:EINPROGRESS>> ()
    class <singleton class:<constant:WaitReadable>> < ::<constant:Module> ()
    class <singleton class:<constant:WaitWritable>> < ::<constant:Module> ()
    method << (arg0) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<> -> BasicObject
    method <overload N.1 : bytes> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    }
      argument blk<block>
    method <overload N.1 : chars> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block>
    method <overload N.1 : codepoints> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    }
      argument blk<block>
    method <overload N.1 : each> (sep, limit) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block>
      argument limit<optional> -> Integer
      argument sep<optional> -> String
    method <overload N.1 : each_byte> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    }
      argument blk<block>
    method <overload N.1 : each_char> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block>
    method <overload N.1 : each_codepoint> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    }
      argument blk<block>
    method <overload N.1 : each_line> (sep, limit) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block>
      argument limit<optional> -> Integer
      argument sep<optional> -> String
    method <overload N.1 : lines> (sep, limit) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block>
      argument limit<optional> -> Integer
      argument sep<optional> -> String
    method <overload N.1 : read_nonblock> (len, buf) -> String
      argument buf<optional> -> String
      argument len<> -> Integer
    method <overload N.1 : readpartial> (maxlen, outbuf) -> String
      argument maxlen<> -> Integer
      argument outbuf<optional> -> String
    method <overload N.1 : reopen> (mode_str) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument mode_str<optional> -> String
      argument other_IO<>
    method <overload N.1 : set_encoding> (int_enc) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument ext_or_ext_int_enc<optional>
      argument int_enc<optional> -> String | Encoding
    method advise (arg0, offset, len) -> NilClass
      argument arg0<> -> Symbol
      argument len<optional> -> Integer
      argument offset<optional> -> Integer
    method autoclose= (arg0) -> TrueClass | FalseClass
      argument arg0<> -> TrueClass | FalseClass
    method autoclose? () -> TrueClass | FalseClass
    method binmode () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method binmode? () -> TrueClass | FalseClass
    method bytes (blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method chars (blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
    method clone () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method close () -> NilClass
    method close_on_exec= (arg0) -> TrueClass | FalseClass
      argument arg0<> -> TrueClass | FalseClass
    method close_on_exec? () -> TrueClass | FalseClass
    method close_read () -> NilClass
    method close_write () -> NilClass
    method closed? () -> TrueClass | FalseClass
    method codepoints (blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method dup () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method each (sep, limit, blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
      argument limit<optional> -> Integer
      argument sep<optional> -> String
    method each_byte (blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method each_char (blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
    method each_codepoint (blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method each_line (sep, limit, blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
      argument limit<optional> -> Integer
      argument sep<optional> -> String
    method eof () -> TrueClass | FalseClass
    method eof? () -> TrueClass | FalseClass
    method fcntl (integer_cmd, arg) -> Integer
      argument arg<> -> String | Integer
      argument integer_cmd<> -> Integer
    method fdatasync () -> Integer | NilClass
    method fileno () -> Integer
    method flush () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method freeze () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method fsync () -> Integer | NilClass
    method getbyte () -> Integer | NilClass
    method getc () -> String | NilClass
    method gets (sep, limit) -> String | NilClass
      argument limit<optional> -> Integer
      argument sep<optional> -> String
    method initialize (fd, mode, opt) -> Object
      argument fd<> -> Integer
      argument mode<optional> -> Integer
      argument opt<optional> -> Integer
    method inspect () -> String
    method internal_encoding () -> Encoding
    method ioctl (integer_cmd, arg) -> Integer
      argument arg<> -> String | Integer
      argument integer_cmd<> -> Integer
    method isatty () -> TrueClass | FalseClass
    method lineno () -> Integer
    method lineno= (arg0) -> Integer
      argument arg0<> -> Integer
    method lines (sep, limit, blk) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
      argument limit<optional> -> Integer
      argument sep<optional> -> String
    method pid () -> Integer
    method pos () -> Integer
    method pos= (arg0) -> Integer
      argument arg0<> -> Integer
    method print (arg0) -> NilClass
      argument arg0<repeated> -> BasicObject
    method printf (format_string, arg0) -> NilClass
      argument arg0<repeated> -> BasicObject
      argument format_string<> -> String
    method putc (arg0) -> untyped
      argument arg0<> -> Numeric | String
    method puts (arg0) -> NilClass
      argument arg0<repeated> -> BasicObject
    method read (length, outbuf) -> String | NilClass
      argument length<optional> -> Integer
      argument outbuf<optional> -> String
    method read_nonblock (len) -> String
      argument buf<optional>
      argument len<> -> Integer
    method readbyte () -> Integer
    method readchar () -> String
    method readline (sep, limit) -> String
      argument limit<optional> -> Integer
      argument sep<optional> -> String
    method readlines (sep, limit) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument limit<optional> -> Integer
      argument sep<optional> -> String
    method readpartial (maxlen) -> String
      argument maxlen<> -> Integer
      argument outbuf<optional>
    method reopen (other_IO) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument mode_str<optional>
      argument other_IO<> -> AppliedType {
        klass = ::<constant:IO>
        targs = [
          <constant:Elem> = String
        ]
      }
    method rewind () -> Integer
    method seek (amount, whence) -> Integer
      argument amount<> -> Integer
      argument whence<optional> -> Integer
    method set_encoding (ext_or_ext_int_enc) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument ext_or_ext_int_enc<optional> -> String | Encoding
      argument int_enc<optional>
    method stat () -> File::Stat
    method sync () -> TrueClass | FalseClass
    method sync= (arg0) -> TrueClass | FalseClass
      argument arg0<> -> TrueClass | FalseClass
    method sysread (maxlen, outbuf) -> String
      argument maxlen<> -> Integer
      argument outbuf<> -> String
    method sysseek (amount, whence) -> Integer
      argument amount<> -> Integer
      argument whence<optional> -> Integer
    method syswrite (arg0) -> Integer
      argument arg0<> -> String
    method taint () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method tell () -> Integer
    method to_i () -> Integer
    method to_io () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method trust () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method tty? () -> TrueClass | FalseClass
    method ungetbyte (arg0) -> NilClass
      argument arg0<> -> String | Integer
    method ungetc (arg0) -> NilClass
      argument arg0<> -> String
    method untaint () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method untrust () -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method write (arg0) -> Integer
      argument arg0<> -> String
    static-field <constant:APPEND> -> Integer
    static-field <constant:BINARY> -> Integer
    static-field <constant:CREAT> -> Integer
    static-field <constant:DIRECT> -> Integer
    static-field <constant:DSYNC> -> Integer
    static-field <constant:EXCL> -> Integer
    static-field <constant:FNM_CASEFOLD> -> Integer
    static-field <constant:FNM_DOTMATCH> -> Integer
    static-field <constant:FNM_EXTGLOB> -> Integer
    static-field <constant:FNM_NOESCAPE> -> Integer
    static-field <constant:FNM_PATHNAME> -> Integer
    static-field <constant:FNM_SHORTNAME> -> Integer
    static-field <constant:FNM_SYSCASE> -> Integer
    static-field <constant:LOCK_EX> -> Integer
    static-field <constant:LOCK_NB> -> Integer
    static-field <constant:LOCK_SH> -> Integer
    static-field <constant:LOCK_UN> -> Integer
    static-field <constant:NOATIME> -> Integer
    static-field <constant:NOCTTY> -> Integer
    static-field <constant:NOFOLLOW> -> Integer
    static-field <constant:NONBLOCK> -> Integer
    static-field <constant:NULL> -> String
    static-field <constant:RDONLY> -> Integer
    static-field <constant:RDWR> -> Integer
    static-field <constant:RSYNC> -> Integer
    static-field <constant:SEEK_CUR> -> Integer
    static-field <constant:SEEK_DATA> -> Integer
    static-field <constant:SEEK_END> -> Integer
    static-field <constant:SEEK_HOLE> -> Integer
    static-field <constant:SEEK_SET> -> Integer
    static-field <constant:SHARE_DELETE> -> Integer
    static-field <constant:SYNC> -> Integer
    static-field <constant:TMPFILE> -> Integer
    static-field <constant:TRUNC> -> Integer
    static-field <constant:WRONLY> -> Integer
    typeMember(=) <constant:Elem> -> String
  class <constant:IOError> < ::<constant:StandardError> () -> <Class:IOError>
    method clone () -> IOError
    method dup () -> IOError
    method freeze () -> IOError
    method taint () -> IOError
    method trust () -> IOError
    method untaint () -> IOError
    method untrust () -> IOError
  class <constant:IndexError> < ::<constant:StandardError> () -> <Class:IndexError>
    method clone () -> IndexError
    method dup () -> IndexError
    method freeze () -> IndexError
    method taint () -> IndexError
    method trust () -> IndexError
    method untaint () -> IndexError
    method untrust () -> IndexError
  class <constant:Integer> < ::<constant:Numeric> () -> <Class:Integer>
    method % (arg0) -> Integer
      argument arg0<> -> Integer
    method & (arg0) -> Integer
      argument arg0<> -> Integer
    method * (arg0) -> Integer
      argument arg0<> -> Integer
    method ** (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Integer
    method + (arg0) -> Integer
      argument arg0<> -> Integer
    method +@ () -> Integer
    method - (arg0) -> Integer
      argument arg0<> -> Integer
    method -@ () -> Integer
    method / (arg0) -> Integer
      argument arg0<> -> Integer
    method < (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method << (arg0) -> Integer
      argument arg0<> -> Integer
    method <= (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method <=> (arg0) -> Object
      argument arg0<> -> Integer
    method <overload N.1 : %> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : **> (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Float
    method <overload N.1 : *> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : +> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : -> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : /> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : <=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : <=>> (arg0) -> Object
      argument arg0<> -> Float
    method <overload N.1 : <> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : >=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : >> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : []> (arg0) -> Integer
      argument arg0<> -> Rational
    method <overload N.1 : div> (arg0) -> Integer
      argument arg0<> -> Float
    method <overload N.1 : downto> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    }
      argument arg0<>
      argument blk<block>
    method <overload N.1 : fdiv> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : modulo> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : quo> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : rationalize> (arg0) -> Rational
      argument arg0<optional> -> Integer | Float | Rational | BigDecimal | Complex
    method <overload N.1 : remainder> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : round> (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<optional> -> Integer | Float | Rational | BigDecimal | Complex
    method <overload N.1 : times> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    }
      argument blk<block>
    method <overload N.1 : upto> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer
      ]
    }
      argument arg0<> -> Integer
      argument blk<block>
    method <overload N.2 : %> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.2 : **> (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Rational
    method <overload N.2 : *> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.2 : +> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.2 : -> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.2 : /> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.2 : <=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : <=>> (arg0) -> Object
      argument arg0<> -> Rational
    method <overload N.2 : <> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : >=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : >> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : []> (arg0) -> Integer
      argument arg0<> -> Float
    method <overload N.2 : div> (arg0) -> Integer
      argument arg0<> -> Rational
    method <overload N.2 : fdiv> (arg0) -> Float
      argument arg0<> -> Rational
    method <overload N.2 : modulo> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.2 : quo> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.2 : remainder> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.3 : %> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : **> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : *> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : +> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : -> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : /> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : <=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : <=>> (arg0) -> Object
      argument arg0<> -> BigDecimal
    method <overload N.3 : <> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : >=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : >> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : []> (arg0) -> Integer
      argument arg0<> -> BigDecimal
    method <overload N.3 : div> (arg0) -> Integer
      argument arg0<> -> BigDecimal
    method <overload N.3 : fdiv> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : modulo> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : quo> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : remainder> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.4 : **> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : *> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : +> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : -> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : /> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : fdiv> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : quo> (arg0) -> Complex
      argument arg0<> -> Complex
    method == (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method === (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method > (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method >= (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method >> (arg0) -> Integer
      argument arg0<> -> Integer
    method [] (arg0) -> Integer
      argument arg0<> -> Integer
    method ^ (arg0) -> Integer
      argument arg0<> -> Integer
    method abs () -> Integer
    method abs2 () -> Integer
    method angle () -> Integer | Float | Rational | BigDecimal | Complex
    method arg () -> Integer | Float | Rational | BigDecimal | Complex
    method bit_length () -> Integer
    method ceil () -> Integer
    method chr (arg0) -> String
      argument arg0<> -> Encoding
    method clone () -> Integer
    method coerce (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    }
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method conj () -> Integer
    method conjugate () -> Integer
    method denominator () -> Integer
    method div (arg0) -> Integer
      argument arg0<> -> Integer
    method divmod (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    }
      argument arg0<> -> Integer | Float | Rational | BigDecimal
    method downto (arg0, blk) -> Integer
      argument arg0<> -> Integer
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method dup () -> Integer
    method eql? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method equal? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method even? () -> TrueClass | FalseClass
    method fdiv (arg0) -> Float
      argument arg0<> -> Integer
    method floor () -> Integer
    method freeze () -> Integer
    method gcd (arg0) -> Integer
      argument arg0<> -> Integer
    method gcdlcm (arg0) -> TupleType {
      0 = Integer
      1 = Integer
    }
      argument arg0<> -> Integer
    method hash () -> Integer
    method imag () -> Integer
    method imaginary () -> Integer
    method inspect () -> String
    method integer? () -> TrueClass
    method lcm (arg0) -> Integer
      argument arg0<> -> Integer
    method magnitude () -> Integer
    method modulo (arg0) -> Integer
      argument arg0<> -> Integer
    method next () -> Integer
    method numerator () -> Integer
    method odd? () -> TrueClass | FalseClass
    method ord () -> Integer
    method phase () -> Integer | Float | Rational | BigDecimal | Complex
    method pred () -> Integer
    method quo (arg0) -> Rational
      argument arg0<> -> Integer
    method rationalize () -> Rational
      argument arg0<optional>
    method real () -> Integer
    method real? () -> TrueClass
    method remainder (arg0) -> Integer
      argument arg0<> -> Integer
    method round () -> Integer
      argument arg0<optional>
    method size () -> Integer
    method succ () -> Integer
    method taint () -> Integer
    method times (blk) -> Integer
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method to_c () -> Complex
    method to_f () -> Float
    method to_i () -> Integer
    method to_int () -> Integer
    method to_r () -> Rational
    method to_s () -> String
    method truncate () -> Integer
    method trust () -> Integer
    method untaint () -> Integer
    method untrust () -> Integer
    method upto (arg0, blk) -> Integer
      argument arg0<> -> Integer
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method zero? () -> TrueClass | FalseClass
    method | (arg0) -> Integer
      argument arg0<> -> Integer
    method ~ () -> Integer
  class <constant:Interrupt> < ::<constant:SignalException> () -> <Class:Interrupt>
    method clone () -> Interrupt
    method dup () -> Interrupt
    method freeze () -> Interrupt
    method taint () -> Interrupt
    method trust () -> Interrupt
    method untaint () -> Interrupt
    method untrust () -> Interrupt
  class <constant:Kernel> (<constant:BasicObject>) -> <Class:Kernel>
    method <overload N.1 : Complex> (x) -> Complex
      argument x<> -> String
      argument y<optional>
    method <overload N.1 : Rational> (x) -> Rational
      argument x<> -> Object
      argument y<optional>
    method <overload N.1 : exit> (status) -> NilClass
      argument status<optional> -> Integer | TrueClass | FalseClass
    method <overload N.1 : fail> (arg0) -> NilClass
      argument arg0<optional> -> String
      argument arg1<optional>
      argument arg2<optional>
    method <overload N.1 : raise> (arg0) -> NilClass
      argument arg0<optional> -> String
      argument arg1<optional>
      argument arg2<optional>
    method <overload N.1 : send> (arg0, arg1, blk) -> untyped
      argument arg0<> -> String | Symbol
      argument arg1<repeated> -> BasicObject
      argument blk<block> -> BasicObject
    method <overload N.2 : fail> (arg0, arg1) -> NilClass
      argument arg0<optional> -> Class
      argument arg1<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      }
      argument arg2<optional>
    method <overload N.2 : raise> (arg0, arg1, arg2) -> NilClass
      argument arg0<optional> -> Class
      argument arg1<optional> -> String
      argument arg2<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      }
    method <overload N.3 : fail> (arg0, arg1, arg2) -> NilClass
      argument arg0<optional> -> Class
      argument arg1<optional> -> String
      argument arg2<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      }
    method <overload N.3 : raise> (arg0, arg1, arg2) -> NilClass
      argument arg0<optional> -> Exception
      argument arg1<optional> -> String
      argument arg2<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      }
    method Array (x) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument x<> -> Object
    method Complex (x, y) -> Complex
      argument x<> -> Numeric
      argument y<optional> -> Numeric
    method Float (x) -> Float
      argument x<> -> Numeric
    method Hash (x) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument x<> -> Object
    method Integer (arg, base) -> Integer
      argument arg<> -> Numeric | String
      argument base<optional> -> Integer
    method Rational (x, y) -> Rational
      argument x<> -> Numeric
      argument y<optional> -> Numeric
    method String (x) -> String
      argument x<> -> Object
    method __callee__ () -> Symbol | NilClass
    method __dir__ () -> String | NilClass
    method __method__ () -> Symbol | NilClass
    method ` (arg0) -> String
      argument arg0<> -> String
    method abort (msg) -> NilClass
      argument msg<optional> -> String
    method at_exit (blk) -> Proc
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc0>
        targs = [
          <constant:Return> = BasicObject
        ]
      }
    method autoload (_module, filename) -> NilClass
      argument _module<> -> String | Symbol
      argument filename<> -> String
    method autoload? (name) -> String | NilClass
      argument name<> -> Symbol | String
    method binding () -> Binding
    method clone () -> Kernel
    method configatron ()
    method exit () -> NilClass
      argument status<optional>
    method exit! (status) -> NilClass
      argument status<> -> Integer | TrueClass | FalseClass
    method fail () -> NilClass
      argument arg0<optional>
      argument arg1<optional>
      argument arg2<optional>
    method format (format, args) -> String
      argument args<repeated> -> BasicObject
      argument format<> -> String
    method gets (arg0, arg1) -> String
      argument arg0<optional> -> String
      argument arg1<optional> -> Integer
    method global_variables () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
    method hard_assert (predicate, msg, opts) -> NilClass
      argument msg<optional> -> String | NilClass
      argument opts<keyword, repeated> -> untyped
      argument predicate<> -> TrueClass | FalseClass
    method load (filename, arg0) -> TrueClass | FalseClass
      argument arg0<optional> -> TrueClass | FalseClass
      argument filename<> -> String
    method open (name, rest, block) -> AppliedType {
          klass = ::<constant:IO>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass
      argument block<optional> -> String
      argument name<> -> String
      argument rest<optional> -> String | Integer
    method printf (arg0, arg1, arg2) -> NilClass
      argument arg0<optional> -> AppliedType {
        klass = ::<constant:IO>
        targs = [
          <constant:Elem> = String
        ]
      }
      argument arg1<optional> -> String
      argument arg2<repeated> -> BasicObject
    method proc (blk) -> Proc
      argument blk<block> -> BasicObject
    method putc (arg0) -> Integer
      argument arg0<> -> Integer
    method puts (arg0) -> NilClass
      argument arg0<repeated> -> BasicObject
    method raise () -> NilClass
      argument arg0<optional>
      argument arg1<optional>
      argument arg2<optional>
    method readline (arg0, arg1) -> String
      argument arg0<optional> -> String
      argument arg1<optional> -> Integer
    method readlines (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<optional> -> String
      argument arg1<optional> -> Integer
    method require (path) -> TrueClass | FalseClass
      argument path<> -> String
    method require_relative (feature) -> TrueClass | FalseClass
      argument feature<> -> String
    method select (read, write, error, timeout) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument error<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
      argument read<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
      argument timeout<optional> -> Integer
      argument write<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
    method send (arg0, arg1) -> untyped
      argument arg0<> -> String | Symbol
      argument arg1<repeated> -> BasicObject
      argument blk<block>
    method sleep (duration) -> Integer
      argument duration<> -> Numeric
    method sprintf (format, args) -> String
      argument args<repeated> -> BasicObject
      argument format<> -> String
    method syscall (num, args) -> untyped
      argument args<repeated> -> BasicObject
      argument num<> -> Integer
    method test (cmd, file1, file2) -> TrueClass | FalseClass | Time
      argument cmd<> -> String
      argument file1<> -> String
      argument file2<optional> -> String
    method to_s () -> String
    method warn (msg) -> NilClass
      argument msg<repeated> -> String
    static-field <constant:RUBYGEMS_ACTIVATION_MONITOR> -> Monitor
  class <constant:KeyError> < ::<constant:IndexError> () -> <Class:KeyError>
    method clone () -> KeyError
    method dup () -> KeyError
    method freeze () -> KeyError
    method taint () -> KeyError
    method trust () -> KeyError
    method untaint () -> KeyError
    method untrust () -> KeyError
  class <constant:LoadError> < ::<constant:ScriptError> () -> <Class:LoadError>
    method clone () -> LoadError
    method dup () -> LoadError
    method freeze () -> LoadError
    method taint () -> LoadError
    method trust () -> LoadError
    method untaint () -> LoadError
    method untrust () -> LoadError
  class <constant:LocalJumpError> < ::<constant:StandardError> () -> <Class:LocalJumpError>
    method clone () -> LocalJumpError
    method dup () -> LocalJumpError
    method freeze () -> LocalJumpError
    method taint () -> LocalJumpError
    method trust () -> LocalJumpError
    method untaint () -> LocalJumpError
    method untrust () -> LocalJumpError
  class <constant:Marshal> (<constant:BasicObject>) -> <Class:Marshal>
    static-field <constant:MAJOR_VERSION> -> Integer
    static-field <constant:MINOR_VERSION> -> Integer
  class <constant:MatchData> < ::<constant:Object> () -> <Class:MatchData>
    method <overload N.1 : []> (length) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument i<>
      argument length<optional> -> Integer
    method <overload N.2 : []> () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument i<>
      argument length<optional>
    method <overload N.3 : []> () -> String | NilClass
      argument i<>
      argument length<optional>
    method == (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method [] (i) -> String | NilClass
      argument i<> -> Integer
      argument length<optional>
    method begin (n) -> Integer
      argument n<> -> Integer
    method captures () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
    method clone () -> MatchData
    method dup () -> MatchData
    method end (n) -> Integer
      argument n<> -> Integer
    method eql? (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method freeze () -> MatchData
    method hash () -> Integer
    method inspect () -> String
    method length () -> Integer
    method names () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
    method offset (n) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    }
      argument n<> -> Integer
    method post_match () -> String
    method pre_match () -> String
    method regexp () -> Regexp
    method size () -> Integer
    method string () -> String
    method taint () -> MatchData
    method to_a () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
    method to_s () -> String
    method trust () -> MatchData
    method untaint () -> MatchData
    method untrust () -> MatchData
    method values_at (indexes) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument indexes<repeated> -> Integer
  class <constant:Math> (<constant:BasicObject>) -> <Class:Math>
    class <constant:DomainError> < ::<constant:StandardError> () -> <Class:Math::DomainError>
    class <singleton class:<constant:DomainError>> < ::<singleton class:<constant:StandardError>> ()
    static-field <constant:E> -> Float
    static-field <constant:PI> -> Float
  class <constant:Method> < ::<constant:Object> () -> <Class:Method>
    method clone () -> Method
    method dup () -> Method
    method freeze () -> Method
    method taint () -> Method
    method trust () -> Method
    method untaint () -> Method
    method untrust () -> Method
  class <constant:Module> < ::<constant:Object> () -> <Class:Module>
    method < (other) -> TrueClass | FalseClass | NilClass
      argument other<> -> Module
    method <= (other) -> TrueClass | FalseClass | NilClass
      argument other<> -> Module
    method <=> (other) -> Integer | NilClass
      argument other<> -> Module
    method <overload N.1 : define_method> (arg0, blk) -> Symbol
      argument arg0<> -> Symbol
      argument arg1<optional>
      argument blk<block> -> BasicObject
    method <overload N.1 : initialize> (blk) -> Object
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Module
        ]
      }
    method == (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method === (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method > (other) -> TrueClass | FalseClass | NilClass
      argument other<> -> Module
    method >= (other) -> TrueClass | FalseClass | NilClass
      argument other<> -> Module
    method alias_method (new_name, old_name) -> Module
      argument new_name<> -> Symbol
      argument old_name<> -> Symbol
    method ancestors () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Module
      ]
    }
    method append_features (arg0) -> Module
      argument arg0<> -> Module
    method attr (arg0) -> NilClass
      argument arg0<repeated> -> Symbol | String
    method attr_accessor (arg0) -> NilClass
      argument arg0<repeated> -> Symbol | String
    method attr_reader (arg0) -> NilClass
      argument arg0<repeated> -> Symbol | String
    method attr_writer (arg0) -> NilClass
      argument arg0<repeated> -> Symbol | String
    method autoload (_module, filename) -> NilClass
      argument _module<> -> Symbol
      argument filename<> -> String
    method autoload? (name) -> String | NilClass
      argument name<> -> Symbol
    method class_eval (arg0, filename, lineno) -> untyped
      argument arg0<> -> String
      argument filename<optional> -> String
      argument lineno<optional> -> Integer
    method class_exec (args, blk) -> untyped
      argument args<repeated> -> BasicObject
      argument blk<block> -> BasicObject
    method class_variable_defined? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Symbol | String
    method class_variable_get (arg0) -> untyped
      argument arg0<> -> Symbol | String
    method class_variable_set (arg0, arg1) -> untyped
      argument arg0<> -> Symbol | String
      argument arg1<> -> BasicObject
    method class_variables (inherit) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
      argument inherit<optional> -> TrueClass | FalseClass
    method clone () -> Module
    method const_defined? (arg0, inherit) -> TrueClass | FalseClass
      argument arg0<> -> Symbol | String
      argument inherit<optional> -> TrueClass | FalseClass
    method const_get (arg0, inherit) -> untyped
      argument arg0<> -> Symbol | String
      argument inherit<optional> -> TrueClass | FalseClass
    method const_missing (arg0) -> untyped
      argument arg0<> -> Symbol
    method const_set (arg0, arg1) -> untyped
      argument arg0<> -> Symbol | String
      argument arg1<> -> BasicObject
    method constants (inherit) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
      argument inherit<optional> -> TrueClass | FalseClass
    method define_method (arg0, arg1) -> Symbol
      argument arg0<> -> Symbol
      argument arg1<optional> -> Method
      argument blk<block>
    method dup () -> Module
    method eql? (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method equal? (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method extend_object (arg0) -> untyped
      argument arg0<> -> BasicObject
    method extended (othermod) -> untyped
      argument othermod<> -> Module
    method freeze () -> Module
    method include (arg0) -> Module
      argument arg0<repeated> -> Module
    method include? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Module
    method included (othermod) -> untyped
      argument othermod<> -> Module
    method included_modules () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Module
      ]
    }
    method initialize () -> Object
      argument blk<block>
    method inspect () -> String
    method instance_method (arg0) -> UnboundMethod
      argument arg0<> -> Symbol
    method instance_methods (include_super) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
      argument include_super<optional> -> TrueClass | FalseClass
    method method_added (meth) -> untyped
      argument meth<> -> Symbol
    method method_defined? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Symbol | String
    method method_removed (method_name) -> untyped
      argument method_name<> -> Symbol
    method module_eval (arg0, filename, lineno) -> untyped
      argument arg0<> -> String
      argument filename<optional> -> String
      argument lineno<optional> -> Integer
    method module_exec (args, blk) -> untyped
      argument args<repeated> -> BasicObject
      argument blk<block> -> BasicObject
    method module_function (arg0) -> Module
      argument arg0<repeated> -> Symbol | String
    method name () -> String
    method prepend (arg0) -> Module
      argument arg0<repeated> -> Module
    method prepend_features (arg0) -> Module
      argument arg0<> -> Module
    method prepended (othermod) -> untyped
      argument othermod<> -> Module
    method private (arg0) -> Module
      argument arg0<repeated> -> Symbol | String
    method private_class_method (arg0) -> Module
      argument arg0<repeated> -> Symbol | String
    method private_constant (arg0) -> Module
      argument arg0<repeated> -> Symbol
    method private_instance_methods (include_super) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
      argument include_super<optional> -> TrueClass | FalseClass
    method private_method_defined? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Symbol | String
    method protected (arg0) -> Module
      argument arg0<repeated> -> Symbol | String
    method protected_instance_methods (include_super) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
      argument include_super<optional> -> TrueClass | FalseClass
    method protected_method_defined? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Symbol | String
    method public (arg0) -> Module
      argument arg0<repeated> -> Symbol | String
    method public_class_method (arg0) -> Module
      argument arg0<repeated> -> Symbol | String
    method public_constant (arg0) -> Module
      argument arg0<repeated> -> Symbol
    method public_instance_method (arg0) -> UnboundMethod
      argument arg0<> -> Symbol
    method public_instance_methods (include_super) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
      argument include_super<optional> -> TrueClass | FalseClass
    method public_method_defined? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Symbol | String
    method refine (arg0, blk) -> Module
      argument arg0<> -> Class
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = untyped
        ]
      }
    method remove_class_variable (arg0) -> untyped
      argument arg0<> -> Symbol
    method remove_const (arg0) -> untyped
      argument arg0<> -> Symbol
    method remove_method (arg0) -> Module
      argument arg0<> -> Symbol | String
    method singleton_class? () -> TrueClass | FalseClass
    method taint () -> Module
    method to_s () -> String
    method trust () -> Module
    method undef_method (arg0) -> Module
      argument arg0<> -> Symbol | String
    method untaint () -> Module
    method untrust () -> Module
    method using (arg0) -> Module
      argument arg0<> -> Module
    static-field <constant:ARGF> -> Object
    static-field <constant:ARGV> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:CROSS_COMPILING> -> NilClass
    static-field <constant:ENV> -> Object
    static-field <constant:FALSE> -> FalseClass
    static-field <constant:NIL> -> NilClass
    static-field <constant:RUBY_COPYRIGHT> -> String
    static-field <constant:RUBY_DESCRIPTION> -> String
    static-field <constant:RUBY_ENGINE> -> String
    static-field <constant:RUBY_ENGINE_VERSION> -> String
    static-field <constant:RUBY_PATCHLEVEL> -> Integer
    static-field <constant:RUBY_PLATFORM> -> String
    static-field <constant:RUBY_RELEASE_DATE> -> String
    static-field <constant:RUBY_REVISION> -> Integer
    static-field <constant:RUBY_VERSION> -> String
    static-field <constant:STDERR> -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    static-field <constant:STDIN> -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    static-field <constant:STDOUT> -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    static-field <constant:TOPLEVEL_BINDING> -> Binding
    static-field <constant:TRUE> -> TrueClass
  class <constant:Monitor> < ::<constant:Object> (<constant:MonitorMixin>) -> <Class:Monitor>
    method clone () -> Monitor
    method dup () -> Monitor
    method freeze () -> Monitor
    method taint () -> Monitor
    method trust () -> Monitor
    method untaint () -> Monitor
    method untrust () -> Monitor
  class <constant:MonitorMixin> (<constant:BasicObject>) -> <Class:MonitorMixin>
    class <constant:ConditionVariable> < ::<constant:Object> () -> <Class:MonitorMixin::ConditionVariable>
      class <constant:Timeout> < ::<constant:Exception> () -> <Class:MonitorMixin::ConditionVariable::Timeout>
      class <singleton class:<constant:Timeout>> < ::<singleton class:<constant:Exception>> ()
    class <singleton class:<constant:ConditionVariable>> < ::<singleton class:<constant:Object>> ()
  class <constant:NameError> < ::<constant:StandardError> () -> <Class:NameError>
    method clone () -> NameError
    method dup () -> NameError
    method freeze () -> NameError
    method taint () -> NameError
    method trust () -> NameError
    method untaint () -> NameError
    method untrust () -> NameError
  class <constant:NilClass> < ::<constant:Object> () -> <Class:NilClass>
    method & (obj) -> FalseClass
      argument obj<> -> BasicObject
    method ^ (obj) -> TrueClass | FalseClass
      argument obj<> -> BasicObject
    method clone () -> NilClass
    method dup () -> NilClass
    method freeze () -> NilClass
    method rationalize () -> Rational
    method taint () -> NilClass
    method to_a () -> TupleType {
    }
    method to_c () -> Complex
    method to_f () -> Float
    method to_h () -> untyped
    method to_r () -> Rational
    method trust () -> NilClass
    method untaint () -> NilClass
    method untrust () -> NilClass
    method | (obj) -> TrueClass | FalseClass
      argument obj<> -> BasicObject
  class <constant:NoMemoryError> < ::<constant:Exception> () -> <Class:NoMemoryError>
    method clone () -> NoMemoryError
    method dup () -> NoMemoryError
    method freeze () -> NoMemoryError
    method taint () -> NoMemoryError
    method trust () -> NoMemoryError
    method untaint () -> NoMemoryError
    method untrust () -> NoMemoryError
  class <constant:NoMethodError> < ::<constant:NameError> () -> <Class:NoMethodError>
    method clone () -> NoMethodError
    method dup () -> NoMethodError
    method freeze () -> NoMethodError
    method taint () -> NoMethodError
    method trust () -> NoMethodError
    method untaint () -> NoMethodError
    method untrust () -> NoMethodError
  class <constant:NotImplementedError> < ::<constant:ScriptError> () -> <Class:NotImplementedError>
    method clone () -> NotImplementedError
    method dup () -> NotImplementedError
    method freeze () -> NotImplementedError
    method taint () -> NotImplementedError
    method trust () -> NotImplementedError
    method untaint () -> NotImplementedError
    method untrust () -> NotImplementedError
  class <constant:Numeric> < ::<constant:Object> (<constant:Comparable>) -> <Class:Numeric>
    method % (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method +@ () -> Integer | Float | Rational | BigDecimal | Complex
    method -@ () -> Integer | Float | Rational | BigDecimal | Complex
    method <=> (arg0) -> Object
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method <overload N.1 : step> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer | Float | Rational | BigDecimal | Complex
      ]
    }
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
      argument arg1<optional>
      argument blk<block>
    method <overload N.2 : step> (arg0, arg1, blk) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
      argument arg1<optional> -> Integer | Float | Rational | BigDecimal | Complex
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer | Float | Rational | BigDecimal | Complex
        ]
      }
    method <overload N.3 : step> (arg0, arg1) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Integer | Float | Rational | BigDecimal | Complex
      ]
    }
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
      argument arg1<optional> -> Integer | Float | Rational | BigDecimal | Complex
      argument blk<block>
    method abs () -> Integer | Float | Rational | BigDecimal | Complex
    method abs2 () -> Integer | Float | Rational | BigDecimal | Complex
    method angle () -> Integer | Float | Rational | BigDecimal | Complex
    method arg () -> Integer | Float | Rational | BigDecimal | Complex
    method ceil () -> Integer
    method clone () -> Numeric
    method coerce (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal | Complex
      1 = Integer | Float | Rational | BigDecimal | Complex
    }
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method conj () -> Integer | Float | Rational | BigDecimal | Complex
    method conjugate () -> Integer | Float | Rational | BigDecimal | Complex
    method denominator () -> Integer
    method div (arg0) -> Integer
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method divmod (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal | Complex
      1 = Integer | Float | Rational | BigDecimal | Complex
    }
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method dup () -> Numeric
    method eql? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method fdiv (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method floor () -> Integer
    method freeze () -> Numeric
    method i () -> Complex
    method imag () -> Integer | Float | Rational | BigDecimal | Complex
    method imaginary () -> Integer | Float | Rational | BigDecimal | Complex
    method integer? () -> TrueClass | FalseClass
    method magnitude () -> Integer | Float | Rational | BigDecimal | Complex
    method modulo (arg0) -> Integer | Float | Rational | BigDecimal
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method nonzero? () -> untyped
    method numerator () -> Integer
    method phase () -> Integer | Float | Rational | BigDecimal | Complex
    method polar () -> TupleType {
      0 = Integer | Float | Rational | BigDecimal | Complex
      1 = Integer | Float | Rational | BigDecimal | Complex
    }
    method quo (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method real () -> Integer | Float | Rational | BigDecimal | Complex
    method real? () -> Integer | Float | Rational | BigDecimal | Complex
    method rect () -> TupleType {
      0 = Integer | Float | Rational | BigDecimal | Complex
      1 = Integer | Float | Rational | BigDecimal | Complex
    }
    method rectangular () -> TupleType {
      0 = Integer | Float | Rational | BigDecimal | Complex
      1 = Integer | Float | Rational | BigDecimal | Complex
    }
    method remainder (arg0) -> Integer | Float | Rational | BigDecimal
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method round (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
    method singleton_method_added (arg0) -> TypeError
      argument arg0<> -> Symbol
    method step (arg0, blk) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Integer | Float | Rational | BigDecimal | Complex
      argument arg1<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer | Float | Rational | BigDecimal | Complex
        ]
      }
    method taint () -> Numeric
    method to_c () -> Complex
    method to_int () -> Integer
    method truncate () -> Integer
    method trust () -> Numeric
    method untaint () -> Numeric
    method untrust () -> Numeric
    method zero? () -> TrueClass | FalseClass
  class <constant:Object> < ::<constant:BasicObject> (<constant:Kernel>) -> <Class:Object>
    method !~ (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method <=> (other) -> Integer | NilClass
      argument other<> -> BasicObject
    method <overload N.1 : enum_for> (method, args, blk) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument args<repeated> -> BasicObject
      argument blk<block> -> BasicObject
      argument method<optional> -> Symbol
    method <overload N.1 : to_enum> (method, args, blk) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument args<repeated> -> BasicObject
      argument blk<block> -> BasicObject
      argument method<optional> -> Symbol
    method === (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method =~ (other) -> NilClass
      argument other<> -> BasicObject
    method clone () -> Object
    method display (port) -> NilClass
      argument port<> -> AppliedType {
        klass = ::<constant:IO>
        targs = [
          <constant:Elem> = String
        ]
      }
    method dup () -> Object
    method enum_for (method, args) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument args<repeated> -> BasicObject
      argument blk<block>
      argument method<optional> -> Symbol
    method eql? (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method extend (mod) -> NilClass
      argument mod<> -> Module
    method freeze () -> Object
    method frozen? () -> TrueClass | FalseClass
    method hash () -> Integer
    method inspect () -> String
    method instance_of? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Class
    method instance_variable_defined? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Symbol | String
    method instance_variable_get (arg0) -> untyped
      argument arg0<> -> Symbol | String
    method instance_variable_set (arg0, arg1) -> untyped
      argument arg0<> -> Symbol | String
      argument arg1<> -> BasicObject
    method instance_variables () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
    method is_a? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Module
    method kind_of? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Class
    method method (arg0) -> Method
      argument arg0<> -> Symbol
    method methods (regular) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
      argument regular<optional> -> TrueClass | FalseClass
    method nil? () -> TrueClass | FalseClass
    method private_methods (all) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
      argument all<optional> -> TrueClass | FalseClass
    method protected_methods (all) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
      argument all<optional> -> TrueClass | FalseClass
    method public_method (arg0) -> Method
      argument arg0<> -> Symbol
    method public_methods (all) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
      argument all<optional> -> TrueClass | FalseClass
    method public_send (arg0, args) -> untyped
      argument arg0<> -> Symbol | String
      argument args<repeated> -> BasicObject
    method remove_instance_variable (arg0) -> untyped
      argument arg0<> -> Symbol
    method send (arg0, args) -> untyped
      argument arg0<> -> Symbol | String
      argument args<repeated> -> BasicObject
    method singleton_class () -> Class
    method singleton_method (arg0) -> Method
      argument arg0<> -> Symbol
    method singleton_methods (all) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
      argument all<optional> -> TrueClass | FalseClass
    method taint () -> Object
    method tainted? () -> TrueClass | FalseClass
    method to_enum (method, args) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument args<repeated> -> BasicObject
      argument blk<block>
      argument method<optional> -> Symbol
    method trust () -> Object
    method untaint () -> Object
    method untrust () -> Object
    method untrusted? () -> TrueClass | FalseClass
    static-field <constant:ARGF> -> Object
    static-field <constant:ARGV> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:CROSS_COMPILING> -> NilClass
    static-field <constant:ENV> -> Object
    static-field <constant:FALSE> -> FalseClass
    static-field <constant:NIL> -> NilClass
    static-field <constant:RUBYGEMS_ACTIVATION_MONITOR> -> Monitor
    static-field <constant:RUBY_COPYRIGHT> -> String
    static-field <constant:RUBY_DESCRIPTION> -> String
    static-field <constant:RUBY_ENGINE> -> String
    static-field <constant:RUBY_ENGINE_VERSION> -> String
    static-field <constant:RUBY_PATCHLEVEL> -> Integer
    static-field <constant:RUBY_PLATFORM> -> String
    static-field <constant:RUBY_RELEASE_DATE> -> String
    static-field <constant:RUBY_REVISION> -> Integer
    static-field <constant:RUBY_VERSION> -> String
    static-field <constant:STDERR> -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    static-field <constant:STDIN> -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    static-field <constant:STDOUT> -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
    static-field <constant:TOPLEVEL_BINDING> -> Binding
    static-field <constant:TRUE> -> TrueClass
  class <constant:ObjectSpace> (<constant:BasicObject>) -> <Class:ObjectSpace>
    class <constant:WeakMap>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:ObjectSpace::WeakMap>
      typeMember(=) <constant:Elem>
    class <singleton class:<constant:WeakMap>> < ::<singleton class:<constant:Object>> ()
  class <constant:Opus> () -> <Class:Opus>
    class <constant:DB> () -> <Class:Opus::DB>
      class <constant:Model> () -> <Class:Opus::DB::Model>
      class <singleton class:<constant:Model>> < ::<constant:Module> ()
    class <singleton class:<constant:DB>> < ::<constant:Module> ()
  class <constant:Pathname> < ::<constant:Object> () -> <Class:Pathname>
    method + (other) -> Pathname
      argument other<> -> String | Pathname
    method / (other) -> Pathname
      argument other<> -> String | Pathname
    method <=> (p1) -> Integer | NilClass
      argument p1<> -> BasicObject
    method <overload N.1 : each_filename> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block>
    method <overload N.1 : each_line> (sep, limit) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block>
      argument limit<optional> -> Integer
      argument sep<optional> -> String
    method <overload N.1 : find> (ignore_error) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = Pathname
      ]
    }
      argument blk<block>
      argument ignore_error<> -> TrueClass | FalseClass
    method <overload N.1 : open> (mode, perm, opt, blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:File>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
      argument mode<optional> -> String
      argument opt<optional> -> Integer
      argument perm<optional> -> String
    method <overload N.1 : opendir> (arg0, blk) -> untyped
      argument arg0<optional> -> Encoding
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Dir>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
    method <overload N.1 : symlink?> () -> TrueClass | FalseClass
      argument old<optional>
    method == (p1) -> TrueClass | FalseClass
      argument p1<> -> BasicObject
    method === (p1) -> TrueClass | FalseClass
      argument p1<> -> BasicObject
    method absolute? () -> TrueClass | FalseClass
    method ascend (blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Pathname
        ]
      }
    method atime () -> Time
    method basename (p1) -> Pathname
      argument p1<optional> -> String
    method binread (length, offset) -> String
      argument length<optional> -> Integer
      argument offset<optional> -> Integer
    method binwrite (arg0, offset) -> Integer
      argument arg0<> -> String
      argument offset<optional> -> Integer
    method birthtime () -> Time
    method blockdev? () -> TrueClass | FalseClass
    method chardev? () -> TrueClass | FalseClass
    method children (with_directory) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Pathname
      ]
    }
      argument with_directory<> -> TrueClass | FalseClass
    method chmod (mode) -> Integer
      argument mode<> -> Integer
    method chown (owner, group) -> Integer
      argument group<> -> Integer
      argument owner<> -> Integer
    method cleanpath (consider_symlink) -> untyped
      argument consider_symlink<optional> -> TrueClass | FalseClass
    method ctime () -> Time
    method delete () -> untyped
    method descend (blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Pathname
        ]
      }
    method directory? () -> TrueClass | FalseClass
    method dirname () -> Pathname
    method each_child (with_directory, blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Pathname
        ]
      }
      argument with_directory<> -> TrueClass | FalseClass
    method each_entry (blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Pathname
        ]
      }
    method each_filename (blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
    method each_line (sep, limit, blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
      argument limit<optional> -> Integer
      argument sep<optional> -> String
    method entries () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Pathname
      ]
    }
    method eql? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method executable? () -> TrueClass | FalseClass
    method executable_real? () -> TrueClass | FalseClass
    method exist? () -> TrueClass | FalseClass
    method expand_path (p1) -> Pathname
      argument p1<optional> -> String | Pathname
    method extname () -> String
    method file? () -> TrueClass | FalseClass
    method find (ignore_error, blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Pathname
        ]
      }
      argument ignore_error<> -> TrueClass | FalseClass
    method fnmatch (pattern, flags) -> TrueClass | FalseClass
      argument flags<optional> -> Integer
      argument pattern<> -> String
    method freeze () -> Pathname
    method ftype () -> String
    method grpowned? () -> TrueClass | FalseClass
    method join (args) -> Pathname
      argument args<repeated> -> String | Pathname
    method lchmod (mode) -> Integer
      argument mode<> -> Integer
    method lchown (owner, group) -> Integer
      argument group<> -> Integer
      argument owner<> -> Integer
    method lstat () -> File::Stat
    method make_link (old) -> Integer
      argument old<> -> String
    method mkdir (p1) -> Integer
      argument p1<> -> String
    method mkpath () -> untyped
    method mountpoint? () -> TrueClass | FalseClass
    method mtime () -> Time
    method open (mode, perm, opt) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block>
      argument mode<optional> -> String
      argument opt<optional> -> Integer
      argument perm<optional> -> String
    method opendir (arg0) -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<optional> -> Encoding
      argument blk<block>
    method owned? () -> TrueClass | FalseClass
    method parent () -> Pathname
    method pipe? () -> TrueClass | FalseClass
    method read (length, offset, open_args) -> String
      argument length<optional> -> Integer
      argument offset<optional> -> Integer
      argument open_args<optional> -> Integer
    method readable? () -> TrueClass | FalseClass
    method readable_real? () -> TrueClass | FalseClass
    method readlines (sep, limit, open_args) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument limit<optional> -> Integer
      argument open_args<optional> -> Integer
      argument sep<optional> -> String
    method readlink () -> String
    method realdirpath (p1) -> String
      argument p1<optional> -> String
    method realpath (p1) -> String
      argument p1<optional> -> String
    method relative? () -> TrueClass | FalseClass
    method relative_path_from (base_directory) -> Pathname
      argument base_directory<> -> String | Pathname
    method rename (p1) -> Integer
      argument p1<> -> String
    method rmdir () -> Integer
    method rmtree () -> Integer
    method root? () -> TrueClass | FalseClass
    method setgid? () -> TrueClass | FalseClass
    method setuid? () -> TrueClass | FalseClass
    method size () -> Integer
    method size? () -> TrueClass | FalseClass
    method socket? () -> TrueClass | FalseClass
    method split () -> TupleType {
      0 = Pathname
      1 = Pathname
    }
    method stat () -> File::Stat
    method sticky? () -> TrueClass | FalseClass
    method sub (args) -> Pathname
      argument args<repeated> -> String
    method sub_ext (p1) -> Pathname
      argument p1<> -> String
    method symlink? (old) -> Integer
      argument old<optional> -> String
    method sysopen (mode, perm) -> Integer
      argument mode<optional> -> Integer
      argument perm<optional> -> Integer
    method taint () -> Pathname
    method to_path () -> String
    method to_s () -> String
    method truncate (length) -> Integer
      argument length<> -> Integer
    method unlink () -> Integer
    method untaint () -> Pathname
    method utime (atime, mtime) -> Integer
      argument atime<> -> Time
      argument mtime<> -> Time
    method world_readable? () -> TrueClass | FalseClass
    method world_writable? () -> TrueClass | FalseClass
    method writable? () -> TrueClass | FalseClass
    method writable_real? () -> TrueClass | FalseClass
    method write (arg0, offset, open_args) -> Integer
      argument arg0<> -> String
      argument offset<optional> -> Integer
      argument open_args<optional> -> Integer
    method zero? () -> TrueClass | FalseClass
  class <constant:Proc0>[<constant:Return>] < ::<constant:Proc> () -> <Class:Proc0>
    method <static-init> ()
    method [] () -> AliasType { symbol = ::<constant:Proc0>#call }
    method call () -> LambdaParam(::<constant:Proc0>#<constant:Return>)
    typeMember(=) <constant:Return>
  class <constant:Proc10>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>, <constant:Arg4>, <constant:Arg5>, <constant:Arg6>, <constant:Arg7>, <constant:Arg8>, <constant:Arg9>] < ::<constant:Proc> () -> <Class:Proc10>
    method <static-init> ()
    method [] () -> AliasType { symbol = ::<constant:Proc10>#call }
    method call (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) -> LambdaParam(::<constant:Proc10>#<constant:Return>)
      argument arg0<> -> LambdaParam(::<constant:Proc10>#<constant:Arg0>)
      argument arg1<> -> LambdaParam(::<constant:Proc10>#<constant:Arg1>)
      argument arg2<> -> LambdaParam(::<constant:Proc10>#<constant:Arg2>)
      argument arg3<> -> LambdaParam(::<constant:Proc10>#<constant:Arg3>)
      argument arg4<> -> LambdaParam(::<constant:Proc10>#<constant:Arg4>)
      argument arg5<> -> LambdaParam(::<constant:Proc10>#<constant:Arg5>)
      argument arg6<> -> LambdaParam(::<constant:Proc10>#<constant:Arg6>)
      argument arg7<> -> LambdaParam(::<constant:Proc10>#<constant:Arg7>)
      argument arg8<> -> LambdaParam(::<constant:Proc10>#<constant:Arg8>)
      argument arg9<> -> LambdaParam(::<constant:Proc10>#<constant:Arg9>)
    typeMember(=) <constant:Arg0>
    typeMember(=) <constant:Arg1>
    typeMember(=) <constant:Arg2>
    typeMember(=) <constant:Arg3>
    typeMember(=) <constant:Arg4>
    typeMember(=) <constant:Arg5>
    typeMember(=) <constant:Arg6>
    typeMember(=) <constant:Arg7>
    typeMember(=) <constant:Arg8>
    typeMember(=) <constant:Arg9>
    typeMember(=) <constant:Return>
  class <constant:Proc1>[<constant:Return>, <constant:Arg0>] < ::<constant:Proc> () -> <Class:Proc1>
    method <static-init> ()
    method [] () -> AliasType { symbol = ::<constant:Proc1>#call }
    method call (arg0) -> LambdaParam(::<constant:Proc1>#<constant:Return>)
      argument arg0<> -> LambdaParam(::<constant:Proc1>#<constant:Arg0>)
    typeMember(=) <constant:Arg0>
    typeMember(=) <constant:Return>
  class <constant:Proc2>[<constant:Return>, <constant:Arg0>, <constant:Arg1>] < ::<constant:Proc> () -> <Class:Proc2>
    method <static-init> ()
    method [] () -> AliasType { symbol = ::<constant:Proc2>#call }
    method call (arg0, arg1) -> LambdaParam(::<constant:Proc2>#<constant:Return>)
      argument arg0<> -> LambdaParam(::<constant:Proc2>#<constant:Arg0>)
      argument arg1<> -> LambdaParam(::<constant:Proc2>#<constant:Arg1>)
    typeMember(=) <constant:Arg0>
    typeMember(=) <constant:Arg1>
    typeMember(=) <constant:Return>
  class <constant:Proc3>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>] < ::<constant:Proc> () -> <Class:Proc3>
    method <static-init> ()
    method [] () -> AliasType { symbol = ::<constant:Proc3>#call }
    method call (arg0, arg1, arg2) -> LambdaParam(::<constant:Proc3>#<constant:Return>)
      argument arg0<> -> LambdaParam(::<constant:Proc3>#<constant:Arg0>)
      argument arg1<> -> LambdaParam(::<constant:Proc3>#<constant:Arg1>)
      argument arg2<> -> LambdaParam(::<constant:Proc3>#<constant:Arg2>)
    typeMember(=) <constant:Arg0>
    typeMember(=) <constant:Arg1>
    typeMember(=) <constant:Arg2>
    typeMember(=) <constant:Return>
  class <constant:Proc4>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>] < ::<constant:Proc> () -> <Class:Proc4>
    method <static-init> ()
    method [] () -> AliasType { symbol = ::<constant:Proc4>#call }
    method call (arg0, arg1, arg2, arg3) -> LambdaParam(::<constant:Proc4>#<constant:Return>)
      argument arg0<> -> LambdaParam(::<constant:Proc4>#<constant:Arg0>)
      argument arg1<> -> LambdaParam(::<constant:Proc4>#<constant:Arg1>)
      argument arg2<> -> LambdaParam(::<constant:Proc4>#<constant:Arg2>)
      argument arg3<> -> LambdaParam(::<constant:Proc4>#<constant:Arg3>)
    typeMember(=) <constant:Arg0>
    typeMember(=) <constant:Arg1>
    typeMember(=) <constant:Arg2>
    typeMember(=) <constant:Arg3>
    typeMember(=) <constant:Return>
  class <constant:Proc5>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>, <constant:Arg4>] < ::<constant:Proc> () -> <Class:Proc5>
    method <static-init> ()
    method [] () -> AliasType { symbol = ::<constant:Proc5>#call }
    method call (arg0, arg1, arg2, arg3, arg4) -> LambdaParam(::<constant:Proc5>#<constant:Return>)
      argument arg0<> -> LambdaParam(::<constant:Proc5>#<constant:Arg0>)
      argument arg1<> -> LambdaParam(::<constant:Proc5>#<constant:Arg1>)
      argument arg2<> -> LambdaParam(::<constant:Proc5>#<constant:Arg2>)
      argument arg3<> -> LambdaParam(::<constant:Proc5>#<constant:Arg3>)
      argument arg4<> -> LambdaParam(::<constant:Proc5>#<constant:Arg4>)
    typeMember(=) <constant:Arg0>
    typeMember(=) <constant:Arg1>
    typeMember(=) <constant:Arg2>
    typeMember(=) <constant:Arg3>
    typeMember(=) <constant:Arg4>
    typeMember(=) <constant:Return>
  class <constant:Proc6>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>, <constant:Arg4>, <constant:Arg5>] < ::<constant:Proc> () -> <Class:Proc6>
    method <static-init> ()
    method [] () -> AliasType { symbol = ::<constant:Proc6>#call }
    method call (arg0, arg1, arg2, arg3, arg4, arg5) -> LambdaParam(::<constant:Proc6>#<constant:Return>)
      argument arg0<> -> LambdaParam(::<constant:Proc6>#<constant:Arg0>)
      argument arg1<> -> LambdaParam(::<constant:Proc6>#<constant:Arg1>)
      argument arg2<> -> LambdaParam(::<constant:Proc6>#<constant:Arg2>)
      argument arg3<> -> LambdaParam(::<constant:Proc6>#<constant:Arg3>)
      argument arg4<> -> LambdaParam(::<constant:Proc6>#<constant:Arg4>)
      argument arg5<> -> LambdaParam(::<constant:Proc6>#<constant:Arg5>)
    typeMember(=) <constant:Arg0>
    typeMember(=) <constant:Arg1>
    typeMember(=) <constant:Arg2>
    typeMember(=) <constant:Arg3>
    typeMember(=) <constant:Arg4>
    typeMember(=) <constant:Arg5>
    typeMember(=) <constant:Return>
  class <constant:Proc7>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>, <constant:Arg4>, <constant:Arg5>, <constant:Arg6>] < ::<constant:Proc> () -> <Class:Proc7>
    method <static-init> ()
    method [] () -> AliasType { symbol = ::<constant:Proc7>#call }
    method call (arg0, arg1, arg2, arg3, arg4, arg5, arg6) -> LambdaParam(::<constant:Proc7>#<constant:Return>)
      argument arg0<> -> LambdaParam(::<constant:Proc7>#<constant:Arg0>)
      argument arg1<> -> LambdaParam(::<constant:Proc7>#<constant:Arg1>)
      argument arg2<> -> LambdaParam(::<constant:Proc7>#<constant:Arg2>)
      argument arg3<> -> LambdaParam(::<constant:Proc7>#<constant:Arg3>)
      argument arg4<> -> LambdaParam(::<constant:Proc7>#<constant:Arg4>)
      argument arg5<> -> LambdaParam(::<constant:Proc7>#<constant:Arg5>)
      argument arg6<> -> LambdaParam(::<constant:Proc7>#<constant:Arg6>)
    typeMember(=) <constant:Arg0>
    typeMember(=) <constant:Arg1>
    typeMember(=) <constant:Arg2>
    typeMember(=) <constant:Arg3>
    typeMember(=) <constant:Arg4>
    typeMember(=) <constant:Arg5>
    typeMember(=) <constant:Arg6>
    typeMember(=) <constant:Return>
  class <constant:Proc8>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>, <constant:Arg4>, <constant:Arg5>, <constant:Arg6>, <constant:Arg7>] < ::<constant:Proc> () -> <Class:Proc8>
    method <static-init> ()
    method [] () -> AliasType { symbol = ::<constant:Proc8>#call }
    method call (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) -> LambdaParam(::<constant:Proc8>#<constant:Return>)
      argument arg0<> -> LambdaParam(::<constant:Proc8>#<constant:Arg0>)
      argument arg1<> -> LambdaParam(::<constant:Proc8>#<constant:Arg1>)
      argument arg2<> -> LambdaParam(::<constant:Proc8>#<constant:Arg2>)
      argument arg3<> -> LambdaParam(::<constant:Proc8>#<constant:Arg3>)
      argument arg4<> -> LambdaParam(::<constant:Proc8>#<constant:Arg4>)
      argument arg5<> -> LambdaParam(::<constant:Proc8>#<constant:Arg5>)
      argument arg6<> -> LambdaParam(::<constant:Proc8>#<constant:Arg6>)
      argument arg7<> -> LambdaParam(::<constant:Proc8>#<constant:Arg7>)
    typeMember(=) <constant:Arg0>
    typeMember(=) <constant:Arg1>
    typeMember(=) <constant:Arg2>
    typeMember(=) <constant:Arg3>
    typeMember(=) <constant:Arg4>
    typeMember(=) <constant:Arg5>
    typeMember(=) <constant:Arg6>
    typeMember(=) <constant:Arg7>
    typeMember(=) <constant:Return>
  class <constant:Proc9>[<constant:Return>, <constant:Arg0>, <constant:Arg1>, <constant:Arg2>, <constant:Arg3>, <constant:Arg4>, <constant:Arg5>, <constant:Arg6>, <constant:Arg7>, <constant:Arg8>] < ::<constant:Proc> () -> <Class:Proc9>
    method <static-init> ()
    method [] () -> AliasType { symbol = ::<constant:Proc9>#call }
    method call (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) -> LambdaParam(::<constant:Proc9>#<constant:Return>)
      argument arg0<> -> LambdaParam(::<constant:Proc9>#<constant:Arg0>)
      argument arg1<> -> LambdaParam(::<constant:Proc9>#<constant:Arg1>)
      argument arg2<> -> LambdaParam(::<constant:Proc9>#<constant:Arg2>)
      argument arg3<> -> LambdaParam(::<constant:Proc9>#<constant:Arg3>)
      argument arg4<> -> LambdaParam(::<constant:Proc9>#<constant:Arg4>)
      argument arg5<> -> LambdaParam(::<constant:Proc9>#<constant:Arg5>)
      argument arg6<> -> LambdaParam(::<constant:Proc9>#<constant:Arg6>)
      argument arg7<> -> LambdaParam(::<constant:Proc9>#<constant:Arg7>)
      argument arg8<> -> LambdaParam(::<constant:Proc9>#<constant:Arg8>)
    typeMember(=) <constant:Arg0>
    typeMember(=) <constant:Arg1>
    typeMember(=) <constant:Arg2>
    typeMember(=) <constant:Arg3>
    typeMember(=) <constant:Arg4>
    typeMember(=) <constant:Arg5>
    typeMember(=) <constant:Arg6>
    typeMember(=) <constant:Arg7>
    typeMember(=) <constant:Arg8>
    typeMember(=) <constant:Return>
  class <constant:Proc> < ::<constant:Object> () -> <Class:Proc>
    method arity () -> Integer
    method binding () -> Binding
    method clone () -> Proc
    method curry (arity) -> Proc
      argument arity<optional> -> Integer
    method dup () -> Proc
    method freeze () -> Proc
    method hash () -> Integer
    method inspect () -> String
    method lambda () -> TrueClass | FalseClass
    method parameters () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = TupleType {
            0 = Symbol
            1 = Symbol
          }
      ]
    }
    method source_location () -> TupleType {
      0 = String
      1 = Integer
    }
    method taint () -> Proc
    method to_proc () -> Proc
    method to_s () -> String
    method trust () -> Proc
    method untaint () -> Proc
    method untrust () -> Proc
  class <constant:Process> (<constant:BasicObject>) -> <Class:Process>
    class <constant:GID> (<constant:BasicObject>) -> <Class:Process::GID>
    class <constant:Status> < ::<constant:Object> () -> <Class:Process::Status>
      method & (num) -> Integer
        argument num<> -> Integer
      method == (other) -> TrueClass | FalseClass
        argument other<> -> BasicObject
      method >> (num) -> Integer
        argument num<> -> Integer
      method coredump? () -> TrueClass | FalseClass
      method exited? () -> TrueClass | FalseClass
      method exitstatus () -> Integer | NilClass
      method inspect () -> String
      method pid () -> Integer
      method signaled? () -> TrueClass | FalseClass
      method stopped? () -> TrueClass | FalseClass
      method stopsig () -> Integer | NilClass
      method success? () -> TrueClass | FalseClass
      method termsig () -> Integer | NilClass
      method to_i () -> Integer
      method to_s () -> String
    class <constant:Sys> (<constant:BasicObject>) -> <Class:Process::Sys>
    class <constant:Tms>[<constant:Elem>] < ::<constant:Struct> () -> <Class:Process::Tms>
      typeMember(=) <constant:Elem>
    class <constant:UID> (<constant:BasicObject>) -> <Class:Process::UID>
    class <constant:Waiter> < ::<constant:Thread> () -> <Class:Process::Waiter>
      method pid () -> Integer
    class <singleton class:<constant:GID>> < ::<constant:Module> ()
      method <overload N.1 : switch> (blk) -> untyped
        argument blk<block> -> AppliedType {
          klass = ::<constant:Proc0>
          targs = [
            <constant:Return> = BasicObject
          ]
        }
      method change_privilege (group) -> Integer
        argument group<> -> Integer
      method eid () -> Integer
      method eid= (group) -> Integer
        argument group<> -> Integer
      method from_name (name) -> Integer
        argument name<> -> String
      method grant_privilege (group) -> Integer
        argument group<> -> Integer
      method re_exchange () -> Integer
      method re_exchangeable? () -> TrueClass | FalseClass
      method rid () -> Integer
      method sid_available? () -> TrueClass | FalseClass
      method switch () -> Integer
        argument blk<block>
    class <singleton class:<constant:Status>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:Sys>> < ::<constant:Module> ()
      method geteuid () -> Integer
      method getgid () -> Integer
      method getuid () -> Integer
      method issetugid () -> TrueClass | FalseClass
      method setegid (group) -> NilClass
        argument group<> -> Integer
      method seteuid (user) -> NilClass
        argument user<> -> Integer
      method setgid (group) -> NilClass
        argument group<> -> Integer
      method setregid (rid, eid) -> NilClass
        argument eid<> -> Integer
        argument rid<> -> Integer
      method setresgid (rid, eid, sid) -> NilClass
        argument eid<> -> Integer
        argument rid<> -> Integer
        argument sid<> -> Integer
      method setresuid (rid, eid, sid) -> NilClass
        argument eid<> -> Integer
        argument rid<> -> Integer
        argument sid<> -> Integer
      method setreuid (rid, eid) -> NilClass
        argument eid<> -> Integer
        argument rid<> -> Integer
      method setrgid (group) -> NilClass
        argument group<> -> Integer
      method setruid (user) -> NilClass
        argument user<> -> Integer
      method setuid (user) -> NilClass
        argument user<> -> Integer
    class <singleton class:<constant:Tms>> < ::<singleton class:<constant:Struct>> ()
    class <singleton class:<constant:UID>> < ::<constant:Module> ()
      method <overload N.1 : switch> (blk) -> untyped
        argument blk<block> -> AppliedType {
          klass = ::<constant:Proc0>
          targs = [
            <constant:Return> = BasicObject
          ]
        }
      method change_privilege (user) -> Integer
        argument user<> -> Integer
      method eid () -> Integer
      method eid= (user) -> Integer
        argument user<> -> Integer
      method from_name (name) -> Integer
        argument name<> -> String
      method grant_privilege (user) -> Integer
        argument user<> -> Integer
      method re_exchange () -> Integer
      method re_exchangeable? () -> TrueClass | FalseClass
      method rid () -> Integer
      method sid_available? () -> TrueClass | FalseClass
      method switch () -> Integer
        argument blk<block>
    class <singleton class:<constant:Waiter>> < ::<singleton class:<constant:Thread>> ()
    static-field <constant:CLOCK_BOOTTIME> -> Integer
    static-field <constant:CLOCK_BOOTTIME_ALARM> -> Integer
    static-field <constant:CLOCK_MONOTONIC> -> Integer
    static-field <constant:CLOCK_MONOTONIC_COARSE> -> Integer
    static-field <constant:CLOCK_MONOTONIC_RAW> -> Integer
    static-field <constant:CLOCK_PROCESS_CPUTIME_ID> -> Integer
    static-field <constant:CLOCK_REALTIME> -> Integer
    static-field <constant:CLOCK_REALTIME_ALARM> -> Integer
    static-field <constant:CLOCK_REALTIME_COARSE> -> Integer
    static-field <constant:CLOCK_THREAD_CPUTIME_ID> -> Integer
    static-field <constant:PRIO_PGRP> -> Integer
    static-field <constant:PRIO_PROCESS> -> Integer
    static-field <constant:PRIO_USER> -> Integer
    static-field <constant:RLIMIT_AS> -> Integer
    static-field <constant:RLIMIT_CORE> -> Integer
    static-field <constant:RLIMIT_CPU> -> Integer
    static-field <constant:RLIMIT_DATA> -> Integer
    static-field <constant:RLIMIT_FSIZE> -> Integer
    static-field <constant:RLIMIT_MEMLOCK> -> Integer
    static-field <constant:RLIMIT_MSGQUEUE> -> Integer
    static-field <constant:RLIMIT_NICE> -> Integer
    static-field <constant:RLIMIT_NOFILE> -> Integer
    static-field <constant:RLIMIT_NPROC> -> Integer
    static-field <constant:RLIMIT_RSS> -> Integer
    static-field <constant:RLIMIT_RTPRIO> -> Integer
    static-field <constant:RLIMIT_RTTIME> -> Integer
    static-field <constant:RLIMIT_SIGPENDING> -> Integer
    static-field <constant:RLIMIT_STACK> -> Integer
    static-field <constant:RLIM_INFINITY> -> Integer
    static-field <constant:RLIM_SAVED_CUR> -> Integer
    static-field <constant:RLIM_SAVED_MAX> -> Integer
    static-field <constant:WNOHANG> -> Integer
    static-field <constant:WUNTRACED> -> Integer
  class <constant:Random> < ::<constant:Object> (<constant:Formatter>) -> <Class:Random>
    class <constant:Formatter> (<constant:BasicObject>) -> <Class:Random::Formatter>
    class <singleton class:<constant:Formatter>> < ::<constant:Module> ()
    method <overload N.1 : rand> (max) -> Float
      argument max<optional> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = Float
            ]
          } | Float
    method == (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method bytes (size) -> String
      argument size<> -> Integer
    method clone () -> Random
    method dup () -> Random
    method freeze () -> Random
    method initialize (seed) -> Object
      argument seed<optional> -> Integer
    method rand (max) -> Integer
      argument max<optional> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = Integer
            ]
          } | Integer
    method seed () -> Integer
    method taint () -> Random
    method trust () -> Random
    method untaint () -> Random
    method untrust () -> Random
    static-field <constant:DEFAULT> -> Random
  class <constant:Range>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Range>
    method <overload N.1 : each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method <overload N.1 : first> (n) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    }
      argument n<optional> -> Integer
    method <overload N.1 : last> (n) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    }
      argument n<optional> -> Integer
    method <overload N.1 : max> (blk) -> LambdaParam(::<constant:Range>#<constant:Elem>)
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      }
      argument n<optional>
    method <overload N.1 : min> (blk) -> LambdaParam(::<constant:Range>#<constant:Elem>)
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      }
      argument n<optional>
    method <overload N.1 : step> (n) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    }
      argument blk<block>
      argument n<optional> -> Integer
    method <overload N.2 : max> (n) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    }
      argument blk<block>
      argument n<optional> -> Integer
    method <overload N.2 : min> (n) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    }
      argument blk<block>
      argument n<optional> -> Integer
    method <overload N.3 : max> (n, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      }
      argument n<optional> -> Integer
    method <overload N.3 : min> (n, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Range>#<constant:Elem>)
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc2>
        targs = [
          <constant:Return> = Integer
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
          <constant:Arg1> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      }
      argument n<optional> -> Integer
    method == (obj) -> TrueClass | FalseClass
      argument obj<> -> BasicObject
    method === (obj) -> TrueClass | FalseClass
      argument obj<> -> BasicObject
    method begin () -> LambdaParam(::<constant:Range>#<constant:Elem>)
    method bsearch (blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      }
    method clone () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method cover? (obj) -> TrueClass | FalseClass
      argument obj<> -> BasicObject
    method dup () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method each (blk) -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      }
    method end () -> LambdaParam(::<constant:Range>#<constant:Elem>)
    method eql? (obj) -> TrueClass | FalseClass
      argument obj<> -> BasicObject
    method exclude_end? () -> TrueClass | FalseClass
    method first () -> LambdaParam(::<constant:Range>#<constant:Elem>)
      argument n<optional>
    method freeze () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method hash () -> Integer
    method include? (obj) -> TrueClass | FalseClass
      argument obj<> -> BasicObject
    method initialize (_begin, _end, exclude_end) -> Object
      argument _begin<> -> Integer
      argument _end<> -> Integer
      argument exclude_end<optional> -> TrueClass | FalseClass
    method inspect () -> String
    method last () -> LambdaParam(::<constant:Range>#<constant:Elem>)
      argument n<optional>
    method max () -> LambdaParam(::<constant:Range>#<constant:Elem>)
      argument blk<block>
      argument n<optional>
    method member? (obj) -> TrueClass | FalseClass
      argument obj<> -> BasicObject
    method min () -> LambdaParam(::<constant:Range>#<constant:Elem>)
      argument blk<block>
      argument n<optional>
    method size () -> Integer | NilClass
    method step (n, blk) -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Range>#<constant:Elem>)
        ]
      }
      argument n<optional> -> Integer
    method taint () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method to_s () -> String
    method trust () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method untaint () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method untrust () -> AppliedType {
      klass = ::<constant:Range>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    typeMember(=) <constant:Elem>
  class <constant:RangeError> < ::<constant:StandardError> () -> <Class:RangeError>
    method clone () -> RangeError
    method dup () -> RangeError
    method freeze () -> RangeError
    method taint () -> RangeError
    method trust () -> RangeError
    method untaint () -> RangeError
    method untrust () -> RangeError
  class <constant:Rational> < ::<constant:Numeric> () -> <Class:Rational>
    method % (arg0) -> Rational
      argument arg0<> -> Integer
    method * (arg0) -> Rational
      argument arg0<> -> Integer
    method ** (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Integer
    method + (arg0) -> Rational
      argument arg0<> -> Integer
    method +@ () -> Rational
    method - (arg0) -> Rational
      argument arg0<> -> Integer
    method -@ () -> Rational
    method / (arg0) -> Rational
      argument arg0<> -> Integer
    method < (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method <= (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method <=> (arg0) -> Object
      argument arg0<> -> Integer
    method <overload N.1 : %> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : **> (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Float
    method <overload N.1 : *> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : +> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : -> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : /> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : <=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : <=>> (arg0) -> Object
      argument arg0<> -> Float
    method <overload N.1 : <> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : >=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : >> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Float
    method <overload N.1 : ceil> (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<optional> -> Integer
    method <overload N.1 : coerce> (arg0) -> TupleType {
      0 = Float
      1 = Float
    }
      argument arg0<> -> Float
    method <overload N.1 : div> (arg0) -> Integer
      argument arg0<> -> Float
    method <overload N.1 : fdiv> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : floor> (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<optional> -> Integer
    method <overload N.1 : modulo> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : quo> (arg0) -> Float
      argument arg0<> -> Float
    method <overload N.1 : rationalize> (arg0) -> Rational
      argument arg0<optional> -> Integer | Float | Rational | BigDecimal | Complex
    method <overload N.1 : round> (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<optional> -> Integer
    method <overload N.1 : truncate> (arg0) -> Rational
      argument arg0<optional> -> Integer
    method <overload N.2 : %> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.2 : **> (arg0) -> Integer | Float | Rational | BigDecimal | Complex
      argument arg0<> -> Rational
    method <overload N.2 : *> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.2 : +> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.2 : -> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.2 : /> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.2 : <=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : <=>> (arg0) -> Object
      argument arg0<> -> Rational
    method <overload N.2 : <> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : >=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : >> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Rational
    method <overload N.2 : coerce> (arg0) -> TupleType {
      0 = Rational
      1 = Rational
    }
      argument arg0<> -> Rational
    method <overload N.2 : div> (arg0) -> Integer
      argument arg0<> -> Rational
    method <overload N.2 : fdiv> (arg0) -> Float
      argument arg0<> -> Rational
    method <overload N.2 : modulo> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.2 : quo> (arg0) -> Rational
      argument arg0<> -> Rational
    method <overload N.3 : %> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : **> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : *> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : +> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : -> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : /> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : <=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : <=>> (arg0) -> Object
      argument arg0<> -> BigDecimal
    method <overload N.3 : <> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : >=> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : >> (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BigDecimal
    method <overload N.3 : coerce> (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal | Complex
      1 = Integer | Float | Rational | BigDecimal | Complex
    }
      argument arg0<> -> Complex
    method <overload N.3 : div> (arg0) -> Integer
      argument arg0<> -> BigDecimal
    method <overload N.3 : fdiv> (arg0) -> Float
      argument arg0<> -> BigDecimal
    method <overload N.3 : modulo> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.3 : quo> (arg0) -> BigDecimal
      argument arg0<> -> BigDecimal
    method <overload N.4 : **> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : *> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : +> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : -> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : /> (arg0) -> Complex
      argument arg0<> -> Complex
    method <overload N.4 : fdiv> (arg0) -> Float
      argument arg0<> -> Complex
    method <overload N.4 : quo> (arg0) -> Complex
      argument arg0<> -> Complex
    method == (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method > (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method >= (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Integer
    method abs () -> Rational
    method abs2 () -> Rational
    method angle () -> Integer | Float | Rational | BigDecimal | Complex
    method arg () -> Integer | Float | Rational | BigDecimal | Complex
    method ceil () -> Integer
      argument arg0<optional>
    method clone () -> Rational
    method coerce (arg0) -> TupleType {
      0 = Rational
      1 = Rational
    }
      argument arg0<> -> Integer
    method conj () -> Rational
    method conjugate () -> Rational
    method denominator () -> Integer
    method div (arg0) -> Integer
      argument arg0<> -> Integer
    method divmod (arg0) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    }
      argument arg0<> -> Integer | Float | Rational | BigDecimal
    method dup () -> Rational
    method equal? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> Object
    method fdiv (arg0) -> Float
      argument arg0<> -> Integer
    method floor () -> Integer
      argument arg0<optional>
    method freeze () -> Rational
    method hash () -> Integer
    method imag () -> Integer
    method imaginary () -> Integer
    method inspect () -> String
    method modulo (arg0) -> Rational
      argument arg0<> -> Integer
    method numerator () -> Integer
    method phase () -> Integer | Float | Rational | BigDecimal | Complex
    method quo (arg0) -> Rational
      argument arg0<> -> Integer
    method rationalize () -> Rational
      argument arg0<optional>
    method real () -> Rational
    method real? () -> TrueClass
    method round () -> Integer
      argument arg0<optional>
    method taint () -> Rational
    method to_c () -> Complex
    method to_f () -> Float
    method to_i () -> Integer
    method to_r () -> Rational
    method to_s () -> String
    method truncate () -> Integer
      argument arg0<optional>
    method trust () -> Rational
    method untaint () -> Rational
    method untrust () -> Rational
    method zero? () -> TrueClass | FalseClass
  class <constant:RbConfig> (<constant:BasicObject>) -> <Class:RbConfig>
    static-field <constant:CONFIG> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:DESTDIR> -> String
    static-field <constant:MAKEFILE_CONFIG> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:TOPDIR> -> String
  class <constant:Regexp> < ::<constant:Object> () -> <Class:Regexp>
    method <overload N.1 : initialize> (arg0) -> Object
      argument arg0<> -> Regexp
      argument kcode<optional>
      argument options<optional>
    method == (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method === (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method =~ (str) -> Integer | NilClass
      argument str<> -> String
    method casefold? () -> TrueClass | FalseClass
    method clone () -> Regexp
    method dup () -> Regexp
    method encoding () -> Encoding
    method eql? (other) -> TrueClass | FalseClass
      argument other<> -> BasicObject
    method fixed_encoding? () -> TrueClass | FalseClass
    method freeze () -> Regexp
    method hash () -> Integer
    method initialize (arg0, options, kcode) -> Object
      argument arg0<> -> String
      argument kcode<optional> -> String
      argument options<optional> -> BasicObject
    method inspect () -> String
    method match (arg0, arg1) -> MatchData | NilClass
      argument arg0<> -> String
      argument arg1<optional> -> Integer
    method named_captures () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = String
        <constant:V> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = Integer
            ]
          }
        <constant:Elem> = untyped
      ]
    }
    method names () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
    method options () -> Integer
    method source () -> String
    method taint () -> Regexp
    method to_s () -> String
    method trust () -> Regexp
    method untaint () -> Regexp
    method untrust () -> Regexp
    method ~ () -> Integer | NilClass
    static-field <constant:EXTENDED> -> Integer
    static-field <constant:FIXEDENCODING> -> Integer
    static-field <constant:IGNORECASE> -> Integer
    static-field <constant:MULTILINE> -> Integer
    static-field <constant:NOENCODING> -> Integer
  class <constant:RegexpError> < ::<constant:StandardError> () -> <Class:RegexpError>
    method clone () -> RegexpError
    method dup () -> RegexpError
    method freeze () -> RegexpError
    method taint () -> RegexpError
    method trust () -> RegexpError
    method untaint () -> RegexpError
    method untrust () -> RegexpError
  class <constant:RubyTyper> () -> <Class:RubyTyper>
    class <constant:DynamicStruct>[<constant:Elem>] < ::<constant:Struct> () -> <Class:RubyTyper::DynamicStruct>
      typeMember(=) <constant:Elem> -> untyped
    class <constant:StubClass> < ::<constant:Object> () -> <Class:RubyTyper::StubClass>
    class <singleton class:<constant:DynamicStruct>> < ::<singleton class:<constant:Struct>> ()
      method new (arg1) -> AppliedType {
        klass = ::<constant:RubyTyper>::<constant:DynamicStruct>
        targs = [
          <constant:Elem> = untyped
        ]
      }
        argument arg1<repeated> -> untyped
    class <singleton class:<constant:StubClass>> < ::<singleton class:<constant:Object>> ()
  class <constant:RubyVM> < ::<constant:Object> () -> <Class:RubyVM>
    class <constant:InstructionSequence> < ::<constant:Object> () -> <Class:RubyVM::InstructionSequence>
    class <singleton class:<constant:InstructionSequence>> < ::<singleton class:<constant:Object>> ()
    method clone () -> RubyVM
    method dup () -> RubyVM
    method freeze () -> RubyVM
    method taint () -> RubyVM
    method trust () -> RubyVM
    method untaint () -> RubyVM
    method untrust () -> RubyVM
    static-field <constant:DEFAULT_PARAMS> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:INSTRUCTION_NAMES> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:OPTS> -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
  class <constant:RuntimeError> < ::<constant:StandardError> () -> <Class:RuntimeError>
    method clone () -> RuntimeError
    method dup () -> RuntimeError
    method freeze () -> RuntimeError
    method taint () -> RuntimeError
    method trust () -> RuntimeError
    method untaint () -> RuntimeError
    method untrust () -> RuntimeError
  class <constant:ScriptError> < ::<constant:Exception> () -> <Class:ScriptError>
    method clone () -> ScriptError
    method dup () -> ScriptError
    method freeze () -> ScriptError
    method taint () -> ScriptError
    method trust () -> ScriptError
    method untaint () -> ScriptError
    method untrust () -> ScriptError
  class <constant:SecurityError> < ::<constant:Exception> () -> <Class:SecurityError>
    method clone () -> SecurityError
    method dup () -> SecurityError
    method freeze () -> SecurityError
    method taint () -> SecurityError
    method trust () -> SecurityError
    method untaint () -> SecurityError
    method untrust () -> SecurityError
  class <constant:Set>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Set>
    method & (enum) -> untyped
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method + (enum) -> untyped
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method - (enum) -> untyped
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method < (set) -> TrueClass | FalseClass
      argument set<> -> untyped
    method << (o) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>)
    method <= (set) -> TrueClass | FalseClass
      argument set<> -> untyped
    method <overload N.1 : each> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
      ]
    }
      argument blk<block>
    method > (set) -> TrueClass | FalseClass
      argument set<> -> untyped
    method >= (set) -> TrueClass | FalseClass
      argument set<> -> untyped
    method ^ (enum) -> untyped
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method add (o) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>)
    method add? (o) -> untyped
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>)
    method classify (blk) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = LambdaParam(::<constant:Set>#<constant:Elem>)
          <constant:Arg0> = untyped
        ]
      }
    method clear () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method clone () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method collect! (blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method delete (o) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>)
    method delete? (o) -> untyped
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>)
    method delete_if (blk) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method difference (enum) -> untyped
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method disjoint? (set) -> TrueClass | FalseClass
      argument set<> -> untyped
    method dup () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method each (blk) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method empty? () -> TrueClass | FalseClass
    method flatten () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method flatten! () -> untyped
    method freeze () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method include? (o) -> TrueClass | FalseClass
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>)
    method initialize (enum) -> Object
      argument enum<optional> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = BasicObject
        ]
      }
    method intersect? (set) -> TrueClass | FalseClass
      argument set<> -> untyped
    method intersection (enum) -> untyped
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method keep_if (blk) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method length () -> Integer
    method map! (blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method member? (o) -> TrueClass | FalseClass
      argument o<> -> LambdaParam(::<constant:Set>#<constant:Elem>)
    method merge (enum) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method proper_subset? (set) -> TrueClass | FalseClass
      argument set<> -> untyped
    method proper_superset? (set) -> TrueClass | FalseClass
      argument set<> -> untyped
    method reject! (blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method replace (enum) -> untyped
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = BasicObject
        ]
      }
    method select! (blk) -> untyped
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method size () -> Integer
    method subset? (set) -> TrueClass | FalseClass
      argument set<> -> untyped
    method subtract (enum) -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method superset? (set) -> TrueClass | FalseClass
      argument set<> -> untyped
    method taint () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method to_a () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
      ]
    }
    method trust () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method union (enum) -> untyped
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    method untaint () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method untrust () -> AppliedType {
      klass = ::<constant:Set>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method | (enum) -> untyped
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:Set>#<constant:Elem>)
        ]
      }
    typeMember(=) <constant:Elem>
  class <constant:Signal> (<constant:BasicObject>) -> <Class:Signal>
  class <constant:SignalException> < ::<constant:Exception> () -> <Class:SignalException>
    method clone () -> SignalException
    method dup () -> SignalException
    method freeze () -> SignalException
    method taint () -> SignalException
    method trust () -> SignalException
    method untaint () -> SignalException
    method untrust () -> SignalException
  class <constant:SingleForwardable> (<constant:BasicObject>) -> <Class:SingleForwardable>
  class <constant:SortedSet>[<constant:Elem>] < ::<constant:Set> () -> <Class:SortedSet>
    method add (o) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument o<> -> LambdaParam(::<constant:SortedSet>#<constant:Elem>)
    method clear () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method clone () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method delete (o) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument o<> -> LambdaParam(::<constant:SortedSet>#<constant:Elem>)
    method delete_if (blk) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:SortedSet>#<constant:Elem>)
        ]
      }
    method dup () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method each (blk) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = LambdaParam(::<constant:SortedSet>#<constant:Elem>)
        ]
      }
    method freeze () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method keep_if (blk) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = TrueClass | FalseClass
          <constant:Arg0> = LambdaParam(::<constant:SortedSet>#<constant:Elem>)
        ]
      }
    method merge (enum) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:SortedSet>#<constant:Elem>)
        ]
      }
    method subtract (enum) -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument enum<> -> AppliedType {
        klass = ::<constant:Enumerable>
        targs = [
          <constant:Elem> = LambdaParam(::<constant:SortedSet>#<constant:Elem>)
        ]
      }
    method taint () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method trust () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method untaint () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method untrust () -> AppliedType {
      klass = ::<constant:SortedSet>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    typeMember(=) <constant:Elem>
  class <constant:StandardError> < ::<constant:Exception> () -> <Class:StandardError>
    method clone () -> StandardError
    method dup () -> StandardError
    method freeze () -> StandardError
    method taint () -> StandardError
    method trust () -> StandardError
    method untaint () -> StandardError
    method untrust () -> StandardError
  class <constant:StopIteration> < ::<constant:IndexError> () -> <Class:StopIteration>
    method clone () -> StopIteration
    method dup () -> StopIteration
    method freeze () -> StopIteration
    method taint () -> StopIteration
    method trust () -> StopIteration
    method untaint () -> StopIteration
    method untrust () -> StopIteration
  class <constant:String> < ::<constant:Object> (<constant:Comparable>) -> <Class:String>
    method % (arg0) -> String
      argument arg0<> -> Object
    method * (arg0) -> String
      argument arg0<> -> Integer
    method + (arg0) -> String
      argument arg0<> -> String
    method << (arg0) -> String
      argument arg0<> -> Object
    method <=> (other) -> Integer | NilClass
      argument other<> -> String
    method <overload N.1 : []> (arg0) -> String | NilClass
      argument arg0<> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = Integer
            ]
          } | Regexp
      argument arg1<optional>
    method <overload N.1 : byteslice> (arg0) -> String | NilClass
      argument arg0<> -> AppliedType {
        klass = ::<constant:Range>
        targs = [
          <constant:Elem> = Integer
        ]
      }
      argument arg1<optional>
    method <overload N.1 : codepoints> (blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    }
      argument blk<block> -> BasicObject
    method <overload N.1 : each_byte> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block>
    method <overload N.1 : each_char> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block>
    method <overload N.1 : each_codepoint> () -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument blk<block>
    method <overload N.1 : each_line> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument arg0<optional> -> String
      argument blk<block>
    method <overload N.1 : gsub!> (arg0, blk) -> String | NilClass
      argument arg0<> -> Regexp | String
      argument arg1<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
    method <overload N.1 : gsub> (arg0, arg1) -> String
      argument arg0<> -> Regexp | String
      argument arg1<optional> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      argument blk<block>
    method <overload N.1 : match> (arg0, arg1) -> MatchData
      argument arg0<> -> Regexp | String
      argument arg1<optional> -> Integer
    method <overload N.1 : scan> (arg0, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = AppliedType {
                klass = ::<constant:Array>
                targs = [
                  <constant:Elem> = String
                ]
              } | String
      ]
    }
      argument arg0<> -> Regexp | String
      argument blk<block> -> BasicObject
    method <overload N.1 : scrub!> (arg0, blk) -> String
      argument arg0<optional> -> String
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = untyped
        ]
      }
    method <overload N.1 : scrub> (arg0, blk) -> String
      argument arg0<optional> -> String
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = untyped
        ]
      }
    method <overload N.1 : slice!> (arg0) -> String | NilClass
      argument arg0<> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = Integer
            ]
          } | Regexp
      argument arg1<optional>
    method <overload N.1 : slice> (arg0) -> String | NilClass
      argument arg0<> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = Integer
            ]
          } | Regexp
      argument arg1<optional>
    method <overload N.1 : split> (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<optional> -> Integer
      argument arg1<optional>
    method <overload N.1 : sub!> (arg0, blk) -> String
      argument arg0<> -> Regexp | String
      argument arg1<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
    method <overload N.1 : sub> (arg0, blk) -> String
      argument arg0<> -> Regexp | String
      argument arg1<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
    method <overload N.1 : upto> (arg0, arg1, blk) -> String
      argument arg0<> -> String
      argument arg1<optional> -> BasicObject
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
    method <overload N.2 : []> (arg0, arg1) -> String | NilClass
      argument arg0<> -> Regexp
      argument arg1<optional> -> Integer
    method <overload N.2 : gsub!> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> Regexp | String
      argument arg1<optional>
      argument blk<block>
    method <overload N.2 : gsub> (arg0, blk) -> String
      argument arg0<> -> Regexp | String
      argument arg1<optional>
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
    method <overload N.2 : slice!> (arg0, arg1) -> String | NilClass
      argument arg0<> -> Regexp
      argument arg1<optional> -> Integer
    method <overload N.2 : slice> (arg0, arg1) -> String | NilClass
      argument arg0<> -> Regexp
      argument arg1<optional> -> Integer
    method <overload N.3 : []> (arg0, arg1) -> String | NilClass
      argument arg0<> -> Regexp
      argument arg1<optional> -> String
    method <overload N.3 : gsub> (arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> Regexp | String
      argument arg1<optional>
      argument blk<block>
    method <overload N.3 : slice!> (arg0, arg1) -> String | NilClass
      argument arg0<> -> Regexp
      argument arg1<optional> -> String
    method <overload N.3 : slice> (arg0, arg1) -> String | NilClass
      argument arg0<> -> Regexp
      argument arg1<optional> -> String
    method <overload N.4 : []> (arg0) -> String | NilClass
      argument arg0<> -> String
      argument arg1<optional>
    method <overload N.4 : gsub> (arg0) -> String
      argument arg0<> -> Regexp | String
      argument arg1<optional>
      argument blk<block>
    method <overload N.4 : slice!> (arg0) -> String | NilClass
      argument arg0<> -> String
      argument arg1<optional>
    method <overload N.4 : slice> (arg0) -> String | NilClass
      argument arg0<> -> String
      argument arg1<optional>
    method == (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method === (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method =~ (arg0) -> Integer | NilClass
      argument arg0<> -> Object
    method [] (arg0, arg1) -> String | NilClass
      argument arg0<> -> Integer
      argument arg1<optional> -> Integer
    method ascii_only? () -> TrueClass | FalseClass
    method b () -> String
    method bytes () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method bytesize () -> Integer
    method byteslice (arg0, arg1) -> String | NilClass
      argument arg0<> -> Integer
      argument arg1<optional> -> Integer
    method capitalize () -> String
    method capitalize! () -> String | NilClass
    method casecmp (arg0) -> NilClass | Integer
      argument arg0<> -> String
    method center (arg0, arg1) -> String
      argument arg0<> -> Integer
      argument arg1<optional> -> String
    method chars () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method chomp (arg0) -> String
      argument arg0<optional> -> String
    method chomp! (arg0) -> String | NilClass
      argument arg0<optional> -> String
    method chop () -> String
    method chop! () -> String | NilClass
    method chr () -> String
    method clear () -> String
    method clone () -> String
    method codepoints () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    }
      argument blk<block>
    method concat (arg0) -> String
      argument arg0<> -> Object
    method count (arg0, arg1) -> Integer
      argument arg0<> -> String
      argument arg1<repeated> -> String
    method crypt (arg0) -> String
      argument arg0<> -> String
    method delete (arg0, arg1) -> String
      argument arg0<> -> String
      argument arg1<repeated> -> String
    method delete! (arg0, arg1) -> String | NilClass
      argument arg0<> -> String
      argument arg1<repeated> -> String
    method downcase () -> String
    method downcase! () -> String | NilClass
    method dump () -> String
    method dup () -> String
    method each_byte (blk) -> String
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method each_char (blk) -> String
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
    method each_codepoint (blk) -> String
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method each_line (arg0, blk) -> String
      argument arg0<optional> -> String
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method empty? () -> TrueClass | FalseClass
    method encoding () -> Encoding
    method end_with? (arg0) -> TrueClass | FalseClass
      argument arg0<repeated> -> String
    method eql? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> String
    method force_encoding (arg0) -> String
      argument arg0<> -> String | Encoding
    method freeze () -> String
    method getbyte (arg0) -> Integer | NilClass
      argument arg0<> -> Integer
    method gsub (arg0, arg1) -> String
      argument arg0<> -> Regexp | String
      argument arg1<optional> -> String
      argument blk<block>
    method gsub! (arg0, arg1) -> String | NilClass
      argument arg0<> -> Regexp | String
      argument arg1<optional> -> String
      argument blk<block>
    method hash () -> Integer
    method hex () -> Integer
    method include? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> String
    method index (arg0, arg1) -> Integer | NilClass
      argument arg0<> -> Regexp | String
      argument arg1<optional> -> Integer
    method initialize (str) -> Object
      argument str<optional> -> String
    method insert (arg0, arg1) -> String
      argument arg0<> -> Integer
      argument arg1<> -> String
    method inspect () -> String
    method intern () -> Symbol
    method length () -> Integer
    method lines (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<optional> -> String
    method ljust (arg0, arg1) -> String
      argument arg0<> -> Integer
      argument arg1<optional> -> String
    method lstrip () -> String
    method lstrip! () -> String | NilClass
    method match (arg0) -> MatchData
      argument arg0<> -> Regexp | String
      argument arg1<optional>
    method next () -> String
    method next! () -> String
    method oct () -> Integer
    method ord () -> Integer
    method partition (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<> -> Regexp | String
    method prepend (arg0) -> String
      argument arg0<> -> String
    method replace (arg0) -> String
      argument arg0<> -> String
    method reverse () -> String
    method rindex (arg0, arg1) -> Integer | NilClass
      argument arg0<> -> String | Regexp
      argument arg1<optional> -> Integer
    method rjust (arg0, arg1) -> String
      argument arg0<> -> Integer
      argument arg1<optional> -> String
    method rpartition (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<> -> String | Regexp
    method rstrip () -> String
    method rstrip! () -> String
    method scan (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = AppliedType {
                klass = ::<constant:Array>
                targs = [
                  <constant:Elem> = String
                ]
              } | String
      ]
    }
      argument arg0<> -> Regexp | String
      argument blk<block>
    method scrub (arg0) -> String
      argument arg0<optional> -> String
      argument blk<block>
    method scrub! (arg0) -> String
      argument arg0<optional> -> String
      argument blk<block>
    method setbyte (arg0, arg1) -> Integer
      argument arg0<> -> Integer
      argument arg1<> -> Integer
    method size () -> Integer
    method slice (arg0, arg1) -> String | NilClass
      argument arg0<> -> Integer
      argument arg1<optional> -> Integer
    method slice! (arg0, arg1) -> String | NilClass
      argument arg0<> -> Integer
      argument arg1<optional> -> Integer
    method split (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<optional> -> Regexp | String
      argument arg1<optional> -> Integer
    method squeeze (arg0) -> String
      argument arg0<optional> -> String
    method squeeze! (arg0) -> String
      argument arg0<optional> -> String
    method start_with? (arg0) -> TrueClass | FalseClass
      argument arg0<repeated> -> String
    method strip () -> String
    method strip! () -> String
    method sub (arg0, arg1) -> String
      argument arg0<> -> Regexp | String
      argument arg1<optional> -> AppliedType {
            klass = ::<constant:Hash>
            targs = [
              <constant:K> = untyped
              <constant:V> = untyped
              <constant:Elem> = untyped
            ]
          } | String
      argument blk<block>
    method sub! (arg0, arg1) -> String
      argument arg0<> -> Regexp | String
      argument arg1<optional> -> String
      argument blk<block>
    method succ () -> String
    method sum (arg0) -> Integer
      argument arg0<optional> -> Integer
    method swapcase () -> String
    method swapcase! () -> String | NilClass
    method taint () -> String
    method to_c () -> Complex
    method to_f () -> Float
    method to_i (arg0) -> Integer
      argument arg0<optional> -> Integer
    method to_r () -> Rational
    method to_s () -> String
    method to_str () -> String
    method to_sym () -> Symbol
    method tr (arg0, arg1) -> String
      argument arg0<> -> String
      argument arg1<> -> String
    method tr! (arg0, arg1) -> String | NilClass
      argument arg0<> -> String
      argument arg1<> -> String
    method tr_s (arg0, arg1) -> String
      argument arg0<> -> String
      argument arg1<> -> String
    method tr_s! (arg0, arg1) -> String | NilClass
      argument arg0<> -> String
      argument arg1<> -> String
    method trust () -> String
    method unpack (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<> -> String
    method untaint () -> String
    method untrust () -> String
    method upcase () -> String
    method upcase! () -> String | NilClass
    method upto (arg0, arg1) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> String
      argument arg1<optional> -> BasicObject
      argument blk<block>
    method valid_encoding? () -> TrueClass | FalseClass
  class <constant:StringIO>[<constant:Elem>] < ::<constant:Data> (<constant:Enumerable>) -> <Class:StringIO>
    method clone () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method dup () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method freeze () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method taint () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method trust () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method untaint () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    }
    method untrust () -> AppliedType {
      klass = ::<constant:StringIO>
      targs = [
        <constant:Elem> = String
      ]
    }
    typeMember(=) <constant:Elem> -> String
  class <constant:StringScanner> < ::<constant:Object> () -> <Class:StringScanner>
    method eos? () -> TrueClass | FalseClass
    method getch () -> String
    method scan (arg0) -> String
      argument arg0<> -> Regexp
  class <constant:Struct>[<constant:Elem>] < ::<constant:Object> (<constant:Enumerable>) -> <Class:Struct>
    method clone () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method dup () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method freeze () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method taint () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method trust () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method untaint () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    method untrust () -> AppliedType {
      klass = ::<constant:Struct>
      targs = [
        <constant:Elem> = untyped
      ]
    }
    typeMember(=) <constant:Elem> -> untyped
  class <constant:Symbol> < ::<constant:Object> (<constant:Comparable>) -> <Class:Symbol>
    method <=> (other) -> Integer | NilClass
      argument other<> -> Symbol
    method <overload N.1 : []> (n) -> String
      argument idx<>
      argument n<optional> -> Integer
    method <overload N.1 : slice> (n) -> String
      argument idx<>
      argument n<optional> -> Integer
    method <overload N.2 : []> () -> String
      argument idx<>
      argument n<optional>
    method <overload N.2 : slice> () -> String
      argument idx<>
      argument n<optional>
    method == (obj) -> TrueClass | FalseClass
      argument obj<> -> BasicObject
    method =~ (obj) -> Integer | NilClass
      argument obj<> -> BasicObject
    method [] (idx) -> String
      argument idx<> -> Integer
      argument n<optional>
    method capitalize () -> Symbol
    method casecmp (other) -> Integer | NilClass
      argument other<> -> Symbol
    method clone () -> Symbol
    method downcase () -> Symbol
    method dup () -> Symbol
    method empty? () -> TrueClass | FalseClass
    method encoding () -> Encoding
    method freeze () -> Symbol
    method id2name () -> String
    method inspect () -> String
    method intern () -> Symbol
    method length () -> Integer
    method match (obj) -> Integer | NilClass
      argument obj<> -> BasicObject
    method size () -> Integer
    method slice (idx) -> String
      argument idx<> -> Integer
      argument n<optional>
    method succ () -> Symbol
    method swapcase () -> Symbol
    method taint () -> Symbol
    method to_proc () -> Proc
    method to_s () -> String
    method to_sym () -> Symbol
    method trust () -> Symbol
    method untaint () -> Symbol
    method untrust () -> Symbol
    method upcase () -> Symbol
  class <constant:SyntaxError> < ::<constant:ScriptError> () -> <Class:SyntaxError>
    method clone () -> SyntaxError
    method dup () -> SyntaxError
    method freeze () -> SyntaxError
    method taint () -> SyntaxError
    method trust () -> SyntaxError
    method untaint () -> SyntaxError
    method untrust () -> SyntaxError
  class <constant:SystemCallError> < ::<constant:StandardError> () -> <Class:SystemCallError>
    method clone () -> SystemCallError
    method dup () -> SystemCallError
    method freeze () -> SystemCallError
    method taint () -> SystemCallError
    method trust () -> SystemCallError
    method untaint () -> SystemCallError
    method untrust () -> SystemCallError
  class <constant:SystemExit> < ::<constant:Exception> () -> <Class:SystemExit>
    method clone () -> SystemExit
    method dup () -> SystemExit
    method freeze () -> SystemExit
    method taint () -> SystemExit
    method trust () -> SystemExit
    method untaint () -> SystemExit
    method untrust () -> SystemExit
  class <constant:SystemStackError> < ::<constant:Exception> () -> <Class:SystemStackError>
    method clone () -> SystemStackError
    method dup () -> SystemStackError
    method freeze () -> SystemStackError
    method taint () -> SystemStackError
    method trust () -> SystemStackError
    method untaint () -> SystemStackError
    method untrust () -> SystemStackError
  class <constant:T> < ::<constant:Object> () -> <Class:T>
    class <constant:Array> () -> <Class:T::Array>
    class <constant:Enumerable> () -> <Class:T::Enumerable>
    class <constant:Generic> (<constant:BasicObject>, <constant:Helpers>) -> <Class:T::Generic>
    class <constant:Hash> () -> <Class:T::Hash>
    class <constant:Helpers> (<constant:BasicObject>) -> <Class:T::Helpers>
    class <constant:Proc> () -> <Class:T::Proc>
    class <singleton class:<constant:Array>> < ::<constant:Module> ()
    class <singleton class:<constant:Enumerable>> < ::<constant:Module> ()
    class <singleton class:<constant:Generic>> < ::<constant:Module> ()
    class <singleton class:<constant:Hash>> < ::<constant:Module> ()
    class <singleton class:<constant:Helpers>> < ::<constant:Module> ()
    class <singleton class:<constant:Proc>> < ::<constant:Module> ()
    method all ()
    method any ()
    method nilable ()
    method untyped ()
  class <constant:Thread> < ::<constant:Object> () -> <Class:Thread>
    class <constant:Backtrace> < ::<constant:Object> () -> <Class:Thread::Backtrace>
      class <constant:Location> < ::<constant:Object> () -> <Class:Thread::Backtrace::Location>
      class <singleton class:<constant:Location>> < ::<singleton class:<constant:Object>> ()
    class <constant:ConditionVariable> < ::<constant:Object> () -> <Class:Thread::ConditionVariable>
    class <constant:Mutex> < ::<constant:Object> () -> <Class:Thread::Mutex>
    class <constant:Queue> < ::<constant:Object> () -> <Class:Thread::Queue>
    class <constant:SizedQueue> < ::<constant:Thread>::<constant:Queue> () -> <Class:Thread::SizedQueue>
    class <singleton class:<constant:Backtrace>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:ConditionVariable>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:Mutex>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:Queue>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:SizedQueue>> < ::<constant:Thread>::<singleton class:<constant:Queue>> ()
    method clone () -> Thread
    method dup () -> Thread
    method freeze () -> Thread
    method taint () -> Thread
    method trust () -> Thread
    method untaint () -> Thread
    method untrust () -> Thread
  class <constant:ThreadError> < ::<constant:StandardError> () -> <Class:ThreadError>
    method clone () -> ThreadError
    method dup () -> ThreadError
    method freeze () -> ThreadError
    method taint () -> ThreadError
    method trust () -> ThreadError
    method untaint () -> ThreadError
    method untrust () -> ThreadError
  class <constant:ThreadGroup> < ::<constant:Object> () -> <Class:ThreadGroup>
    method clone () -> ThreadGroup
    method dup () -> ThreadGroup
    method freeze () -> ThreadGroup
    method taint () -> ThreadGroup
    method trust () -> ThreadGroup
    method untaint () -> ThreadGroup
    method untrust () -> ThreadGroup
  class <constant:Time> < ::<constant:Object> (<constant:Comparable>) -> <Class:Time>
    method + (arg0) -> Time
      argument arg0<> -> Numeric
    method - (arg0) -> Float
      argument arg0<> -> Time
    method <=> (other) -> Integer | NilClass
      argument other<> -> Time
    method <overload N.1 : -> (arg0) -> Time
      argument arg0<> -> Numeric
    method asctime () -> String
    method clone () -> Time
    method ctime () -> String
    method day () -> Integer
    method dst? () -> TrueClass | FalseClass
    method dup () -> Time
    method eql? (arg0) -> TrueClass | FalseClass
      argument arg0<> -> BasicObject
    method freeze () -> Time
    method friday? () -> TrueClass | FalseClass
    method getgm () -> Time
    method getlocal (utc_offset) -> Time
      argument utc_offset<optional> -> Integer
    method getutc () -> Time
    method gmt? () -> TrueClass | FalseClass
    method gmt_offset () -> Integer
    method gmtime () -> Time
    method gmtoff () -> Integer
    method hash () -> Integer
    method hour () -> Integer
    method initialize (year, month, day, hour, min, sec, usec_with_frac) -> Object
      argument day<optional> -> Integer
      argument hour<optional> -> Integer
      argument min<optional> -> Integer
      argument month<optional> -> Integer | String
      argument sec<optional> -> Numeric
      argument usec_with_frac<optional> -> Numeric
      argument year<optional> -> Integer
    method inspect () -> String
    method isdst () -> TrueClass | FalseClass
    method localtime (utc_offset) -> Time
      argument utc_offset<optional> -> String
    method mday () -> Integer
    method min () -> Integer
    method mon () -> Integer
    method monday? () -> TrueClass | FalseClass
    method month () -> Integer
    method nsec () -> Integer
    method round (arg0) -> Time
      argument arg0<> -> Integer
    method saturday? () -> TrueClass | FalseClass
    method sec () -> Integer
    method strftime (arg0) -> String
      argument arg0<> -> String
    method subsec () -> Numeric
    method succ () -> Time
    method sunday? () -> TrueClass | FalseClass
    method taint () -> Time
    method thursday? () -> TrueClass | FalseClass
    method to_a () -> TupleType {
      0 = Integer
      1 = Integer
      2 = Integer
      3 = Integer
      4 = Integer
      5 = Integer
      6 = Integer
      7 = Integer
      8 = TrueClass | FalseClass
      9 = String
    }
    method to_date () -> Date
    method to_datetime () -> DateTime
    method to_f () -> Float
    method to_i () -> Numeric
    method to_r () -> Rational
    method to_s () -> String
    method to_time () -> Time
    method trust () -> Time
    method tuesday? () -> TrueClass | FalseClass
    method tv_nsec () -> Numeric
    method tv_sec () -> Numeric
    method tv_usec () -> Numeric
    method untaint () -> Time
    method untrust () -> Time
    method usec () -> Numeric
    method utc () -> Time
    method utc? () -> TrueClass | FalseClass
    method utc_offset () -> Integer
    method wday () -> Integer
    method wednesday? () -> TrueClass | FalseClass
    method yday () -> Integer
    method year () -> Integer
    method zone () -> String
  class <constant:TracePoint> < ::<constant:Object> () -> <Class:TracePoint>
    method clone () -> TracePoint
    method dup () -> TracePoint
    method freeze () -> TracePoint
    method taint () -> TracePoint
    method trust () -> TracePoint
    method untaint () -> TracePoint
    method untrust () -> TracePoint
  class <constant:TrueClass> < ::<constant:Object> () -> <Class:TrueClass>
    method clone () -> TrueClass
    method dup () -> TrueClass
    method freeze () -> TrueClass
    method taint () -> TrueClass
    method trust () -> TrueClass
    method untaint () -> TrueClass
    method untrust () -> TrueClass
  class <constant:TypeError> < ::<constant:StandardError> () -> <Class:TypeError>
    method clone () -> TypeError
    method dup () -> TypeError
    method freeze () -> TypeError
    method taint () -> TypeError
    method trust () -> TypeError
    method untaint () -> TypeError
    method untrust () -> TypeError
  class <constant:URI> (<constant:BasicObject>) -> <Class:URI>
    class <constant:BadURIError> < ::<constant:URI>::<constant:Error> () -> <Class:URI::BadURIError>
    class <constant:Error> < ::<constant:StandardError> () -> <Class:URI::Error>
    class <constant:Escape> (<constant:BasicObject>) -> <Class:URI::Escape>
    class <constant:FTP> < ::<constant:URI>::<constant:Generic> () -> <Class:URI::FTP>
      static-field <constant:ABS_PATH> -> Regexp
      static-field <constant:ABS_URI> -> Regexp
      static-field <constant:ABS_URI_REF> -> Regexp
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser
      static-field <constant:DEFAULT_PORT> -> Integer
      static-field <constant:ESCAPED> -> Regexp
      static-field <constant:FRAGMENT> -> Regexp
      static-field <constant:HOST> -> Regexp
      static-field <constant:HTML5ASCIIINCOMPAT> -> String
      static-field <constant:OPAQUE> -> Regexp
      static-field <constant:PORT> -> Regexp
      static-field <constant:QUERY> -> Regexp
      static-field <constant:REGISTRY> -> Regexp
      static-field <constant:REL_PATH> -> Regexp
      static-field <constant:REL_URI> -> Regexp
      static-field <constant:REL_URI_REF> -> Regexp
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser
      static-field <constant:SCHEME> -> Regexp
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:TYPECODE> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:TYPECODE_PREFIX> -> String
      static-field <constant:UNSAFE> -> Regexp
      static-field <constant:URI_REF> -> Regexp
      static-field <constant:USERINFO> -> Regexp
      static-field <constant:USE_REGISTRY> -> FalseClass
      static-field <constant:VERSION> -> String
      static-field <constant:VERSION_CODE> -> String
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
    class <constant:Generic> < ::<constant:Object> (<constant:URI>, <constant:RFC2396_REGEXP>) -> <Class:URI::Generic>
      static-field <constant:ABS_PATH> -> Regexp
      static-field <constant:ABS_URI> -> Regexp
      static-field <constant:ABS_URI_REF> -> Regexp
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser
      static-field <constant:DEFAULT_PORT> -> NilClass
      static-field <constant:ESCAPED> -> Regexp
      static-field <constant:FRAGMENT> -> Regexp
      static-field <constant:HOST> -> Regexp
      static-field <constant:HTML5ASCIIINCOMPAT> -> String
      static-field <constant:OPAQUE> -> Regexp
      static-field <constant:PORT> -> Regexp
      static-field <constant:QUERY> -> Regexp
      static-field <constant:REGISTRY> -> Regexp
      static-field <constant:REL_PATH> -> Regexp
      static-field <constant:REL_URI> -> Regexp
      static-field <constant:REL_URI_REF> -> Regexp
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser
      static-field <constant:SCHEME> -> Regexp
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:UNSAFE> -> Regexp
      static-field <constant:URI_REF> -> Regexp
      static-field <constant:USERINFO> -> Regexp
      static-field <constant:USE_REGISTRY> -> FalseClass
      static-field <constant:VERSION> -> String
      static-field <constant:VERSION_CODE> -> String
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
    class <constant:HTTP> < ::<constant:URI>::<constant:Generic> () -> <Class:URI::HTTP>
      static-field <constant:ABS_PATH> -> Regexp
      static-field <constant:ABS_URI> -> Regexp
      static-field <constant:ABS_URI_REF> -> Regexp
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser
      static-field <constant:DEFAULT_PORT> -> Integer
      static-field <constant:ESCAPED> -> Regexp
      static-field <constant:FRAGMENT> -> Regexp
      static-field <constant:HOST> -> Regexp
      static-field <constant:HTML5ASCIIINCOMPAT> -> String
      static-field <constant:OPAQUE> -> Regexp
      static-field <constant:PORT> -> Regexp
      static-field <constant:QUERY> -> Regexp
      static-field <constant:REGISTRY> -> Regexp
      static-field <constant:REL_PATH> -> Regexp
      static-field <constant:REL_URI> -> Regexp
      static-field <constant:REL_URI_REF> -> Regexp
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser
      static-field <constant:SCHEME> -> Regexp
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:UNSAFE> -> Regexp
      static-field <constant:URI_REF> -> Regexp
      static-field <constant:USERINFO> -> Regexp
      static-field <constant:USE_REGISTRY> -> FalseClass
      static-field <constant:VERSION> -> String
      static-field <constant:VERSION_CODE> -> String
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
    class <constant:HTTPS> < ::<constant:URI>::<constant:HTTP> () -> <Class:URI::HTTPS>
      static-field <constant:ABS_PATH> -> Regexp
      static-field <constant:ABS_URI> -> Regexp
      static-field <constant:ABS_URI_REF> -> Regexp
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser
      static-field <constant:DEFAULT_PORT> -> Integer
      static-field <constant:ESCAPED> -> Regexp
      static-field <constant:FRAGMENT> -> Regexp
      static-field <constant:HOST> -> Regexp
      static-field <constant:HTML5ASCIIINCOMPAT> -> String
      static-field <constant:OPAQUE> -> Regexp
      static-field <constant:PORT> -> Regexp
      static-field <constant:QUERY> -> Regexp
      static-field <constant:REGISTRY> -> Regexp
      static-field <constant:REL_PATH> -> Regexp
      static-field <constant:REL_URI> -> Regexp
      static-field <constant:REL_URI_REF> -> Regexp
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser
      static-field <constant:SCHEME> -> Regexp
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:UNSAFE> -> Regexp
      static-field <constant:URI_REF> -> Regexp
      static-field <constant:USERINFO> -> Regexp
      static-field <constant:USE_REGISTRY> -> FalseClass
      static-field <constant:VERSION> -> String
      static-field <constant:VERSION_CODE> -> String
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
    class <constant:InvalidComponentError> < ::<constant:URI>::<constant:Error> () -> <Class:URI::InvalidComponentError>
    class <constant:InvalidURIError> < ::<constant:URI>::<constant:Error> () -> <Class:URI::InvalidURIError>
    class <constant:LDAP> < ::<constant:URI>::<constant:Generic> () -> <Class:URI::LDAP>
      static-field <constant:ABS_PATH> -> Regexp
      static-field <constant:ABS_URI> -> Regexp
      static-field <constant:ABS_URI_REF> -> Regexp
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser
      static-field <constant:DEFAULT_PORT> -> Integer
      static-field <constant:ESCAPED> -> Regexp
      static-field <constant:FRAGMENT> -> Regexp
      static-field <constant:HOST> -> Regexp
      static-field <constant:HTML5ASCIIINCOMPAT> -> String
      static-field <constant:OPAQUE> -> Regexp
      static-field <constant:PORT> -> Regexp
      static-field <constant:QUERY> -> Regexp
      static-field <constant:REGISTRY> -> Regexp
      static-field <constant:REL_PATH> -> Regexp
      static-field <constant:REL_URI> -> Regexp
      static-field <constant:REL_URI_REF> -> Regexp
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser
      static-field <constant:SCHEME> -> Regexp
      static-field <constant:SCOPE> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:SCOPE_BASE> -> String
      static-field <constant:SCOPE_ONE> -> String
      static-field <constant:SCOPE_SUB> -> String
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:UNSAFE> -> Regexp
      static-field <constant:URI_REF> -> Regexp
      static-field <constant:USERINFO> -> Regexp
      static-field <constant:USE_REGISTRY> -> FalseClass
      static-field <constant:VERSION> -> String
      static-field <constant:VERSION_CODE> -> String
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
    class <constant:LDAPS> < ::<constant:URI>::<constant:LDAP> () -> <Class:URI::LDAPS>
      static-field <constant:ABS_PATH> -> Regexp
      static-field <constant:ABS_URI> -> Regexp
      static-field <constant:ABS_URI_REF> -> Regexp
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser
      static-field <constant:DEFAULT_PORT> -> Integer
      static-field <constant:ESCAPED> -> Regexp
      static-field <constant:FRAGMENT> -> Regexp
      static-field <constant:HOST> -> Regexp
      static-field <constant:HTML5ASCIIINCOMPAT> -> String
      static-field <constant:OPAQUE> -> Regexp
      static-field <constant:PORT> -> Regexp
      static-field <constant:QUERY> -> Regexp
      static-field <constant:REGISTRY> -> Regexp
      static-field <constant:REL_PATH> -> Regexp
      static-field <constant:REL_URI> -> Regexp
      static-field <constant:REL_URI_REF> -> Regexp
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser
      static-field <constant:SCHEME> -> Regexp
      static-field <constant:SCOPE> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:SCOPE_BASE> -> String
      static-field <constant:SCOPE_ONE> -> String
      static-field <constant:SCOPE_SUB> -> String
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:UNSAFE> -> Regexp
      static-field <constant:URI_REF> -> Regexp
      static-field <constant:USERINFO> -> Regexp
      static-field <constant:USE_REGISTRY> -> FalseClass
      static-field <constant:VERSION> -> String
      static-field <constant:VERSION_CODE> -> String
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
    class <constant:MailTo> < ::<constant:URI>::<constant:Generic> () -> <Class:URI::MailTo>
      static-field <constant:ABS_PATH> -> Regexp
      static-field <constant:ABS_URI> -> Regexp
      static-field <constant:ABS_URI_REF> -> Regexp
      static-field <constant:COMPONENT> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser
      static-field <constant:DEFAULT_PORT> -> NilClass
      static-field <constant:EMAIL_REGEXP> -> Regexp
      static-field <constant:ESCAPED> -> Regexp
      static-field <constant:FRAGMENT> -> Regexp
      static-field <constant:HEADER_REGEXP> -> Regexp
      static-field <constant:HOST> -> Regexp
      static-field <constant:HTML5ASCIIINCOMPAT> -> String
      static-field <constant:OPAQUE> -> Regexp
      static-field <constant:PORT> -> Regexp
      static-field <constant:QUERY> -> Regexp
      static-field <constant:REGISTRY> -> Regexp
      static-field <constant:REL_PATH> -> Regexp
      static-field <constant:REL_URI> -> Regexp
      static-field <constant:REL_URI_REF> -> Regexp
      static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser
      static-field <constant:SCHEME> -> Regexp
      static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
      static-field <constant:UNSAFE> -> Regexp
      static-field <constant:URI_REF> -> Regexp
      static-field <constant:USERINFO> -> Regexp
      static-field <constant:USE_REGISTRY> -> FalseClass
      static-field <constant:VERSION> -> String
      static-field <constant:VERSION_CODE> -> String
      static-field <constant:WEB_ENCODINGS_> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = untyped
          <constant:V> = untyped
          <constant:Elem> = untyped
        ]
      }
    class <constant:RFC2396_Parser> < ::<constant:Object> (<constant:RFC2396_REGEXP>) -> <Class:URI::RFC2396_Parser>
    class <constant:RFC2396_REGEXP> (<constant:BasicObject>) -> <Class:URI::RFC2396_REGEXP>
      class <constant:PATTERN> (<constant:BasicObject>) -> <Class:URI::RFC2396_REGEXP::PATTERN>
        static-field <constant:ABS_PATH> -> String
        static-field <constant:ABS_URI> -> String
        static-field <constant:ALNUM> -> String
        static-field <constant:ALPHA> -> String
        static-field <constant:DOMLABEL> -> String
        static-field <constant:ESCAPED> -> String
        static-field <constant:FRAGMENT> -> String
        static-field <constant:HEX> -> String
        static-field <constant:HIER_PART> -> String
        static-field <constant:HOST> -> String
        static-field <constant:HOSTNAME> -> String
        static-field <constant:HOSTPORT> -> String
        static-field <constant:IPV4ADDR> -> String
        static-field <constant:IPV6ADDR> -> String
        static-field <constant:IPV6REF> -> String
        static-field <constant:NET_PATH> -> String
        static-field <constant:OPAQUE_PART> -> String
        static-field <constant:PATH_SEGMENTS> -> String
        static-field <constant:PORT> -> String
        static-field <constant:QUERY> -> String
        static-field <constant:REG_NAME> -> String
        static-field <constant:REL_PATH> -> String
        static-field <constant:REL_SEGMENT> -> String
        static-field <constant:REL_URI> -> String
        static-field <constant:RESERVED> -> String
        static-field <constant:SCHEME> -> String
        static-field <constant:TOPLABEL> -> String
        static-field <constant:UNRESERVED> -> String
        static-field <constant:URIC> -> String
        static-field <constant:URIC_NO_SLASH> -> String
        static-field <constant:URI_REF> -> String
        static-field <constant:USERINFO> -> String
        static-field <constant:X_ABS_URI> -> String
        static-field <constant:X_REL_URI> -> String
      class <singleton class:<constant:PATTERN>> < ::<constant:Module> ()
    class <constant:RFC3986_Parser> < ::<constant:Object> () -> <Class:URI::RFC3986_Parser>
      static-field <constant:RFC3986_URI> -> Regexp
    class <constant:Util> (<constant:BasicObject>) -> <Class:URI::Util>
    class <singleton class:<constant:BadURIError>> < ::<constant:URI>::<singleton class:<constant:Error>> ()
    class <singleton class:<constant:Error>> < ::<singleton class:<constant:StandardError>> ()
    class <singleton class:<constant:Escape>> < ::<constant:Module> ()
    class <singleton class:<constant:FTP>> < ::<constant:URI>::<singleton class:<constant:Generic>> ()
    class <singleton class:<constant:Generic>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:HTTP>> < ::<constant:URI>::<singleton class:<constant:Generic>> ()
    class <singleton class:<constant:HTTPS>> < ::<constant:URI>::<singleton class:<constant:HTTP>> ()
    class <singleton class:<constant:InvalidComponentError>> < ::<constant:URI>::<singleton class:<constant:Error>> ()
    class <singleton class:<constant:InvalidURIError>> < ::<constant:URI>::<singleton class:<constant:Error>> ()
    class <singleton class:<constant:LDAP>> < ::<constant:URI>::<singleton class:<constant:Generic>> ()
    class <singleton class:<constant:LDAPS>> < ::<constant:URI>::<singleton class:<constant:LDAP>> ()
    class <singleton class:<constant:MailTo>> < ::<constant:URI>::<singleton class:<constant:Generic>> ()
    class <singleton class:<constant:RFC2396_Parser>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:RFC2396_REGEXP>> < ::<constant:Module> ()
    class <singleton class:<constant:RFC3986_Parser>> < ::<singleton class:<constant:Object>> ()
    class <singleton class:<constant:Util>> < ::<constant:Module> ()
    static-field <constant:ABS_PATH> -> Regexp
    static-field <constant:ABS_URI> -> Regexp
    static-field <constant:ABS_URI_REF> -> Regexp
    static-field <constant:DEFAULT_PARSER> -> URI::RFC2396_Parser
    static-field <constant:ESCAPED> -> Regexp
    static-field <constant:FRAGMENT> -> Regexp
    static-field <constant:HOST> -> Regexp
    static-field <constant:HTML5ASCIIINCOMPAT> -> String
    static-field <constant:OPAQUE> -> Regexp
    static-field <constant:PORT> -> Regexp
    static-field <constant:QUERY> -> Regexp
    static-field <constant:REGISTRY> -> Regexp
    static-field <constant:REL_PATH> -> Regexp
    static-field <constant:REL_URI> -> Regexp
    static-field <constant:REL_URI_REF> -> Regexp
    static-field <constant:RFC3986_PARSER> -> URI::RFC3986_Parser
    static-field <constant:SCHEME> -> Regexp
    static-field <constant:TBLDECWWWCOMP_> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:TBLENCWWWCOMP_> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    static-field <constant:UNSAFE> -> Regexp
    static-field <constant:URI_REF> -> Regexp
    static-field <constant:USERINFO> -> Regexp
    static-field <constant:VERSION> -> String
    static-field <constant:VERSION_CODE> -> String
    static-field <constant:WEB_ENCODINGS_> -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
  class <constant:UnboundMethod> < ::<constant:Object> () -> <Class:UnboundMethod>
    method clone () -> UnboundMethod
    method dup () -> UnboundMethod
    method freeze () -> UnboundMethod
    method taint () -> UnboundMethod
    method trust () -> UnboundMethod
    method untaint () -> UnboundMethod
    method untrust () -> UnboundMethod
  class <constant:UncaughtThrowError> < ::<constant:ArgumentError> () -> <Class:UncaughtThrowError>
    method clone () -> UncaughtThrowError
    method dup () -> UncaughtThrowError
    method freeze () -> UncaughtThrowError
    method taint () -> UncaughtThrowError
    method trust () -> UncaughtThrowError
    method untaint () -> UncaughtThrowError
    method untrust () -> UncaughtThrowError
  class <constant:Warning> (<constant:BasicObject>) -> <Class:Warning>
  class <constant:YAML> (<constant:BasicObject>) -> <Class:YAML>
  class <constant:ZeroDivisionError> < ::<constant:StandardError> () -> <Class:ZeroDivisionError>
    method clone () -> ZeroDivisionError
    method dup () -> ZeroDivisionError
    method freeze () -> ZeroDivisionError
    method taint () -> ZeroDivisionError
    method trust () -> ZeroDivisionError
    method untaint () -> ZeroDivisionError
    method untrust () -> ZeroDivisionError
  class <constant:nil> < ::<constant:Object> () -> NilClass
  class <constant:untyped> () -> untyped
  class <singleton class:<constant:<<JUNK>>>> < ::<constant:Module> ()
  class <singleton class:<constant:<root>>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:<todo sym>>> < ::<constant:Module> ()
  class <singleton class:<constant:Abbrev>> < ::<constant:Module> ()
    method abbrev (words) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = String
        <constant:V> = String
        <constant:Elem> = untyped
      ]
    }
      argument words<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      }
  class <singleton class:<constant:ArgumentError>> < ::<singleton class:<constant:StandardError>> ()
  class <singleton class:<constant:Array>> < ::<singleton class:<constant:Object>> (<constant:Generic>)
    method [] (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument arg0<repeated> -> BasicObject
  class <singleton class:<constant:Base64>> < ::<constant:Module> ()
    method decode64 (str) -> String
      argument str<> -> String
    method encode64 (bin) -> String
      argument bin<> -> String
    method strict_decode64 (str) -> String
      argument str<> -> String
    method strict_encode64 (bin) -> String
      argument bin<> -> String
    method urlsafe_decode64 (str) -> String
      argument str<> -> String
    method urlsafe_encode64 (bin) -> String
      argument bin<> -> String
  class <singleton class:<constant:BasicObject>> < ::<constant:Class> ()
  class <singleton class:<constant:Benchmark>> < ::<constant:Module> ()
    method benchmark (caption, label_width, format, labels) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Benchmark::Tms
      ]
    }
      argument caption<> -> String
      argument format<optional> -> String
      argument label_width<optional> -> Integer
      argument labels<repeated> -> String
    method bm (label_width, labels, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Benchmark::Tms
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = NilClass
          <constant:Arg0> = Process
        ]
      }
      argument label_width<optional> -> Integer
      argument labels<repeated> -> String
    method bmbm (width, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Benchmark::Tms
      ]
    }
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = NilClass
          <constant:Arg0> = Process
        ]
      }
      argument width<optional> -> Integer
    method measure (label) -> Benchmark::Tms
      argument label<optional> -> String
    method realtime (blk) -> Integer
      argument blk<block> -> BasicObject
  class <singleton class:<constant:BigDecimal>> < ::<singleton class:<constant:Numeric>> ()
  class <singleton class:<constant:BigMath>> < ::<constant:Module> ()
    method exp (arg0, arg1) -> BigDecimal
      argument arg0<> -> Integer
      argument arg1<> -> Integer
    method log (arg0, arg1) -> BigDecimal
      argument arg0<> -> Integer
      argument arg1<> -> Integer
  class <singleton class:<constant:Binding>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:CSV>> < ::<singleton class:<constant:Object>> (<constant:Generic>)
    method foreach (path, options, blk) -> NilClass
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Array>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
      argument options<optional> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = Symbol
          <constant:V> = BasicObject
          <constant:Elem> = untyped
        ]
      }
      argument path<> -> AppliedType {
            klass = ::<constant:File>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
  class <singleton class:<constant:Class>> < ::<singleton class:<constant:Module>> ()
  class <singleton class:<constant:ClosedQueueError>> < ::<singleton class:<constant:StopIteration>> ()
  class <singleton class:<constant:Comparable>> < ::<constant:Module> ()
  class <singleton class:<constant:Complex>> < ::<singleton class:<constant:Numeric>> ()
  class <singleton class:<constant:Coverage>> < ::<constant:Module> ()
    method result () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = String
        <constant:V> = AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = Integer | NilClass
            ]
          }
        <constant:Elem> = untyped
      ]
    }
    method start () -> NilClass
  class <singleton class:<constant:Data>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:Date>> < ::<singleton class:<constant:Object>> ()
    method _httpdate (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> String
    method _iso8601 (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> String
    method _jisx0301 (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> String
    method _load (arg0) -> untyped
      argument arg0<> -> untyped
    method _parse (arg0, comp) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> String
      argument comp<optional> -> TrueClass | FalseClass
    method _rfc2822 (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> String
    method _rfc3339 (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> String
    method _rfc822 (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> String
    method _strptime (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method _xmlschema (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> String
    method civil (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method commercial (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method gregorian_leap? (arg0) -> untyped
      argument arg0<> -> untyped
    method httpdate (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method iso8601 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method jd (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method jisx0301 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method julian_leap? (arg0) -> untyped
      argument arg0<> -> untyped
    method leap? (arg0) -> untyped
      argument arg0<> -> untyped
    method new (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method ordinal (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method parse (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method rfc2822 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method rfc3339 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method rfc822 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method strptime (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method today (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method valid_civil? (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method valid_commercial? (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method valid_date? (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method valid_jd? (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method valid_ordinal? (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method xmlschema (arg0) -> untyped
      argument arg0<repeated> -> untyped
  class <singleton class:<constant:DateTime>> < ::<singleton class:<constant:Date>> ()
    method _strptime (arg0, format) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument arg0<> -> String
      argument format<optional> -> String
    method civil (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method commercial (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method httpdate (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method iso8601 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method jd (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method jisx0301 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method new (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method now (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method ordinal (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method parse (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method rfc2822 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method rfc3339 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method rfc822 (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method strptime (arg0) -> untyped
      argument arg0<repeated> -> untyped
    method xmlschema (arg0) -> untyped
      argument arg0<repeated> -> untyped
  class <singleton class:<constant:DidYouMean>> < ::<constant:Module> ()
  class <singleton class:<constant:Dir>> < ::<singleton class:<constant:Object>> (<constant:Generic>)
    method <overload N.1 : []> (pattern, flags, blk) -> NilClass
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
      argument flags<optional> -> Integer
      argument pattern<> -> AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          } | String
    method <overload N.1 : chdir> (arg0, blk) -> untyped
      argument arg0<optional> -> String | Pathname
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
    method <overload N.1 : foreach> (dir, arg0) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<optional> -> Encoding
      argument blk<block>
      argument dir<> -> String
    method <overload N.1 : glob> (pattern, flags, blk) -> NilClass
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
      argument flags<optional> -> Integer
      argument pattern<> -> AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          } | String
    method <overload N.1 : open> (arg0, arg1, blk) -> untyped
      argument arg0<> -> String
      argument arg1<optional> -> Encoding
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:Dir>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
    method [] (pattern, flags) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block>
      argument flags<optional> -> Integer
      argument pattern<> -> AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          } | String
    method chdir (arg0) -> Integer
      argument arg0<optional> -> String | Pathname
      argument blk<block>
    method chroot (arg0) -> Integer
      argument arg0<> -> String
    method delete (arg0) -> Integer
      argument arg0<> -> String
    method entries (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<> -> String
      argument arg1<optional> -> Encoding
    method exist? (file) -> TrueClass | FalseClass
      argument file<> -> String
    method foreach (dir, arg0, blk) -> NilClass
      argument arg0<optional> -> Encoding
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
      argument dir<> -> String
    method getwd () -> String
    method glob (pattern, flags) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block>
      argument flags<optional> -> Integer
      argument pattern<> -> AppliedType {
            klass = ::<constant:Array>
            targs = [
              <constant:Elem> = String
            ]
          } | String
    method home (arg0) -> String
      argument arg0<optional> -> String
    method mkdir (arg0, arg1) -> Integer
      argument arg0<> -> String
      argument arg1<optional> -> Integer
    method open (arg0, arg1) -> AppliedType {
      klass = ::<constant:Dir>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<> -> String
      argument arg1<optional> -> Encoding
      argument blk<block>
    method pwd () -> String
    method rmdir (arg0) -> Integer
      argument arg0<> -> String
    method unlink (arg0) -> Integer
      argument arg0<> -> String
  class <singleton class:<constant:EOFError>> < ::<singleton class:<constant:IOError>> ()
  class <singleton class:<constant:Encoding>> < ::<singleton class:<constant:Object>> ()
    method <overload N.1 : default_external=> (arg0) -> Encoding
      argument arg0<> -> Encoding
    method <overload N.1 : default_internal=> (arg0) -> Encoding | NilClass
      argument arg0<> -> Encoding
    method aliases () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = String
        <constant:V> = String
        <constant:Elem> = untyped
      ]
    }
    method compatible? (obj1, obj2) -> Encoding | NilClass
      argument obj1<> -> BasicObject
      argument obj2<> -> BasicObject
    method default_external () -> Encoding
    method default_external= (arg0) -> String
      argument arg0<> -> String
    method default_internal () -> Encoding
    method default_internal= (arg0) -> String | NilClass
      argument arg0<> -> String
    method find (arg0) -> Encoding
      argument arg0<> -> String | Encoding
    method list () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Encoding
      ]
    }
    method name_list () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
  class <singleton class:<constant:EncodingError>> < ::<singleton class:<constant:StandardError>> ()
  class <singleton class:<constant:Enumerable>> < ::<constant:Module> (<constant:Generic>)
  class <singleton class:<constant:Enumerator>> < ::<singleton class:<constant:Object>> (<constant:Generic>)
  class <singleton class:<constant:Errno>> < ::<constant:Module> ()
  class <singleton class:<constant:Exception>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:FalseClass>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:Fiber>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:FiberError>> < ::<singleton class:<constant:StandardError>> ()
  class <singleton class:<constant:File>> < ::<singleton class:<constant:IO>> (<constant:Generic>)
    method <overload N.1 : binread> (arg0, arg1) -> String
      argument arg0<> -> String
      argument arg1<optional> -> Integer
      argument arg2<optional>
    method <overload N.1 : open> (file, perm, opt, mode, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, blk) -> untyped
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:File>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
      argument encoding<optional, keyword> -> String
      argument external_encoding<optional, keyword> -> String
      argument file<optional> -> BasicObject
      argument internal_encoding<optional, keyword> -> String
      argument mode<optional, keyword> -> String
      argument opt<optional> -> Integer
      argument perm<optional> -> String
      argument textmode<optional, keyword> -> BasicObject
    method <overload N.2 : binread> (arg0, arg1, arg2) -> String
      argument arg0<> -> String
      argument arg1<optional> -> Integer
      argument arg2<optional> -> Integer
    method absolute_path (file, dir) -> String
      argument dir<optional> -> String
      argument file<> -> String
    method atime (file) -> Time
      argument file<> -> BasicObject
    method basename (file, suffix) -> String
      argument file<> -> String
      argument suffix<optional> -> String
    method binread (arg0) -> String
      argument arg0<> -> String
      argument arg1<optional>
      argument arg2<optional>
    method birthtime (file) -> Time
      argument file<> -> BasicObject
    method blockdev? (file) -> TrueClass | FalseClass
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
    method chardev? (file) -> TrueClass | FalseClass
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
    method chmod (mode, files) -> Integer
      argument files<repeated> -> String
      argument mode<> -> Integer
    method chown (owner, group, files) -> Integer
      argument files<repeated> -> String
      argument group<> -> Integer
      argument owner<> -> Integer
    method ctime (file) -> Time
      argument file<> -> BasicObject
    method delete (files) -> Integer
      argument files<repeated> -> String
    method directory? (file) -> TrueClass | FalseClass
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
    method dirname (file) -> String
      argument file<> -> String
    method executable? (file) -> TrueClass | FalseClass
      argument file<> -> String
    method executable_real? (file) -> TrueClass | FalseClass
      argument file<> -> String
    method exist? (file) -> TrueClass | FalseClass
      argument file<> -> BasicObject
    method expand_path (file, dir) -> String
      argument dir<optional> -> BasicObject
      argument file<> -> BasicObject
    method extname (path) -> String
      argument path<> -> String
    method file? (file) -> TrueClass | FalseClass
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
    method fnmatch (pattern, path, flags) -> TrueClass | FalseClass
      argument flags<optional> -> Integer
      argument path<> -> String
      argument pattern<> -> String
    method fnmatch? (pattern, path, flags) -> TrueClass | FalseClass
      argument flags<optional> -> Integer
      argument path<> -> String
      argument pattern<> -> String
    method ftype (file) -> String
      argument file<> -> String
    method grpowned? (file) -> TrueClass | FalseClass
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
    method identical? (file_1, file_2) -> TrueClass | FalseClass
      argument file_1<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
      argument file_2<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
    method join (arg0) -> String
      argument arg0<repeated> -> BasicObject
    method lchmod (mode, files) -> Integer
      argument files<repeated> -> String
      argument mode<> -> Integer
    method lchown (owner, group, files) -> Integer
      argument files<repeated> -> String
      argument group<> -> Integer
      argument owner<> -> Integer
    method link (old, new) -> Integer
      argument new<> -> String
      argument old<> -> String
    method lstat (file) -> File::Stat
      argument file<> -> String
    method mtime (file) -> Time
      argument file<> -> BasicObject
    method open (file, perm, opt, mode, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose) -> AppliedType {
      klass = ::<constant:File>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument blk<block>
      argument encoding<optional, keyword> -> String
      argument external_encoding<optional, keyword> -> String
      argument file<optional> -> String
      argument internal_encoding<optional, keyword> -> String
      argument mode<optional, keyword> -> String
      argument opt<optional> -> Integer
      argument perm<optional> -> String
      argument textmode<optional, keyword> -> BasicObject
    method owned? (file) -> TrueClass | FalseClass
      argument file<> -> String
    method path (path) -> String
      argument path<> -> String
    method pipe? (file) -> TrueClass | FalseClass
      argument file<> -> String
    method readable? (file) -> TrueClass | FalseClass
      argument file<> -> String
    method readable_real? (file) -> TrueClass | FalseClass
      argument file<> -> String
    method readlink (link) -> String
      argument link<> -> String
    method realdirpath (pathname, dir) -> String
      argument dir<optional> -> String
      argument pathname<> -> String
    method realpath (pathname, dir) -> String
      argument dir<optional> -> String
      argument pathname<> -> String
    method rename (old, new) -> Integer
      argument new<> -> String
      argument old<> -> String
    method setgid? (file) -> TrueClass | FalseClass
      argument file<> -> String
    method setuid? (file) -> TrueClass | FalseClass
      argument file<> -> String
    method size (file) -> Integer
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
    method size? (file) -> Integer | NilClass
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
    method socket? (file) -> TrueClass | FalseClass
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
    method split (file) -> TupleType {
      0 = String
      1 = String
    }
      argument file<> -> String
    method stat (file) -> File::Stat
      argument file<> -> BasicObject
    method sticky? (file) -> TrueClass | FalseClass
      argument file<> -> String
    method symlink (old, new) -> Integer
      argument new<> -> String
      argument old<> -> String
    method symlink? (file) -> TrueClass | FalseClass
      argument file<> -> String
    method truncate (file, arg0) -> Integer
      argument arg0<> -> Integer
      argument file<> -> String
    method umask (arg0) -> Integer
      argument arg0<optional> -> Integer
    method unlink (files) -> Integer
      argument files<repeated> -> String
    method utime (atime, mtime, files) -> Integer
      argument atime<> -> Time
      argument files<repeated> -> String
      argument mtime<> -> Time
    method world_readable? (file) -> Integer | NilClass
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
    method world_writable? (file) -> Integer | NilClass
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
    method writable? (file) -> Integer | NilClass
      argument file<> -> String
    method writable_real? (file) -> Integer | NilClass
      argument file<> -> String
    method zero? (file) -> Integer | NilClass
      argument file<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = untyped
            ]
          } | String
  class <singleton class:<constant:FileTest>> < ::<constant:Module> ()
  class <singleton class:<constant:FileUtils>> < ::<constant:Module> ()
    method cp_r (src, dest, preserve) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument dest<> -> String | Pathname
      argument preserve<optional> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = Symbol
          <constant:V> = TrueClass | FalseClass
          <constant:Elem> = untyped
        ]
      }
      argument src<> -> String | Pathname
    method mkdir_p (list, mode) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument list<> -> String | Pathname
      argument mode<optional> -> AppliedType {
        klass = ::<constant:Hash>
        targs = [
          <constant:K> = Symbol
          <constant:V> = TrueClass | FalseClass
          <constant:Elem> = untyped
        ]
      }
  class <singleton class:<constant:Float>> < ::<singleton class:<constant:Numeric>> ()
  class <singleton class:<constant:FloatDomainError>> < ::<singleton class:<constant:RangeError>> ()
  class <singleton class:<constant:Forwardable>> < ::<constant:Module> ()
  class <singleton class:<constant:GC>> < ::<constant:Module> ()
  class <singleton class:<constant:Gem>> < ::<constant:Module> ()
    method bin_path (name, args, requirements) -> String
      argument args<optional> -> String
      argument name<> -> String
      argument requirements<repeated> -> Gem::Requirement
    method binary_mode () -> String
    method bindir (install_dir) -> String
      argument install_dir<optional> -> String
    method clear_default_specs () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
    method clear_paths () -> NilClass
    method config_file () -> String
    method configuration () -> Gem::ConfigFile
    method configuration= (config) -> untyped
      argument config<> -> BasicObject
    method datadir (gem_name) -> String | NilClass
      argument gem_name<> -> String
    method default_bindir () -> String | NilClass
    method default_cert_path () -> String | NilClass
    method default_dir () -> String | NilClass
    method default_exec_format () -> String | NilClass
    method default_key_path () -> String | NilClass
    method default_path () -> String | NilClass
    method default_rubygems_dirs () -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass
    method default_sources () -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass
  class <singleton class:<constant:Hash>> < ::<singleton class:<constant:Object>> (<constant:Generic>)
    method [] (arg0) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument arg0<repeated> -> BasicObject
  class <singleton class:<constant:IO>> < ::<singleton class:<constant:Object>> (<constant:Generic>)
    method <overload N.1 : foreach> (name, sep, limit, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> AppliedType {
      klass = ::<constant:Enumerator>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument blk<block>
      argument encoding<optional, keyword> -> String
      argument external_encoding<optional, keyword> -> String
      argument internal_encoding<optional, keyword> -> String
      argument limit<optional> -> Integer
      argument mode<optional, keyword> -> String
      argument name<> -> String
      argument sep<optional> -> String
      argument textmode<optional, keyword> -> BasicObject
    method <overload N.1 : open> (fd, mode, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode, blk) -> untyped
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
      argument encoding<optional, keyword> -> String
      argument external_encoding<optional, keyword> -> String
      argument fd<> -> Integer
      argument internal_encoding<optional, keyword> -> String
      argument mode<optional, keyword> -> String
      argument textmode<optional, keyword> -> BasicObject
    method <overload N.1 : pipe> (int_enc, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> TupleType {
      0 = AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = String
            ]
          }
      1 = AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = String
            ]
          }
    }
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument blk<block>
      argument encoding<optional, keyword> -> String
      argument ext_or_ext_int_enc<optional>
      argument external_encoding<optional, keyword> -> String
      argument int_enc<optional> -> String
      argument internal_encoding<optional, keyword> -> String
      argument mode<optional, keyword> -> String
      argument textmode<optional, keyword> -> BasicObject
    method <overload N.2 : pipe> (ext_or_ext_int_enc, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode, blk) -> untyped
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = TupleType {
              0 = AppliedType {
                    klass = ::<constant:IO>
                    targs = [
                      <constant:Elem> = String
                    ]
                  }
              1 = AppliedType {
                    klass = ::<constant:IO>
                    targs = [
                      <constant:Elem> = String
                    ]
                  }
            }
        ]
      }
      argument encoding<optional, keyword> -> String
      argument ext_or_ext_int_enc<optional> -> String
      argument external_encoding<optional, keyword> -> String
      argument int_enc<optional>
      argument internal_encoding<optional, keyword> -> String
      argument mode<optional, keyword> -> String
      argument textmode<optional, keyword> -> BasicObject
    method <overload N.3 : pipe> (int_enc, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode, blk) -> untyped
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = TupleType {
              0 = AppliedType {
                    klass = ::<constant:IO>
                    targs = [
                      <constant:Elem> = String
                    ]
                  }
              1 = AppliedType {
                    klass = ::<constant:IO>
                    targs = [
                      <constant:Elem> = String
                    ]
                  }
            }
        ]
      }
      argument encoding<optional, keyword> -> String
      argument ext_or_ext_int_enc<optional>
      argument external_encoding<optional, keyword> -> String
      argument int_enc<optional> -> String
      argument internal_encoding<optional, keyword> -> String
      argument mode<optional, keyword> -> String
      argument textmode<optional, keyword> -> BasicObject
    method binread (name, length, offset) -> String
      argument length<optional> -> Integer
      argument name<> -> String
      argument offset<optional> -> Integer
    method binwrite (name, arg0, offset, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> Integer
      argument arg0<> -> String
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument encoding<optional, keyword> -> String
      argument external_encoding<optional, keyword> -> String
      argument internal_encoding<optional, keyword> -> String
      argument mode<optional, keyword> -> String
      argument name<> -> String
      argument offset<optional> -> Integer
      argument textmode<optional, keyword> -> BasicObject
    method copy_stream (src, dst, copy_length, src_offset) -> Integer
      argument copy_length<optional> -> Integer
      argument dst<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = String
            ]
          } | String
      argument src<> -> AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = String
            ]
          } | String
      argument src_offset<optional> -> Integer
    method for_fd (fd, mode, opt) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument fd<> -> Integer
      argument mode<optional> -> Integer
      argument opt<optional> -> Integer
    method foreach (name, sep, limit, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode, blk) -> NilClass
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = String
        ]
      }
      argument encoding<optional, keyword> -> String
      argument external_encoding<optional, keyword> -> String
      argument internal_encoding<optional, keyword> -> String
      argument limit<optional> -> Integer
      argument mode<optional, keyword> -> String
      argument name<> -> String
      argument sep<optional> -> String
      argument textmode<optional, keyword> -> BasicObject
    method open (fd, mode, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> AppliedType {
      klass = ::<constant:IO>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument blk<block>
      argument encoding<optional, keyword> -> String
      argument external_encoding<optional, keyword> -> String
      argument fd<> -> Integer
      argument internal_encoding<optional, keyword> -> String
      argument mode<optional, keyword> -> String
      argument textmode<optional, keyword> -> BasicObject
    method pipe (ext_or_ext_int_enc, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> TupleType {
      0 = AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = String
            ]
          }
      1 = AppliedType {
            klass = ::<constant:IO>
            targs = [
              <constant:Elem> = String
            ]
          }
    }
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument blk<block>
      argument encoding<optional, keyword> -> String
      argument ext_or_ext_int_enc<optional> -> String
      argument external_encoding<optional, keyword> -> String
      argument int_enc<optional>
      argument internal_encoding<optional, keyword> -> String
      argument mode<optional, keyword> -> String
      argument textmode<optional, keyword> -> BasicObject
    method read (name, length, offset, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> String
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument encoding<optional, keyword> -> String
      argument external_encoding<optional, keyword> -> String
      argument internal_encoding<optional, keyword> -> String
      argument length<optional> -> Integer
      argument mode<optional, keyword> -> String
      argument name<> -> String
      argument offset<optional> -> Integer
      argument textmode<optional, keyword> -> BasicObject
    method readlines (name, sep, limit, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument encoding<optional, keyword> -> String
      argument external_encoding<optional, keyword> -> String
      argument internal_encoding<optional, keyword> -> String
      argument limit<optional> -> Integer
      argument mode<optional, keyword> -> String
      argument name<> -> String
      argument sep<optional> -> String
      argument textmode<optional, keyword> -> BasicObject
    method select (read_array, write_array, error_array, timeout) -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = AppliedType {
                klass = ::<constant:IO>
                targs = [
                  <constant:Elem> = String
                ]
              }
          ]
        } | NilClass
      argument error_array<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
      argument read_array<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
      argument timeout<optional> -> Integer
      argument write_array<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
    method sysopen (path, mode, perm) -> Integer
      argument mode<optional> -> String
      argument path<> -> String
      argument perm<optional> -> String
    method try_convert (arg0) -> AppliedType {
          klass = ::<constant:IO>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass
      argument arg0<> -> BasicObject
    method write (name, arg0, offset, external_encoding, internal_encoding, encoding, textmode, binmode, autoclose, mode) -> Integer
      argument arg0<> -> String
      argument autoclose<optional, keyword> -> BasicObject
      argument binmode<optional, keyword> -> BasicObject
      argument encoding<optional, keyword> -> String
      argument external_encoding<optional, keyword> -> String
      argument internal_encoding<optional, keyword> -> String
      argument mode<optional, keyword> -> String
      argument name<> -> String
      argument offset<optional> -> Integer
      argument textmode<optional, keyword> -> BasicObject
  class <singleton class:<constant:IOError>> < ::<singleton class:<constant:StandardError>> ()
  class <singleton class:<constant:IndexError>> < ::<singleton class:<constant:StandardError>> ()
  class <singleton class:<constant:Integer>> < ::<singleton class:<constant:Numeric>> ()
  class <singleton class:<constant:Interrupt>> < ::<singleton class:<constant:SignalException>> ()
  class <singleton class:<constant:Kernel>> < ::<constant:Module> ()
    method <overload N.1 : Complex> (x) -> Complex
      argument x<> -> String
      argument y<optional>
    method <overload N.1 : Rational> (x) -> Rational
      argument x<> -> Object
      argument y<optional>
    method <overload N.1 : caller> () -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass
      argument length<optional>
      argument start<optional>
    method <overload N.1 : caller_locations> () -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass
      argument length<optional>
      argument start<optional>
    method <overload N.1 : exit> (status) -> NilClass
      argument status<optional> -> Integer | TrueClass | FalseClass
    method <overload N.1 : fail> (arg0) -> NilClass
      argument arg0<optional> -> String
      argument arg1<optional>
      argument arg2<optional>
    method <overload N.1 : raise> (arg0) -> NilClass
      argument arg0<optional> -> String
      argument arg1<optional>
      argument arg2<optional>
    method <overload N.2 : fail> (arg0, arg1) -> NilClass
      argument arg0<optional> -> Class
      argument arg1<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      }
      argument arg2<optional>
    method <overload N.2 : raise> (arg0, arg1, arg2) -> NilClass
      argument arg0<optional> -> Class
      argument arg1<optional> -> String
      argument arg2<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      }
    method <overload N.3 : fail> (arg0, arg1, arg2) -> NilClass
      argument arg0<optional> -> Class
      argument arg1<optional> -> String
      argument arg2<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      }
    method <overload N.3 : raise> (arg0, arg1, arg2) -> NilClass
      argument arg0<optional> -> Exception
      argument arg1<optional> -> String
      argument arg2<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = String
        ]
      }
    method Array (x) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = untyped
      ]
    }
      argument x<> -> Object
    method Complex (x, y) -> Complex
      argument x<> -> Numeric
      argument y<optional> -> Numeric
    method Float (x) -> Float
      argument x<> -> Numeric
    method Hash (x) -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = untyped
        <constant:V> = untyped
        <constant:Elem> = untyped
      ]
    }
      argument x<> -> Object
    method Integer (arg, base) -> Integer
      argument arg<> -> Numeric | String
      argument base<optional> -> Integer
    method Rational (x, y) -> Rational
      argument x<> -> Numeric
      argument y<optional> -> Numeric
    method String (x) -> String
      argument x<> -> Object
    method __callee__ () -> Symbol | NilClass
    method __dir__ () -> String | NilClass
    method __method__ () -> Symbol | NilClass
    method ` (arg0) -> String
      argument arg0<> -> String
    method abort (msg) -> NilClass
      argument msg<optional> -> String
    method at_exit (blk) -> Proc
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc0>
        targs = [
          <constant:Return> = BasicObject
        ]
      }
    method autoload (_module, filename) -> NilClass
      argument _module<> -> String | Symbol
      argument filename<> -> String
    method autoload? (name) -> String | NilClass
      argument name<> -> Symbol | String
    method binding () -> Binding
    method block_given? () -> TrueClass | FalseClass
    method caller (start, length) -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass
      argument length<optional> -> Integer
      argument start<optional> -> Integer
    method caller_locations (start, length) -> AppliedType {
          klass = ::<constant:Array>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass
      argument length<optional> -> Integer
      argument start<optional> -> Integer
    method eval (arg0, arg1, filename, lineno) -> untyped
      argument arg0<> -> String
      argument arg1<optional> -> Binding
      argument filename<optional> -> String
      argument lineno<optional> -> Integer
    method exit () -> NilClass
      argument status<optional>
    method exit! (status) -> NilClass
      argument status<> -> Integer | TrueClass | FalseClass
    method fail () -> NilClass
      argument arg0<optional>
      argument arg1<optional>
      argument arg2<optional>
    method format (format, args) -> String
      argument args<repeated> -> BasicObject
      argument format<> -> String
    method gets (arg0, arg1) -> String
      argument arg0<optional> -> String
      argument arg1<optional> -> Integer
    method global_variables () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
    method iterator? () -> TrueClass | FalseClass
    method load (filename, arg0) -> TrueClass | FalseClass
      argument arg0<optional> -> TrueClass | FalseClass
      argument filename<> -> String
    method local_variables () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
    method open (name, rest, block) -> AppliedType {
          klass = ::<constant:IO>
          targs = [
            <constant:Elem> = String
          ]
        } | NilClass
      argument block<optional> -> String
      argument name<> -> String
      argument rest<optional> -> String | Integer
    method printf (arg0, arg1, arg2) -> NilClass
      argument arg0<optional> -> AppliedType {
        klass = ::<constant:IO>
        targs = [
          <constant:Elem> = String
        ]
      }
      argument arg1<optional> -> String
      argument arg2<repeated> -> BasicObject
    method proc (blk) -> Proc
      argument blk<block> -> BasicObject
    method putc (arg0) -> Integer
      argument arg0<> -> Integer
    method puts (arg0) -> NilClass
      argument arg0<repeated> -> BasicObject
    method raise () -> NilClass
      argument arg0<optional>
      argument arg1<optional>
      argument arg2<optional>
    method rand (max) -> Numeric
      argument max<> -> AppliedType {
            klass = ::<constant:Range>
            targs = [
              <constant:Elem> = untyped
            ]
          } | Integer
    method readline (arg0, arg1) -> String
      argument arg0<optional> -> String
      argument arg1<optional> -> Integer
    method readlines (arg0, arg1) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument arg0<optional> -> String
      argument arg1<optional> -> Integer
    method require (name) -> TrueClass | FalseClass
      argument name<> -> String
    method require_relative (name) -> TrueClass | FalseClass
      argument name<> -> String
    method select (read, write, error, timeout) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument error<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
      argument read<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
      argument timeout<optional> -> Integer
      argument write<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = AppliedType {
              klass = ::<constant:IO>
              targs = [
                <constant:Elem> = String
              ]
            }
        ]
      }
    method sleep (duration) -> Integer
      argument duration<> -> Numeric
    method sprintf (format, args) -> String
      argument args<repeated> -> BasicObject
      argument format<> -> String
    method srand (number) -> Numeric
      argument number<> -> Numeric
    method syscall (num, args) -> untyped
      argument args<repeated> -> BasicObject
      argument num<> -> Integer
    method test (cmd, file1, file2) -> TrueClass | FalseClass | Time
      argument cmd<> -> String
      argument file1<> -> String
      argument file2<optional> -> String
    method warn (msg) -> NilClass
      argument msg<repeated> -> String
  class <singleton class:<constant:KeyError>> < ::<singleton class:<constant:IndexError>> ()
  class <singleton class:<constant:LoadError>> < ::<singleton class:<constant:ScriptError>> ()
  class <singleton class:<constant:LocalJumpError>> < ::<singleton class:<constant:StandardError>> ()
  class <singleton class:<constant:Marshal>> < ::<constant:Module> ()
    method <overload N.1 : dump> (arg0, arg1) -> Object
      argument arg0<> -> Object
      argument arg1<optional> -> Integer
      argument arg2<optional>
    method dump (arg0, arg1, arg2) -> Object
      argument arg0<> -> Object
      argument arg1<optional> -> AppliedType {
        klass = ::<constant:IO>
        targs = [
          <constant:Elem> = String
        ]
      }
      argument arg2<optional> -> Integer
    method load (arg0, arg1) -> Object
      argument arg0<> -> String
      argument arg1<optional> -> Proc
  class <singleton class:<constant:MatchData>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:Math>> < ::<constant:Module> ()
    method acos (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method acosh (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method asin (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method asinh (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method atan (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method atan2 (y, x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
      argument y<> -> Integer | Float | Rational | BigDecimal
    method atanh (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method cbrt (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method cos (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method cosh (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method erf (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method erfc (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method exp (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method frexp (x) -> TupleType {
      0 = Integer | Float | Rational | BigDecimal
      1 = Integer | Float | Rational | BigDecimal
    }
      argument x<> -> Integer | Float | Rational | BigDecimal
    method gamma (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method hypot (x, y) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
      argument y<> -> Integer | Float | Rational | BigDecimal
    method ldexp (fraction, exponent) -> Float
      argument exponent<> -> Integer | Float | Rational | BigDecimal
      argument fraction<> -> Integer | Float | Rational | BigDecimal
    method lgamma (x) -> Integer | Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method log (x, base) -> Float
      argument base<optional> -> Integer | Float | Rational | BigDecimal
      argument x<> -> Integer | Float | Rational | BigDecimal
    method log10 (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method log2 (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method sin (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method sinh (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method sqrt (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method tan (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
    method tanh (x) -> Float
      argument x<> -> Integer | Float | Rational | BigDecimal
  class <singleton class:<constant:Method>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:Module>> < ::<singleton class:<constant:Object>> ()
    method constants () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    }
    method nesting () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Module
      ]
    }
  class <singleton class:<constant:Monitor>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:MonitorMixin>> < ::<constant:Module> ()
  class <singleton class:<constant:NameError>> < ::<singleton class:<constant:StandardError>> ()
  class <singleton class:<constant:NilClass>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:NoMemoryError>> < ::<singleton class:<constant:Exception>> ()
  class <singleton class:<constant:NoMethodError>> < ::<singleton class:<constant:NameError>> ()
  class <singleton class:<constant:NotImplementedError>> < ::<singleton class:<constant:ScriptError>> ()
  class <singleton class:<constant:Numeric>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:Object>> < ::<singleton class:<constant:BasicObject>> ()
  class <singleton class:<constant:ObjectSpace>> < ::<constant:Module> ()
  class <singleton class:<constant:Opus>> < ::<constant:Module> ()
  class <singleton class:<constant:Pathname>> < ::<singleton class:<constant:Object>> ()
    method getwd () -> Pathname
    method glob (p1, p2) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Pathname
      ]
    }
      argument p1<> -> String
      argument p2<optional> -> String
    method pwd () -> Pathname
  class <singleton class:<constant:Proc0>> < ::<singleton class:<constant:Proc>> ()
  class <singleton class:<constant:Proc10>> < ::<singleton class:<constant:Proc>> ()
  class <singleton class:<constant:Proc1>> < ::<singleton class:<constant:Proc>> ()
  class <singleton class:<constant:Proc2>> < ::<singleton class:<constant:Proc>> ()
  class <singleton class:<constant:Proc3>> < ::<singleton class:<constant:Proc>> ()
  class <singleton class:<constant:Proc4>> < ::<singleton class:<constant:Proc>> ()
  class <singleton class:<constant:Proc5>> < ::<singleton class:<constant:Proc>> ()
  class <singleton class:<constant:Proc6>> < ::<singleton class:<constant:Proc>> ()
  class <singleton class:<constant:Proc7>> < ::<singleton class:<constant:Proc>> ()
  class <singleton class:<constant:Proc8>> < ::<singleton class:<constant:Proc>> ()
  class <singleton class:<constant:Proc9>> < ::<singleton class:<constant:Proc>> ()
  class <singleton class:<constant:Proc>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:Process>> < ::<constant:Module> ()
    method <overload N.1 : fork> (blk) -> Integer | NilClass
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc0>
        targs = [
          <constant:Return> = BasicObject
        ]
      }
    method abort (msg) -> untyped
      argument msg<optional> -> String
    method argv0 () -> String
    method clock_getres (clock_id, unit) -> Float | Integer
      argument clock_id<> -> Symbol | Integer
      argument unit<optional> -> Symbol
    method clock_gettime (clock_id, unit) -> Float | Integer
      argument clock_id<> -> Symbol | Integer
      argument unit<optional> -> Symbol
    method daemon (nochdir, noclose) -> Integer
      argument nochdir<optional> -> BasicObject
      argument noclose<optional> -> BasicObject
    method detach (pid) -> Thread
      argument pid<> -> Integer
    method egid () -> Integer
    method egid= (arg0) -> Integer
      argument arg0<> -> Integer
    method euid () -> Integer
    method euid= (arg0) -> Integer
      argument arg0<> -> Integer
    method exit (status) -> untyped
      argument status<optional> -> Integer
    method exit! (status) -> untyped
      argument status<optional> -> Integer
    method fork () -> Integer | NilClass
      argument blk<block>
    method getpgid (pid) -> Integer
      argument pid<> -> Integer
    method getpgrp () -> Integer
    method getpriority (kind, arg0) -> Integer
      argument arg0<> -> Integer
      argument kind<> -> Integer
    method getrlimit (resource) -> TupleType {
      0 = Integer
      1 = Integer
    }
      argument resource<> -> Symbol | String | Integer
    method getsid (pid) -> Integer
      argument pid<optional> -> Integer
    method gid () -> Integer
    method gid= (arg0) -> Integer
      argument arg0<> -> Integer
    method groups () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    }
    method groups= (arg0) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    }
      argument arg0<> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = Integer
        ]
      }
    method initgroups (username, gid) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Integer
      ]
    }
      argument gid<> -> Integer
      argument username<> -> String
    method kill (signal, pids) -> Integer
      argument pids<repeated> -> Integer
      argument signal<> -> Integer | Symbol | String
    method maxgroups () -> Integer
    method maxgroups= (arg0) -> Integer
      argument arg0<> -> Integer
    method pid () -> Integer
    method ppid () -> Integer
    method setpgid (pid, arg0) -> Integer
      argument arg0<> -> Integer
      argument pid<> -> Integer
    method setpriority (kind, arg0, priority) -> Integer
      argument arg0<> -> Integer
      argument kind<> -> Integer
      argument priority<> -> Integer
    method setproctitle (arg0) -> String
      argument arg0<> -> String
    method setrlimit (resource, cur_limit, max_limit) -> NilClass
      argument cur_limit<> -> Integer
      argument max_limit<optional> -> Integer
      argument resource<> -> Symbol | String | Integer
    method setsid () -> Integer
    method times () -> Process::Tms
    method uid () -> Integer
    method uid= (user) -> Integer
      argument user<> -> Integer
    method wait (pid, flags) -> Integer
      argument flags<optional> -> Integer
      argument pid<optional> -> Integer
    method wait2 (pid, flags) -> TupleType {
      0 = Integer
      1 = Integer
    }
      argument flags<optional> -> Integer
      argument pid<optional> -> Integer
    method waitall () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = TupleType {
            0 = Integer
            1 = Integer
          }
      ]
    }
    method waitpid (pid, flags) -> Integer
      argument flags<optional> -> Integer
      argument pid<optional> -> Integer
    method waitpid2 (pid, flags) -> TupleType {
      0 = Integer
      1 = Integer
    }
      argument flags<optional> -> Integer
      argument pid<optional> -> Integer
  class <singleton class:<constant:Random>> < ::<singleton class:<constant:Object>> ()
    method new_seed () -> Integer
    method rand (max) -> Numeric
      argument max<optional> -> Integer
    method srand (number) -> Numeric
      argument number<optional> -> Integer
  class <singleton class:<constant:Range>> < ::<singleton class:<constant:Object>> (<constant:Generic>)
  class <singleton class:<constant:RangeError>> < ::<singleton class:<constant:StandardError>> ()
  class <singleton class:<constant:Rational>> < ::<singleton class:<constant:Numeric>> ()
  class <singleton class:<constant:RbConfig>> < ::<constant:Module> ()
  class <singleton class:<constant:Regexp>> < ::<singleton class:<constant:Object>> ()
    method <overload N.1 : compile> (arg0) -> Regexp
      argument arg0<> -> Regexp
      argument kcode<optional>
      argument options<optional>
    method <overload N.1 : last_match> (arg0) -> String
      argument arg0<optional> -> Integer
    method compile (arg0, options, kcode) -> Regexp
      argument arg0<> -> String
      argument kcode<optional> -> String
      argument options<optional> -> BasicObject
    method escape (arg0) -> String
      argument arg0<> -> String | Symbol
    method last_match () -> MatchData
      argument arg0<optional>
    method quote (arg0) -> String
      argument arg0<> -> String | Symbol
    method try_convert (obj) -> Regexp | NilClass
      argument obj<> -> BasicObject
  class <singleton class:<constant:RegexpError>> < ::<singleton class:<constant:StandardError>> ()
  class <singleton class:<constant:RubyTyper>> < ::<constant:Module> ()
  class <singleton class:<constant:RubyVM>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:RuntimeError>> < ::<singleton class:<constant:StandardError>> ()
  class <singleton class:<constant:ScriptError>> < ::<singleton class:<constant:Exception>> ()
  class <singleton class:<constant:SecurityError>> < ::<singleton class:<constant:Exception>> ()
  class <singleton class:<constant:Set>> < ::<singleton class:<constant:Object>> (<constant:Generic>)
    method [] (ary) -> untyped
      argument ary<repeated> -> BasicObject
  class <singleton class:<constant:Signal>> < ::<constant:Module> ()
    method <overload N.1 : trap> (arg0, blk) -> String | Proc
      argument arg0<> -> Integer | String
      argument blk<block> -> AppliedType {
        klass = ::<constant:Proc1>
        targs = [
          <constant:Return> = BasicObject
          <constant:Arg0> = Integer
        ]
      }
    method list () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = String
        <constant:V> = Integer
        <constant:Elem> = untyped
      ]
    }
    method signame (arg0) -> String | NilClass
      argument arg0<> -> Integer
    method trap (arg0) -> String | Proc
      argument arg0<> -> Integer | String
      argument blk<block>
  class <singleton class:<constant:SignalException>> < ::<singleton class:<constant:Exception>> ()
  class <singleton class:<constant:SingleForwardable>> < ::<constant:Module> ()
  class <singleton class:<constant:SortedSet>> < ::<singleton class:<constant:Set>> (<constant:Generic>)
  class <singleton class:<constant:StandardError>> < ::<singleton class:<constant:Exception>> ()
  class <singleton class:<constant:StopIteration>> < ::<singleton class:<constant:IndexError>> ()
  class <singleton class:<constant:String>> < ::<singleton class:<constant:Object>> ()
    method try_convert (obj) -> String | NilClass
      argument obj<> -> Object
  class <singleton class:<constant:StringIO>> < ::<singleton class:<constant:Data>> (<constant:Generic>)
  class <singleton class:<constant:StringScanner>> < ::<singleton class:<constant:Object>> ()
    method new (arg0, arg1) -> StringScanner
      argument arg0<> -> String
      argument arg1<optional> -> TrueClass | FalseClass
  class <singleton class:<constant:Struct>> < ::<singleton class:<constant:Object>> (<constant:Generic>)
    method new (arg0, arg1) -> <Class:RubyTyper::DynamicStruct>
      argument arg0<> -> Symbol | String
      argument arg1<repeated> -> Symbol | String
  class <singleton class:<constant:Symbol>> < ::<singleton class:<constant:Object>> ()
    method all_symbols () -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = Symbol
      ]
    }
  class <singleton class:<constant:SyntaxError>> < ::<singleton class:<constant:ScriptError>> ()
  class <singleton class:<constant:SystemCallError>> < ::<singleton class:<constant:StandardError>> ()
  class <singleton class:<constant:SystemExit>> < ::<singleton class:<constant:Exception>> ()
  class <singleton class:<constant:SystemStackError>> < ::<singleton class:<constant:Exception>> ()
  class <singleton class:<constant:T>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:Thread>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:ThreadError>> < ::<singleton class:<constant:StandardError>> ()
  class <singleton class:<constant:ThreadGroup>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:Time>> < ::<singleton class:<constant:Object>> ()
    method <overload N.1 : at> () -> Time
      argument arg0<>
      argument microseconds_with_frac<optional>
    method <overload N.2 : at> (microseconds_with_frac) -> Time
      argument arg0<>
      argument microseconds_with_frac<optional> -> Numeric
    method at (arg0) -> Time
      argument arg0<> -> Time
      argument microseconds_with_frac<optional>
    method gm (year, month, day, hour, min, sec, usec_with_frac) -> Time
      argument day<optional> -> Integer
      argument hour<optional> -> Integer
      argument min<optional> -> Integer
      argument month<optional> -> Integer | String
      argument sec<optional> -> Numeric
      argument usec_with_frac<optional> -> Numeric
      argument year<> -> Integer
    method local (year, month, day, hour, min, sec, usec_with_frac) -> Time
      argument day<optional> -> Integer
      argument hour<optional> -> Integer
      argument min<optional> -> Integer
      argument month<optional> -> Integer | String
      argument sec<optional> -> Numeric
      argument usec_with_frac<optional> -> Numeric
      argument year<> -> Integer
    method mktime (year, month, day, hour, min, sec, usec_with_frac) -> Time
      argument day<optional> -> Integer
      argument hour<optional> -> Integer
      argument min<optional> -> Integer
      argument month<optional> -> Integer | String
      argument sec<optional> -> Numeric
      argument usec_with_frac<optional> -> Numeric
      argument year<> -> Integer
    method now () -> Time
    method utc (year, month, day, hour, min, sec, usec_with_frac) -> Time
      argument day<optional> -> Integer
      argument hour<optional> -> Integer
      argument min<optional> -> Integer
      argument month<optional> -> Integer | String
      argument sec<optional> -> Numeric
      argument usec_with_frac<optional> -> Numeric
      argument year<> -> Integer
  class <singleton class:<constant:TracePoint>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:TrueClass>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:TypeError>> < ::<singleton class:<constant:StandardError>> ()
  class <singleton class:<constant:URI>> < ::<constant:Module> ()
    method <overload N.1 : encode> (arg, arg0) -> String
      argument arg0<repeated> -> String
      argument arg<> -> String
    method <overload N.1 : escape> (arg, arg0) -> String
      argument arg0<repeated> -> String
      argument arg<> -> String
    method decode (arg) -> String
      argument arg<repeated> -> String
    method decode_www_form_component (str, enc) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = TupleType {
            0 = String
            1 = String
          }
      ]
    }
      argument enc<optional> -> Encoding
      argument str<> -> String
    method encode (arg, arg0) -> String
      argument arg0<repeated> -> Regexp
      argument arg<> -> String
    method escape (arg, arg0) -> String
      argument arg0<repeated> -> Regexp
      argument arg<> -> String
    method extract (str, schemes, blk) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument blk<block> -> BasicObject
      argument schemes<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
      argument str<> -> String
    method join (str) -> URI::HTTP
      argument str<repeated> -> String
    method parse (uri) -> URI::HTTP
      argument uri<> -> String
    method regexp (schemes) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument schemes<optional> -> AppliedType {
        klass = ::<constant:Array>
        targs = [
          <constant:Elem> = untyped
        ]
      }
    method scheme_list () -> AppliedType {
      klass = ::<constant:Hash>
      targs = [
        <constant:K> = String
        <constant:V> = Class
        <constant:Elem> = untyped
      ]
    }
    method split (uri) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String | NilClass
      ]
    }
      argument uri<> -> String
    method unescape (arg) -> String
      argument arg<repeated> -> String
  class <singleton class:<constant:UnboundMethod>> < ::<singleton class:<constant:Object>> ()
  class <singleton class:<constant:UncaughtThrowError>> < ::<singleton class:<constant:ArgumentError>> ()
  class <singleton class:<constant:Warning>> < ::<constant:Module> ()
  class <singleton class:<constant:YAML>> < ::<constant:Module> ()
    method load_file (filename) -> AppliedType {
      klass = ::<constant:Array>
      targs = [
        <constant:Elem> = String
      ]
    }
      argument filename<> -> String
  class <singleton class:<constant:ZeroDivisionError>> < ::<singleton class:<constant:StandardError>> ()
  method <static-init>$1 ()
  method <static-init>$3 ()
  method <static-init>$4 ()
  method <static-init>$5 ()
  method <static-init>$6 ()
  method <static-init>$7 ()
  method <static-init>$8 ()
  static-field <constant:M> -> AliasType { symbol = ::<constant:Opus>::<constant:DB>::<constant:Model> }

class <emptyTree><<constant:<root>>> < ()
  def self.<static-init><<static-init>$8>()
    1
  end
end
ClassDef{
  name = EmptyTree<<constant:<root>>>
  ancestors = []
  rhs = [
    MethodDef{
      self = 1
      name = <static-init><<static-init>$8>
      args = []
      rhs = IntLit{ value = 1 }
    }
  ]
}
digraph "-e"{
subgraph "cluster_#<static-init>$8" {
    label = "#<static-init>$8";
    color = blue;
    "bb#<static-init>$8_0" [shape = invhouse];
    "bb#<static-init>$8_1" [shape = parallelogram];

    "bb#<static-init>$8_0" [label = "block[id=0]()
<returnMethodTemp>$2 = 1 : Integer(1)
<finalReturn> = return <returnMethodTemp>$2 : <bottom>
<unconditional>"];

    "bb#<static-init>$8_0" -> "bb#<static-init>$8_1" [style="bold"];
    "bb#<static-init>$8_1" [label = "block[id=1]()
<unconditional>"];

    "bb#<static-init>$8_1" -> "bb#<static-init>$8_1" [style="bold"];
}

}

digraph "-e"{
subgraph "cluster_#<static-init>$8" {
    label = "#<static-init>$8";
    color = blue;
    "bb#<static-init>$8_0" [shape = invhouse];
    "bb#<static-init>$8_1" [shape = parallelogram];

    "bb#<static-init>$8_0" [label = "block[id=0]()
<returnMethodTemp>$2 = 1 : Integer(1)
<finalReturn> = return <returnMethodTemp>$2 : <bottom>
<returnMethodTemp>$2: Integer(1)

<finalReturn>: <bottom>

<unconditional>"];

    "bb#<static-init>$8_0" -> "bb#<static-init>$8_1" [style="bold"];
    "bb#<static-init>$8_1" [label = "block[id=1]()
<unconditional>"];

    "bb#<static-init>$8_1" -> "bb#<static-init>$8_1" [style="bold"];
}

}

1
# <returnMethodTemp>$2: Integer(1)
#
# <finalReturn>: <bottom>