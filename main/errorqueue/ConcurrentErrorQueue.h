#ifndef SORBET_CONCURRENT_ERRORQUEUE_H
#define SORBET_CONCURRENT_ERRORQUEUE_H
#include "common/concurrency/ConcurrentQueue.h"
#include "core/Errors.h"
#include "core/lsp/QueryResponse.h"
#include "spdlog/spdlog.h"
#include <atomic>
#include <climits> // INT_MAX

namespace spd = spdlog;

namespace sorbet {
namespace realmain {
// This class has to be in a separate header to make us compile /facepalm:
//  - parser defines a constant TRUE in header generated by bison\regel
//  - ConcurrentBoundedQueue on mac includes some OS headers that "#define TRUE 1"
//

struct ErrorQueueMessage {
    enum class Kind { Error, Flush, QueryResponse };
    Kind kind;
    core::FileRef whatFile;
    std::string text;
    std::unique_ptr<core::BasicError> error;
    std::unique_ptr<core::QueryResponse> queryResponse;
};

class ConcurrentErrorQueue : public core::ErrorQueue {
private:
    std::thread::id owner;
    std::unordered_map<core::FileRef, std::vector<ErrorQueueMessage>> collected;
    ConcurrentUnBoundedQueue<ErrorQueueMessage> queue;
    std::atomic<bool> printedAtLeastOneError{false};

    void renderForFile(core::FileRef whatFile, std::stringstream &critical, std::stringstream &nonCritical);

public:
    ConcurrentErrorQueue(spd::logger &logger, spd::logger &tracer);
    ~ConcurrentErrorQueue();

    virtual void pushError(const core::GlobalState &gs, std::unique_ptr<core::BasicError> error) override;
    virtual void pushQueryResponse(std::unique_ptr<core::QueryResponse> error) override;
    virtual void flushFile(core::FileRef file) override;
    virtual void flushErrors(bool all = false) override;
    virtual void flushErrorCount() override;

    std::vector<std::unique_ptr<core::QueryResponse>> drainQueryResponses();
    std::vector<std::unique_ptr<core::BasicError>> drainErrors();
};
} // namespace realmain
} // namespace sorbet

#endif // SORBET_ERRORQUEUE_H
