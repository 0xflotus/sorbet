# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   scripts/bin/remote-script sorbet/shim_generation/gems.rb -r openssl

# typed: true

module OpenSSL
  OPENSSL_FIPS = ::T.let(nil, ::T.untyped)
  OPENSSL_LIBRARY_VERSION = ::T.let(nil, ::T.untyped)
  OPENSSL_VERSION = ::T.let(nil, ::T.untyped)
  OPENSSL_VERSION_NUMBER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.Digest(name); end

  Sorbet.sig {returns(::T.untyped)}
  def self.debug(); end

  Sorbet.sig do
    params(
      debug: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.debug=(debug); end

  Sorbet.sig {returns(::T.untyped)}
  def self.errors(); end

  Sorbet.sig do
    params(
      fips_mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.fips_mode=(fips_mode); end
end

module OpenSSL::ASN1
  BIT_STRING = ::T.let(nil, ::T.untyped)
  BMPSTRING = ::T.let(nil, ::T.untyped)
  BOOLEAN = ::T.let(nil, ::T.untyped)
  CHARACTER_STRING = ::T.let(nil, ::T.untyped)
  EMBEDDED_PDV = ::T.let(nil, ::T.untyped)
  ENUMERATED = ::T.let(nil, ::T.untyped)
  EOC = ::T.let(nil, ::T.untyped)
  EXTERNAL = ::T.let(nil, ::T.untyped)
  GENERALIZEDTIME = ::T.let(nil, ::T.untyped)
  GENERALSTRING = ::T.let(nil, ::T.untyped)
  GRAPHICSTRING = ::T.let(nil, ::T.untyped)
  IA5STRING = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  ISO64STRING = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NUMERICSTRING = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  OBJECT_DESCRIPTOR = ::T.let(nil, ::T.untyped)
  OCTET_STRING = ::T.let(nil, ::T.untyped)
  PRINTABLESTRING = ::T.let(nil, ::T.untyped)
  REAL = ::T.let(nil, ::T.untyped)
  RELATIVE_OID = ::T.let(nil, ::T.untyped)
  SEQUENCE = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
  T61STRING = ::T.let(nil, ::T.untyped)
  UNIVERSALSTRING = ::T.let(nil, ::T.untyped)
  UNIVERSAL_TAG_NAME = ::T.let(nil, ::T.untyped)
  UTCTIME = ::T.let(nil, ::T.untyped)
  UTF8STRING = ::T.let(nil, ::T.untyped)
  VIDEOTEXSTRING = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.BMPString(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.BitString(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.Boolean(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.EndOfContent(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.Enumerated(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.GeneralString(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.GeneralizedTime(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.GraphicString(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.IA5String(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ISO64String(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.Integer(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.Null(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.NumericString(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ObjectId(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.OctetString(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.PrintableString(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.Sequence(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.Set(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.T61String(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.UTCTime(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.UTF8String(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.UniversalString(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.VideotexString(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.decode(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.decode_all(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.traverse(_); end
end

class OpenSSL::ASN1::ASN1Data
  Sorbet.sig {returns(::T.untyped)}
  def infinite_length(); end

  Sorbet.sig do
    params(
      infinite_length: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def infinite_length=(infinite_length); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(_, _1, _2); end

  Sorbet.sig {returns(::T.untyped)}
  def tag(); end

  Sorbet.sig do
    params(
      tag: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def tag=(tag); end

  Sorbet.sig {returns(::T.untyped)}
  def tag_class(); end

  Sorbet.sig do
    params(
      tag_class: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def tag_class=(tag_class); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def value=(value); end
end

class OpenSSL::ASN1::ASN1Error < OpenSSL::OpenSSLError
end

class OpenSSL::ASN1::BMPString < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::BitString < OpenSSL::ASN1::Primitive
  Sorbet.sig {returns(::T.untyped)}
  def unused_bits(); end

  Sorbet.sig do
    params(
      unused_bits: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unused_bits=(unused_bits); end
end

class OpenSSL::ASN1::Boolean < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::Constructive < OpenSSL::ASN1::ASN1Data
  include ::Enumerable
  Sorbet.sig {returns(::T.untyped)}
  def each(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def tagging(); end

  Sorbet.sig do
    params(
      tagging: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def tagging=(tagging); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end
end

class OpenSSL::ASN1::EndOfContent < OpenSSL::ASN1::ASN1Data
  Sorbet.sig {returns(::T.untyped)}
  def initialize(); end
end

class OpenSSL::ASN1::Enumerated < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::GeneralString < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::GeneralizedTime < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::GraphicString < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::IA5String < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::ISO64String < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::Integer < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::Null < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::NumericString < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::ObjectId < OpenSSL::ASN1::Primitive
  Sorbet.sig {returns(::T.untyped)}
  def ln(); end

  Sorbet.sig {returns(::T.untyped)}
  def long_name(); end

  Sorbet.sig {returns(::T.untyped)}
  def oid(); end

  Sorbet.sig {returns(::T.untyped)}
  def short_name(); end

  Sorbet.sig {returns(::T.untyped)}
  def sn(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.register(_, _1, _2); end
end

class OpenSSL::ASN1::OctetString < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::Primitive < OpenSSL::ASN1::ASN1Data
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def tagging(); end

  Sorbet.sig do
    params(
      tagging: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def tagging=(tagging); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end
end

class OpenSSL::ASN1::PrintableString < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::Sequence < OpenSSL::ASN1::Constructive
end

class OpenSSL::ASN1::Set < OpenSSL::ASN1::Constructive
end

class OpenSSL::ASN1::T61String < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::UTCTime < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::UTF8String < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::UniversalString < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::VideotexString < OpenSSL::ASN1::Primitive
end

class OpenSSL::BN
  include ::Comparable
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def %(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def *(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def **(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def +(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def -(_); end


  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <<(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <=>(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ==(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ===(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def >>(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def bit_set?(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def clear_bit!(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cmp(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def coerce(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def copy(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def eql?(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def gcd(_); end

  Sorbet.sig {returns(::T.untyped)}
  def hash(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lshift!(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mask_bits!(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mod_add(_, _1); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mod_exp(_, _1); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mod_inverse(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mod_mul(_, _1); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mod_sqr(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mod_sub(_, _1); end

  Sorbet.sig {returns(::T.untyped)}
  def num_bits(); end

  Sorbet.sig {returns(::T.untyped)}
  def num_bytes(); end

  Sorbet.sig {returns(::T.untyped)}
  def odd?(); end

  Sorbet.sig {returns(::T.untyped)}
  def one?(); end

  Sorbet.sig do
    params(
      q: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def pretty_print(q); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def prime?(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def prime_fasttest?(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rshift!(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_bit!(_); end

  Sorbet.sig {returns(::T.untyped)}
  def sqr(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_bn(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_i(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_int(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def to_s(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ucmp(_); end

  Sorbet.sig {returns(::T.untyped)}
  def zero?(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.generate_prime(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.pseudo_rand(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.pseudo_rand_range(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.rand(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.rand_range(_); end
end

class OpenSSL::BNError < OpenSSL::OpenSSLError
end

module OpenSSL::Buffering
  include ::Enumerable
  BLOCK_SIZE = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      s: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <<(s); end

  Sorbet.sig {returns(::T.untyped)}
  def close(); end

  Sorbet.sig do
    params(
      eol: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each(eol=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def each_byte(); end

  Sorbet.sig do
    params(
      eol: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_line(eol=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def eof(); end

  Sorbet.sig {returns(::T.untyped)}
  def eof?(); end

  Sorbet.sig {returns(::T.untyped)}
  def flush(); end

  Sorbet.sig {returns(::T.untyped)}
  def getc(); end

  Sorbet.sig do
    params(
      eol: ::T.untyped,
      limit: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def gets(eol=T.unsafe(nil), limit=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def print(*args); end

  Sorbet.sig do
    params(
      s: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def printf(s, *args); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def puts(*args); end

  Sorbet.sig do
    params(
      size: ::T.untyped,
      buf: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(size=T.unsafe(nil), buf=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      maxlen: ::T.untyped,
      buf: ::T.untyped,
      exception: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_nonblock(maxlen, buf=T.unsafe(nil), exception: T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def readchar(); end

  Sorbet.sig do
    params(
      eol: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readline(eol=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      eol: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readlines(eol=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      maxlen: ::T.untyped,
      buf: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readpartial(maxlen, buf=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def sync(); end

  Sorbet.sig do
    params(
      sync: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sync=(sync); end

  Sorbet.sig do
    params(
      c: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ungetc(c); end

  Sorbet.sig do
    params(
      s: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(s); end

  Sorbet.sig do
    params(
      s: ::T.untyped,
      exception: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_nonblock(s, exception: T.unsafe(nil)); end
end

class OpenSSL::Cipher
  Sorbet.sig do
    params(
      auth_data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_data=(auth_data); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_tag(*_); end

  Sorbet.sig do
    params(
      auth_tag: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_tag=(auth_tag); end

  Sorbet.sig do
    params(
      auth_tag_len: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_tag_len=(auth_tag_len); end

  Sorbet.sig {returns(::T.untyped)}
  def authenticated?(); end

  Sorbet.sig {returns(::T.untyped)}
  def block_size(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def decrypt(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def encrypt(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def final(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(_); end

  Sorbet.sig do
    params(
      iv: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def iv=(iv); end

  Sorbet.sig {returns(::T.untyped)}
  def iv_len(); end

  Sorbet.sig do
    params(
      iv_len: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def iv_len=(iv_len); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key=(key); end

  Sorbet.sig {returns(::T.untyped)}
  def key_len(); end

  Sorbet.sig do
    params(
      key_len: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key_len=(key_len); end

  Sorbet.sig {returns(::T.untyped)}
  def name(); end

  Sorbet.sig do
    params(
      padding: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def padding=(padding); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def pkcs5_keyivgen(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def random_iv(); end

  Sorbet.sig {returns(::T.untyped)}
  def random_key(); end

  Sorbet.sig {returns(::T.untyped)}
  def reset(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def update(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.ciphers(); end
end

class OpenSSL::Cipher::AES < OpenSSL::Cipher
  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*args); end
end

class OpenSSL::Cipher::AES128 < OpenSSL::Cipher
  Sorbet.sig do
    params(
      mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(mode=T.unsafe(nil)); end
end

class OpenSSL::Cipher::AES192 < OpenSSL::Cipher
  Sorbet.sig do
    params(
      mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(mode=T.unsafe(nil)); end
end

class OpenSSL::Cipher::AES256 < OpenSSL::Cipher
  Sorbet.sig do
    params(
      mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(mode=T.unsafe(nil)); end
end

class OpenSSL::Cipher::BF < OpenSSL::Cipher
  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*args); end
end

class OpenSSL::Cipher::CAST5 < OpenSSL::Cipher
  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*args); end
end

class OpenSSL::Cipher::CipherError < OpenSSL::OpenSSLError
end

class OpenSSL::Cipher::DES < OpenSSL::Cipher
  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*args); end
end

class OpenSSL::Cipher::IDEA < OpenSSL::Cipher
  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*args); end
end

class OpenSSL::Cipher::RC2 < OpenSSL::Cipher
  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*args); end
end

class OpenSSL::Cipher::RC4 < OpenSSL::Cipher
  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*args); end
end

class OpenSSL::Cipher::RC5 < OpenSSL::Cipher
  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*args); end
end

class OpenSSL::Config
  include ::Enumerable
  DEFAULT_CONFIG_FILE = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      section: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](section); end

  Sorbet.sig do
    params(
      section: ::T.untyped,
      pairs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(section, pairs); end

  Sorbet.sig do
    params(
      section: ::T.untyped,
      key: ::T.untyped,
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_value(section, key, value); end

  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig {returns(::T.untyped)}
  def each(); end

  Sorbet.sig do
    params(
      section: ::T.untyped,
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def get_value(section, key); end

  Sorbet.sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(filename=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def section(name); end

  Sorbet.sig {returns(::T.untyped)}
  def sections(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig do
    params(
      arg1: ::T.untyped,
      arg2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def value(arg1, arg2=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
      section: ::T.untyped,
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get_key_string(data, section, key); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load(*_); end

  Sorbet.sig do
    params(
      string: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(string); end

  Sorbet.sig do
    params(
      io: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse_config(io); end
end

class OpenSSL::ConfigError < OpenSSL::OpenSSLError
end

class OpenSSL::Digest < Digest::Class
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <<(_); end

  Sorbet.sig {returns(::T.untyped)}
  def block_length(); end

  Sorbet.sig {returns(::T.untyped)}
  def digest_length(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def name(); end

  Sorbet.sig {returns(::T.untyped)}
  def reset(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def update(_); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(name, data); end
end

class OpenSSL::Digest::DSS < OpenSSL::Digest
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::DSS1 < OpenSSL::Digest
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::DigestError < OpenSSL::OpenSSLError
end

class OpenSSL::Digest::MD2 < OpenSSL::Digest
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::MD4 < OpenSSL::Digest
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::MD5 < OpenSSL::Digest
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::MDC2 < OpenSSL::Digest
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::RIPEMD160 < OpenSSL::Digest
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA < OpenSSL::Digest
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA1 < OpenSSL::Digest
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA224 < OpenSSL::Digest
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA256 < OpenSSL::Digest
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA384 < OpenSSL::Digest
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA512 < OpenSSL::Digest
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(data); end
end

class OpenSSL::Engine
  METHOD_ALL = ::T.let(nil, ::T.untyped)
  METHOD_CIPHERS = ::T.let(nil, ::T.untyped)
  METHOD_DH = ::T.let(nil, ::T.untyped)
  METHOD_DIGESTS = ::T.let(nil, ::T.untyped)
  METHOD_DSA = ::T.let(nil, ::T.untyped)
  METHOD_NONE = ::T.let(nil, ::T.untyped)
  METHOD_RAND = ::T.let(nil, ::T.untyped)
  METHOD_RSA = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cipher(_); end

  Sorbet.sig {returns(::T.untyped)}
  def cmds(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ctrl_cmd(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def digest(_); end

  Sorbet.sig {returns(::T.untyped)}
  def finish(); end

  Sorbet.sig {returns(::T.untyped)}
  def id(); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def load_private_key(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def load_public_key(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def name(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_default(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.by_id(_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.cleanup(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.engines(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load(*_); end
end

class OpenSSL::Engine::EngineError < OpenSSL::OpenSSLError
end

module OpenSSL::ExtConfig
  HAVE_TLSEXT_HOST_NAME = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_SOCK = ::T.let(nil, ::T.untyped)
  TLS_DH_anon_WITH_AES_256_GCM_SHA384 = ::T.let(nil, ::T.untyped)

end

class OpenSSL::HMAC
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <<(_); end

  Sorbet.sig {returns(::T.untyped)}
  def digest(); end

  Sorbet.sig {returns(::T.untyped)}
  def hexdigest(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(_, _1); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig {returns(::T.untyped)}
  def reset(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def update(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest(_, _1, _2); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hexdigest(_, _1, _2); end
end

class OpenSSL::HMACError < OpenSSL::OpenSSLError
end

module OpenSSL::Netscape
end

class OpenSSL::Netscape::SPKI
  Sorbet.sig {returns(::T.untyped)}
  def challenge(); end

  Sorbet.sig do
    params(
      challenge: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def challenge=(challenge); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def public_key(); end

  Sorbet.sig do
    params(
      public_key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def public_key=(public_key); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign(_, _1); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_pem(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_text(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(_); end
end

class OpenSSL::Netscape::SPKIError < OpenSSL::OpenSSLError
end

module OpenSSL::OCSP
  NOCASIGN = ::T.let(nil, ::T.untyped)
  NOCERTS = ::T.let(nil, ::T.untyped)
  NOCHAIN = ::T.let(nil, ::T.untyped)
  NOCHECKS = ::T.let(nil, ::T.untyped)
  NODELEGATED = ::T.let(nil, ::T.untyped)
  NOEXPLICIT = ::T.let(nil, ::T.untyped)
  NOINTERN = ::T.let(nil, ::T.untyped)
  NOSIGS = ::T.let(nil, ::T.untyped)
  NOTIME = ::T.let(nil, ::T.untyped)
  NOVERIFY = ::T.let(nil, ::T.untyped)
  RESPID_KEY = ::T.let(nil, ::T.untyped)
  RESPONSE_STATUS_INTERNALERROR = ::T.let(nil, ::T.untyped)
  RESPONSE_STATUS_MALFORMEDREQUEST = ::T.let(nil, ::T.untyped)
  RESPONSE_STATUS_SIGREQUIRED = ::T.let(nil, ::T.untyped)
  RESPONSE_STATUS_SUCCESSFUL = ::T.let(nil, ::T.untyped)
  RESPONSE_STATUS_TRYLATER = ::T.let(nil, ::T.untyped)
  RESPONSE_STATUS_UNAUTHORIZED = ::T.let(nil, ::T.untyped)
  REVOKED_STATUS_AFFILIATIONCHANGED = ::T.let(nil, ::T.untyped)
  REVOKED_STATUS_CACOMPROMISE = ::T.let(nil, ::T.untyped)
  REVOKED_STATUS_CERTIFICATEHOLD = ::T.let(nil, ::T.untyped)
  REVOKED_STATUS_CESSATIONOFOPERATION = ::T.let(nil, ::T.untyped)
  REVOKED_STATUS_KEYCOMPROMISE = ::T.let(nil, ::T.untyped)
  REVOKED_STATUS_NOSTATUS = ::T.let(nil, ::T.untyped)
  REVOKED_STATUS_REMOVEFROMCRL = ::T.let(nil, ::T.untyped)
  REVOKED_STATUS_SUPERSEDED = ::T.let(nil, ::T.untyped)
  REVOKED_STATUS_UNSPECIFIED = ::T.let(nil, ::T.untyped)
  TRUSTOTHER = ::T.let(nil, ::T.untyped)
  V_CERTSTATUS_GOOD = ::T.let(nil, ::T.untyped)
  V_CERTSTATUS_REVOKED = ::T.let(nil, ::T.untyped)
  V_CERTSTATUS_UNKNOWN = ::T.let(nil, ::T.untyped)
  V_RESPID_KEY = ::T.let(nil, ::T.untyped)
  V_RESPID_NAME = ::T.let(nil, ::T.untyped)

end

class OpenSSL::OCSP::BasicResponse
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_nonce(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
      _3: ::T.untyped,
      _4: ::T.untyped,
      _5: ::T.untyped,
      _6: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_status(_, _1, _2, _3, _4, _5, _6); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def copy_nonce(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def find_response(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def responses(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def status(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(*_); end
end

class OpenSSL::OCSP::CertificateId
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cmp(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cmp_issuer(_); end

  Sorbet.sig {returns(::T.untyped)}
  def hash_algorithm(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def issuer_key_hash(); end

  Sorbet.sig {returns(::T.untyped)}
  def issuer_name_hash(); end

  Sorbet.sig {returns(::T.untyped)}
  def serial(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end
end

class OpenSSL::OCSP::OCSPError < OpenSSL::OpenSSLError
end

class OpenSSL::OCSP::Request
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_certid(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_nonce(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def certid(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def check_nonce(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(*_); end
end

class OpenSSL::OCSP::Response
  Sorbet.sig {returns(::T.untyped)}
  def basic(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def status(); end

  Sorbet.sig {returns(::T.untyped)}
  def status_string(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.create(_, _1); end
end

class OpenSSL::OCSP::SingleResponse
  Sorbet.sig {returns(::T.untyped)}
  def cert_status(); end

  Sorbet.sig {returns(::T.untyped)}
  def certid(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def check_validity(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def extensions(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(_); end

  Sorbet.sig {returns(::T.untyped)}
  def next_update(); end

  Sorbet.sig {returns(::T.untyped)}
  def revocation_reason(); end

  Sorbet.sig {returns(::T.untyped)}
  def revocation_time(); end

  Sorbet.sig {returns(::T.untyped)}
  def this_update(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end
end

class OpenSSL::OpenSSLError < StandardError
end

class OpenSSL::PKCS12
  Sorbet.sig {returns(::T.untyped)}
  def ca_certs(); end

  Sorbet.sig {returns(::T.untyped)}
  def certificate(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def key(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.create(*_); end
end

class OpenSSL::PKCS12::PKCS12Error < OpenSSL::OpenSSLError
end

module OpenSSL::PKCS5
  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
      _3: ::T.untyped,
      _4: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.pbkdf2_hmac(_, _1, _2, _3, _4); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
      _3: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.pbkdf2_hmac_sha1(_, _1, _2, _3); end
end

class OpenSSL::PKCS5::PKCS5Error < OpenSSL::OpenSSLError
end

class OpenSSL::PKCS7
  BINARY = ::T.let(nil, ::T.untyped)
  DETACHED = ::T.let(nil, ::T.untyped)
  NOATTR = ::T.let(nil, ::T.untyped)
  NOCERTS = ::T.let(nil, ::T.untyped)
  NOCHAIN = ::T.let(nil, ::T.untyped)
  NOINTERN = ::T.let(nil, ::T.untyped)
  NOSIGS = ::T.let(nil, ::T.untyped)
  NOSMIMECAP = ::T.let(nil, ::T.untyped)
  NOVERIFY = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_certificate(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_crl(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_data(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_recipient(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_signer(_); end

  Sorbet.sig {returns(::T.untyped)}
  def certificates(); end

  Sorbet.sig do
    params(
      certificates: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def certificates=(certificates); end

  Sorbet.sig do
    params(
      cipher: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cipher=(cipher); end

  Sorbet.sig {returns(::T.untyped)}
  def crls(); end

  Sorbet.sig do
    params(
      crls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def crls=(crls); end

  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(data); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def decrypt(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def detached(); end

  Sorbet.sig do
    params(
      detached: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def detached=(detached); end

  Sorbet.sig {returns(::T.untyped)}
  def detached?(); end

  Sorbet.sig {returns(::T.untyped)}
  def error_string(); end

  Sorbet.sig do
    params(
      error_string: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def error_string=(error_string); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def recipients(); end

  Sorbet.sig {returns(::T.untyped)}
  def signers(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_pem(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(type); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.encrypt(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.read_smime(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.sign(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.write_smime(*_); end
end

class OpenSSL::PKCS7::PKCS7Error < OpenSSL::OpenSSLError
end

class OpenSSL::PKCS7::RecipientInfo
  Sorbet.sig {returns(::T.untyped)}
  def enc_key(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(_); end

  Sorbet.sig {returns(::T.untyped)}
  def issuer(); end

  Sorbet.sig {returns(::T.untyped)}
  def serial(); end
end

class OpenSSL::PKCS7::SignerInfo
  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(_, _1, _2); end

  Sorbet.sig {returns(::T.untyped)}
  def issuer(); end

  Sorbet.sig {returns(::T.untyped)}
  def name(); end

  Sorbet.sig {returns(::T.untyped)}
  def serial(); end

  Sorbet.sig {returns(::T.untyped)}
  def signed_time(); end
end

module OpenSSL::PKey
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.read(*_); end
end

class OpenSSL::PKey::DH < OpenSSL::PKey::PKey
  DEFAULT_1024 = ::T.let(nil, ::T.untyped)
  DEFAULT_2048 = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def compute_key(_); end

  Sorbet.sig {returns(::T.untyped)}
  def export(); end

  Sorbet.sig {returns(::T.untyped)}
  def g(); end

  Sorbet.sig do
    params(
      g: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def g=(g); end

  Sorbet.sig {returns(::T.untyped)}
  def generate_key!(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def p(); end

  Sorbet.sig do
    params(
      p: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def p=(p); end

  Sorbet.sig {returns(::T.untyped)}
  def params(); end

  Sorbet.sig {returns(::T.untyped)}
  def params_ok?(); end

  Sorbet.sig {returns(::T.untyped)}
  def priv_key(); end

  Sorbet.sig do
    params(
      priv_key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def priv_key=(priv_key); end

  Sorbet.sig {returns(::T.untyped)}
  def private?(); end

  Sorbet.sig {returns(::T.untyped)}
  def pub_key(); end

  Sorbet.sig do
    params(
      pub_key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def pub_key=(pub_key); end

  Sorbet.sig {returns(::T.untyped)}
  def public?(); end

  Sorbet.sig {returns(::T.untyped)}
  def public_key(); end

  Sorbet.sig {returns(::T.untyped)}
  def q(); end

  Sorbet.sig do
    params(
      q: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def q=(q); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_key(_, _1); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_pqg(_, _1, _2); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_pem(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_text(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.generate(*_); end
end

class OpenSSL::PKey::DHError < OpenSSL::PKey::PKeyError
end

class OpenSSL::PKey::DSA < OpenSSL::PKey::PKey
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def export(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def g(); end

  Sorbet.sig do
    params(
      g: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def g=(g); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def p(); end

  Sorbet.sig do
    params(
      p: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def p=(p); end

  Sorbet.sig {returns(::T.untyped)}
  def params(); end

  Sorbet.sig {returns(::T.untyped)}
  def priv_key(); end

  Sorbet.sig do
    params(
      priv_key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def priv_key=(priv_key); end

  Sorbet.sig {returns(::T.untyped)}
  def private?(); end

  Sorbet.sig {returns(::T.untyped)}
  def pub_key(); end

  Sorbet.sig do
    params(
      pub_key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def pub_key=(pub_key); end

  Sorbet.sig {returns(::T.untyped)}
  def public?(); end

  Sorbet.sig {returns(::T.untyped)}
  def public_key(); end

  Sorbet.sig {returns(::T.untyped)}
  def q(); end

  Sorbet.sig do
    params(
      q: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def q=(q); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_key(_, _1); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_pqg(_, _1, _2); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def syssign(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sysverify(_, _1); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def to_pem(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def to_s(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def to_text(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.generate(_); end
end

class OpenSSL::PKey::DSAError < OpenSSL::PKey::PKeyError
end

class OpenSSL::PKey::EC < OpenSSL::PKey::PKey
  NAMED_CURVE = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def check_key(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dh_compute_key(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dsa_sign_asn1(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dsa_verify_asn1(_, _1); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def export(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def generate_key(); end

  Sorbet.sig {returns(::T.untyped)}
  def generate_key!(); end

  Sorbet.sig {returns(::T.untyped)}
  def group(); end

  Sorbet.sig do
    params(
      group: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def group=(group); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def private?(); end

  Sorbet.sig {returns(::T.untyped)}
  def private_key(); end

  Sorbet.sig do
    params(
      private_key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def private_key=(private_key); end

  Sorbet.sig {returns(::T.untyped)}
  def private_key?(); end

  Sorbet.sig {returns(::T.untyped)}
  def public?(); end

  Sorbet.sig {returns(::T.untyped)}
  def public_key(); end

  Sorbet.sig do
    params(
      public_key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def public_key=(public_key); end

  Sorbet.sig {returns(::T.untyped)}
  def public_key?(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def to_pem(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def to_text(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.builtin_curves(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.generate(_); end
end

class OpenSSL::PKey::EC::Group
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ==(_); end

  Sorbet.sig {returns(::T.untyped)}
  def asn1_flag(); end

  Sorbet.sig do
    params(
      asn1_flag: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def asn1_flag=(asn1_flag); end

  Sorbet.sig {returns(::T.untyped)}
  def cofactor(); end

  Sorbet.sig {returns(::T.untyped)}
  def curve_name(); end

  Sorbet.sig {returns(::T.untyped)}
  def degree(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def eql?(_); end

  Sorbet.sig {returns(::T.untyped)}
  def generator(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def order(); end

  Sorbet.sig {returns(::T.untyped)}
  def point_conversion_form(); end

  Sorbet.sig do
    params(
      point_conversion_form: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def point_conversion_form=(point_conversion_form); end

  Sorbet.sig {returns(::T.untyped)}
  def seed(); end

  Sorbet.sig do
    params(
      seed: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def seed=(seed); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_generator(_, _1, _2); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_pem(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_text(); end
end

class OpenSSL::PKey::EC::Group::Error < OpenSSL::OpenSSLError
end

class OpenSSL::PKey::EC::Point
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ==(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def eql?(_); end

  Sorbet.sig {returns(::T.untyped)}
  def group(); end

  Sorbet.sig {returns(::T.untyped)}
  def infinity?(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def invert!(); end

  Sorbet.sig {returns(::T.untyped)}
  def make_affine!(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mul(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def on_curve?(); end

  Sorbet.sig {returns(::T.untyped)}
  def set_to_infinity!(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def to_bn(*_); end
end

class OpenSSL::PKey::EC::Point::Error < OpenSSL::OpenSSLError
end

class OpenSSL::PKey::ECError < OpenSSL::PKey::PKeyError
end

class OpenSSL::PKey::PKey
  Sorbet.sig {returns(::T.untyped)}
  def initialize(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign(_, _1); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(_, _1, _2); end
end

class OpenSSL::PKey::PKeyError < OpenSSL::OpenSSLError
end

class OpenSSL::PKey::RSA < OpenSSL::PKey::PKey
  NO_PADDING = ::T.let(nil, ::T.untyped)
  PKCS1_OAEP_PADDING = ::T.let(nil, ::T.untyped)
  PKCS1_PADDING = ::T.let(nil, ::T.untyped)
  SSLV23_PADDING = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def d(); end

  Sorbet.sig do
    params(
      d: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def d=(d); end

  Sorbet.sig {returns(::T.untyped)}
  def dmp1(); end

  Sorbet.sig do
    params(
      dmp1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dmp1=(dmp1); end

  Sorbet.sig {returns(::T.untyped)}
  def dmq1(); end

  Sorbet.sig do
    params(
      dmq1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dmq1=(dmq1); end

  Sorbet.sig {returns(::T.untyped)}
  def e(); end

  Sorbet.sig do
    params(
      e: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def e=(e); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def export(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def iqmp(); end

  Sorbet.sig do
    params(
      iqmp: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def iqmp=(iqmp); end

  Sorbet.sig {returns(::T.untyped)}
  def n(); end

  Sorbet.sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def n=(n); end

  Sorbet.sig {returns(::T.untyped)}
  def p(); end

  Sorbet.sig do
    params(
      p: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def p=(p); end

  Sorbet.sig {returns(::T.untyped)}
  def params(); end

  Sorbet.sig {returns(::T.untyped)}
  def private?(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def private_decrypt(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def private_encrypt(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def public?(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def public_decrypt(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def public_encrypt(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def public_key(); end

  Sorbet.sig {returns(::T.untyped)}
  def q(); end

  Sorbet.sig do
    params(
      q: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def q=(q); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_crt_params(_, _1, _2); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_factors(_, _1); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
      _2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_key(_, _1, _2); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def to_pem(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def to_s(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def to_text(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.generate(*_); end
end

class OpenSSL::PKey::RSAError < OpenSSL::PKey::PKeyError
end

module OpenSSL::Random
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.egd(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.egd_bytes(_, _1); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load_random_file(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.pseudo_bytes(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.random_add(_, _1); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.random_bytes(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.seed(_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.status?(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.write_random_file(_); end
end

class OpenSSL::Random::RandomError < OpenSSL::OpenSSLError
end

module OpenSSL::SSL
  OP_ALL = ::T.let(nil, ::T.untyped)
  OP_CIPHER_SERVER_PREFERENCE = ::T.let(nil, ::T.untyped)
  OP_DONT_INSERT_EMPTY_FRAGMENTS = ::T.let(nil, ::T.untyped)
  OP_EPHEMERAL_RSA = ::T.let(nil, ::T.untyped)
  OP_MICROSOFT_BIG_SSLV3_BUFFER = ::T.let(nil, ::T.untyped)
  OP_MICROSOFT_SESS_ID_BUG = ::T.let(nil, ::T.untyped)
  OP_MSIE_SSLV2_RSA_PADDING = ::T.let(nil, ::T.untyped)
  OP_NETSCAPE_CA_DN_BUG = ::T.let(nil, ::T.untyped)
  OP_NETSCAPE_CHALLENGE_BUG = ::T.let(nil, ::T.untyped)
  OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = ::T.let(nil, ::T.untyped)
  OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = ::T.let(nil, ::T.untyped)
  OP_NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_SSLv2 = ::T.let(nil, ::T.untyped)
  OP_NO_SSLv3 = ::T.let(nil, ::T.untyped)
  OP_NO_TICKET = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1 = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_1 = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_2 = ::T.let(nil, ::T.untyped)
  OP_PKCS1_CHECK_1 = ::T.let(nil, ::T.untyped)
  OP_PKCS1_CHECK_2 = ::T.let(nil, ::T.untyped)
  OP_SINGLE_DH_USE = ::T.let(nil, ::T.untyped)
  OP_SINGLE_ECDH_USE = ::T.let(nil, ::T.untyped)
  OP_SSLEAY_080_CLIENT_DH_BUG = ::T.let(nil, ::T.untyped)
  OP_SSLREF2_REUSE_CERT_TYPE_BUG = ::T.let(nil, ::T.untyped)
  OP_TLS_BLOCK_PADDING_BUG = ::T.let(nil, ::T.untyped)
  OP_TLS_D5_BUG = ::T.let(nil, ::T.untyped)
  OP_TLS_ROLLBACK_BUG = ::T.let(nil, ::T.untyped)
  VERIFY_CLIENT_ONCE = ::T.let(nil, ::T.untyped)
  VERIFY_FAIL_IF_NO_PEER_CERT = ::T.let(nil, ::T.untyped)
  VERIFY_NONE = ::T.let(nil, ::T.untyped)
  VERIFY_PEER = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      cert: ::T.untyped,
      hostname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.verify_certificate_identity(cert, hostname); end

  Sorbet.sig do
    params(
      hostname: ::T.untyped,
      san: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.verify_hostname(hostname, san); end

  Sorbet.sig do
    params(
      domain_component: ::T.untyped,
      san_component: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.verify_wildcard(domain_component, san_component); end
end

class OpenSSL::SSL::SSLContext
  DEFAULT_CERT_STORE = ::T.let(nil, ::T.untyped)
  DEFAULT_PARAMS = ::T.let(nil, ::T.untyped)
  SESSION_CACHE_BOTH = ::T.let(nil, ::T.untyped)
  SESSION_CACHE_CLIENT = ::T.let(nil, ::T.untyped)
  SESSION_CACHE_NO_AUTO_CLEAR = ::T.let(nil, ::T.untyped)
  SESSION_CACHE_NO_INTERNAL = ::T.let(nil, ::T.untyped)
  SESSION_CACHE_NO_INTERNAL_LOOKUP = ::T.let(nil, ::T.untyped)
  SESSION_CACHE_NO_INTERNAL_STORE = ::T.let(nil, ::T.untyped)
  SESSION_CACHE_OFF = ::T.let(nil, ::T.untyped)
  SESSION_CACHE_SERVER = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def ca_file(); end

  Sorbet.sig do
    params(
      ca_file: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ca_file=(ca_file); end

  Sorbet.sig {returns(::T.untyped)}
  def ca_path(); end

  Sorbet.sig do
    params(
      ca_path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ca_path=(ca_path); end

  Sorbet.sig {returns(::T.untyped)}
  def cert(); end

  Sorbet.sig do
    params(
      cert: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cert=(cert); end

  Sorbet.sig {returns(::T.untyped)}
  def cert_store(); end

  Sorbet.sig do
    params(
      cert_store: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cert_store=(cert_store); end

  Sorbet.sig {returns(::T.untyped)}
  def ciphers(); end

  Sorbet.sig do
    params(
      ciphers: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ciphers=(ciphers); end

  Sorbet.sig {returns(::T.untyped)}
  def client_ca(); end

  Sorbet.sig do
    params(
      client_ca: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def client_ca=(client_ca); end

  Sorbet.sig {returns(::T.untyped)}
  def client_cert_cb(); end

  Sorbet.sig do
    params(
      client_cert_cb: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def client_cert_cb=(client_cert_cb); end

  Sorbet.sig do
    params(
      ecdh_curves: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ecdh_curves=(ecdh_curves); end

  Sorbet.sig {returns(::T.untyped)}
  def extra_chain_cert(); end

  Sorbet.sig do
    params(
      extra_chain_cert: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extra_chain_cert=(extra_chain_cert); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def flush_sessions(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def freeze(); end

  Sorbet.sig do
    params(
      version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(version=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def key(); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key=(key); end

  Sorbet.sig {returns(::T.untyped)}
  def npn_protocols(); end

  Sorbet.sig do
    params(
      npn_protocols: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def npn_protocols=(npn_protocols); end

  Sorbet.sig {returns(::T.untyped)}
  def npn_select_cb(); end

  Sorbet.sig do
    params(
      npn_select_cb: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def npn_select_cb=(npn_select_cb); end

  Sorbet.sig {returns(::T.untyped)}
  def options(); end

  Sorbet.sig do
    params(
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def options=(options); end

  Sorbet.sig {returns(::T.untyped)}
  def renegotiation_cb(); end

  Sorbet.sig do
    params(
      renegotiation_cb: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def renegotiation_cb=(renegotiation_cb); end

  Sorbet.sig {returns(::T.untyped)}
  def security_level(); end

  Sorbet.sig do
    params(
      security_level: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def security_level=(security_level); end

  Sorbet.sig {returns(::T.untyped)}
  def servername_cb(); end

  Sorbet.sig do
    params(
      servername_cb: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def servername_cb=(servername_cb); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def session_add(_); end

  Sorbet.sig {returns(::T.untyped)}
  def session_cache_mode(); end

  Sorbet.sig do
    params(
      session_cache_mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def session_cache_mode=(session_cache_mode); end

  Sorbet.sig {returns(::T.untyped)}
  def session_cache_size(); end

  Sorbet.sig do
    params(
      session_cache_size: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def session_cache_size=(session_cache_size); end

  Sorbet.sig {returns(::T.untyped)}
  def session_cache_stats(); end

  Sorbet.sig {returns(::T.untyped)}
  def session_get_cb(); end

  Sorbet.sig do
    params(
      session_get_cb: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def session_get_cb=(session_get_cb); end

  Sorbet.sig {returns(::T.untyped)}
  def session_id_context(); end

  Sorbet.sig do
    params(
      session_id_context: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def session_id_context=(session_id_context); end

  Sorbet.sig {returns(::T.untyped)}
  def session_new_cb(); end

  Sorbet.sig do
    params(
      session_new_cb: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def session_new_cb=(session_new_cb); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def session_remove(_); end

  Sorbet.sig {returns(::T.untyped)}
  def session_remove_cb(); end

  Sorbet.sig do
    params(
      session_remove_cb: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def session_remove_cb=(session_remove_cb); end

  Sorbet.sig do
    params(
      params: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_params(params=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def setup(); end

  Sorbet.sig {returns(::T.untyped)}
  def ssl_timeout(); end

  Sorbet.sig do
    params(
      ssl_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_timeout=(ssl_timeout); end

  Sorbet.sig do
    params(
      ssl_version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_version=(ssl_version); end

  Sorbet.sig {returns(::T.untyped)}
  def timeout(); end

  Sorbet.sig do
    params(
      timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def timeout=(timeout); end

  Sorbet.sig {returns(::T.untyped)}
  def tmp_dh_callback(); end

  Sorbet.sig do
    params(
      tmp_dh_callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def tmp_dh_callback=(tmp_dh_callback); end

  Sorbet.sig {returns(::T.untyped)}
  def tmp_ecdh_callback(); end

  Sorbet.sig do
    params(
      tmp_ecdh_callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def tmp_ecdh_callback=(tmp_ecdh_callback); end

  Sorbet.sig {returns(::T.untyped)}
  def verify_callback(); end

  Sorbet.sig do
    params(
      verify_callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_callback=(verify_callback); end

  Sorbet.sig {returns(::T.untyped)}
  def verify_depth(); end

  Sorbet.sig do
    params(
      verify_depth: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_depth=(verify_depth); end

  Sorbet.sig {returns(::T.untyped)}
  def verify_hostname(); end

  Sorbet.sig do
    params(
      verify_hostname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_hostname=(verify_hostname); end

  Sorbet.sig {returns(::T.untyped)}
  def verify_mode(); end

  Sorbet.sig do
    params(
      verify_mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_mode=(verify_mode); end
end

class OpenSSL::SSL::SSLError < OpenSSL::OpenSSLError
end

class OpenSSL::SSL::SSLErrorWaitReadable < OpenSSL::SSL::SSLError
  include ::IO::WaitReadable
end

class OpenSSL::SSL::SSLErrorWaitWritable < OpenSSL::SSL::SSLError
  include ::IO::WaitWritable
end

class OpenSSL::SSL::SSLServer
  include ::OpenSSL::SSL::SocketForwarder
  Sorbet.sig {returns(::T.untyped)}
  def accept(); end

  Sorbet.sig {returns(::T.untyped)}
  def close(); end

  Sorbet.sig do
    params(
      svr: ::T.untyped,
      ctx: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(svr, ctx); end

  Sorbet.sig do
    params(
      backlog: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def listen(backlog=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      how: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def shutdown(how=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def start_immediately(); end

  Sorbet.sig do
    params(
      start_immediately: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def start_immediately=(start_immediately); end

  Sorbet.sig {returns(::T.untyped)}
  def to_io(); end
end

class OpenSSL::SSL::SSLSocket
  include ::OpenSSL::SSL::SocketForwarder
  include ::OpenSSL::Buffering
  include ::Enumerable
  Sorbet.sig {returns(::T.untyped)}
  def accept(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def accept_nonblock(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def cert(); end

  Sorbet.sig {returns(::T.untyped)}
  def cipher(); end

  Sorbet.sig {returns(::T.untyped)}
  def client_ca(); end

  Sorbet.sig {returns(::T.untyped)}
  def connect(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connect_nonblock(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def context(); end

  Sorbet.sig {returns(::T.untyped)}
  def hostname(); end

  Sorbet.sig do
    params(
      hostname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def hostname=(hostname); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def io(); end

  Sorbet.sig {returns(::T.untyped)}
  def npn_protocol(); end

  Sorbet.sig {returns(::T.untyped)}
  def peer_cert(); end

  Sorbet.sig {returns(::T.untyped)}
  def peer_cert_chain(); end

  Sorbet.sig {returns(::T.untyped)}
  def pending(); end

  Sorbet.sig do
    params(
      hostname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def post_connection_check(hostname); end

  Sorbet.sig {returns(::T.untyped)}
  def session(); end

  Sorbet.sig do
    params(
      session: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def session=(session); end

  Sorbet.sig {returns(::T.untyped)}
  def session_reused?(); end

  Sorbet.sig {returns(::T.untyped)}
  def ssl_version(); end

  Sorbet.sig {returns(::T.untyped)}
  def state(); end

  Sorbet.sig {returns(::T.untyped)}
  def sync_close(); end

  Sorbet.sig do
    params(
      sync_close: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sync_close=(sync_close); end

  Sorbet.sig {returns(::T.untyped)}
  def sysclose(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sysread(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def syswrite(_); end

  Sorbet.sig {returns(::T.untyped)}
  def to_io(); end

  Sorbet.sig {returns(::T.untyped)}
  def verify_result(); end
end

class OpenSSL::SSL::Session
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ==(_); end

  Sorbet.sig {returns(::T.untyped)}
  def id(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(_); end

  Sorbet.sig {returns(::T.untyped)}
  def time(); end

  Sorbet.sig do
    params(
      time: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def time=(time); end

  Sorbet.sig {returns(::T.untyped)}
  def timeout(); end

  Sorbet.sig do
    params(
      timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def timeout=(timeout); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_pem(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_text(); end
end

class OpenSSL::SSL::Session::SessionError < OpenSSL::OpenSSLError
end

module OpenSSL::SSL::SocketForwarder
  Sorbet.sig {returns(::T.untyped)}
  def addr(); end

  Sorbet.sig {returns(::T.untyped)}
  def closed?(); end

  Sorbet.sig do
    params(
      flag: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def do_not_reverse_lookup=(flag); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fcntl(*args); end

  Sorbet.sig do
    params(
      level: ::T.untyped,
      optname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def getsockopt(level, optname); end

  Sorbet.sig {returns(::T.untyped)}
  def peeraddr(); end

  Sorbet.sig do
    params(
      level: ::T.untyped,
      optname: ::T.untyped,
      optval: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def setsockopt(level, optname, optval); end
end

module OpenSSL::X509
  DEFAULT_CERT_AREA = ::T.let(nil, ::T.untyped)
  DEFAULT_CERT_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_CERT_DIR_ENV = ::T.let(nil, ::T.untyped)
  DEFAULT_CERT_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_CERT_FILE_ENV = ::T.let(nil, ::T.untyped)
  DEFAULT_PRIVATE_DIR = ::T.let(nil, ::T.untyped)
  PURPOSE_ANY = ::T.let(nil, ::T.untyped)
  PURPOSE_CRL_SIGN = ::T.let(nil, ::T.untyped)
  PURPOSE_NS_SSL_SERVER = ::T.let(nil, ::T.untyped)
  PURPOSE_OCSP_HELPER = ::T.let(nil, ::T.untyped)
  PURPOSE_SMIME_ENCRYPT = ::T.let(nil, ::T.untyped)
  PURPOSE_SMIME_SIGN = ::T.let(nil, ::T.untyped)
  PURPOSE_SSL_CLIENT = ::T.let(nil, ::T.untyped)
  PURPOSE_SSL_SERVER = ::T.let(nil, ::T.untyped)
  PURPOSE_TIMESTAMP_SIGN = ::T.let(nil, ::T.untyped)
  TRUST_COMPAT = ::T.let(nil, ::T.untyped)
  TRUST_EMAIL = ::T.let(nil, ::T.untyped)
  TRUST_OBJECT_SIGN = ::T.let(nil, ::T.untyped)
  TRUST_OCSP_REQUEST = ::T.let(nil, ::T.untyped)
  TRUST_OCSP_SIGN = ::T.let(nil, ::T.untyped)
  TRUST_SSL_CLIENT = ::T.let(nil, ::T.untyped)
  TRUST_SSL_SERVER = ::T.let(nil, ::T.untyped)
  TRUST_TSA = ::T.let(nil, ::T.untyped)
  V_ERR_AKID_ISSUER_SERIAL_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_AKID_SKID_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_APPLICATION_VERIFICATION = ::T.let(nil, ::T.untyped)
  V_ERR_CERT_CHAIN_TOO_LONG = ::T.let(nil, ::T.untyped)
  V_ERR_CERT_HAS_EXPIRED = ::T.let(nil, ::T.untyped)
  V_ERR_CERT_NOT_YET_VALID = ::T.let(nil, ::T.untyped)
  V_ERR_CERT_REJECTED = ::T.let(nil, ::T.untyped)
  V_ERR_CERT_REVOKED = ::T.let(nil, ::T.untyped)
  V_ERR_CERT_SIGNATURE_FAILURE = ::T.let(nil, ::T.untyped)
  V_ERR_CERT_UNTRUSTED = ::T.let(nil, ::T.untyped)
  V_ERR_CRL_HAS_EXPIRED = ::T.let(nil, ::T.untyped)
  V_ERR_CRL_NOT_YET_VALID = ::T.let(nil, ::T.untyped)
  V_ERR_CRL_SIGNATURE_FAILURE = ::T.let(nil, ::T.untyped)
  V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT = ::T.let(nil, ::T.untyped)
  V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD = ::T.let(nil, ::T.untyped)
  V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD = ::T.let(nil, ::T.untyped)
  V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD = ::T.let(nil, ::T.untyped)
  V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_CA = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_PURPOSE = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_CERTSIGN = ::T.let(nil, ::T.untyped)
  V_ERR_OUT_OF_MEM = ::T.let(nil, ::T.untyped)
  V_ERR_PATH_LENGTH_EXCEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_SELF_SIGNED_CERT_IN_CHAIN = ::T.let(nil, ::T.untyped)
  V_ERR_SUBJECT_ISSUER_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_GET_CRL = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_GET_ISSUER_CERT = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE = ::T.let(nil, ::T.untyped)
  V_FLAG_ALLOW_PROXY_CERTS = ::T.let(nil, ::T.untyped)
  V_FLAG_CHECK_SS_SIGNATURE = ::T.let(nil, ::T.untyped)
  V_FLAG_CRL_CHECK = ::T.let(nil, ::T.untyped)
  V_FLAG_CRL_CHECK_ALL = ::T.let(nil, ::T.untyped)
  V_FLAG_EXPLICIT_POLICY = ::T.let(nil, ::T.untyped)
  V_FLAG_EXTENDED_CRL_SUPPORT = ::T.let(nil, ::T.untyped)
  V_FLAG_IGNORE_CRITICAL = ::T.let(nil, ::T.untyped)
  V_FLAG_INHIBIT_ANY = ::T.let(nil, ::T.untyped)
  V_FLAG_INHIBIT_MAP = ::T.let(nil, ::T.untyped)
  V_FLAG_NOTIFY_POLICY = ::T.let(nil, ::T.untyped)
  V_FLAG_NO_ALT_CHAINS = ::T.let(nil, ::T.untyped)
  V_FLAG_POLICY_CHECK = ::T.let(nil, ::T.untyped)
  V_FLAG_USE_DELTAS = ::T.let(nil, ::T.untyped)
  V_FLAG_X509_STRICT = ::T.let(nil, ::T.untyped)
  V_OK = ::T.let(nil, ::T.untyped)

end

class OpenSSL::X509::Attribute
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def oid(); end

  Sorbet.sig do
    params(
      oid: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def oid=(oid); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def value=(value); end
end

class OpenSSL::X509::AttributeError < OpenSSL::OpenSSLError
end

class OpenSSL::X509::CRL
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_extension(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_revoked(_); end

  Sorbet.sig {returns(::T.untyped)}
  def extensions(); end

  Sorbet.sig do
    params(
      extensions: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extensions=(extensions); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def issuer(); end

  Sorbet.sig do
    params(
      issuer: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def issuer=(issuer); end

  Sorbet.sig {returns(::T.untyped)}
  def last_update(); end

  Sorbet.sig do
    params(
      last_update: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def last_update=(last_update); end

  Sorbet.sig {returns(::T.untyped)}
  def next_update(); end

  Sorbet.sig do
    params(
      next_update: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def next_update=(next_update); end

  Sorbet.sig {returns(::T.untyped)}
  def revoked(); end

  Sorbet.sig do
    params(
      revoked: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def revoked=(revoked); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign(_, _1); end

  Sorbet.sig {returns(::T.untyped)}
  def signature_algorithm(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_pem(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_text(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(_); end

  Sorbet.sig {returns(::T.untyped)}
  def version(); end

  Sorbet.sig do
    params(
      version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def version=(version); end
end

class OpenSSL::X509::CRLError < OpenSSL::OpenSSLError
end

class OpenSSL::X509::Certificate
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_extension(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def check_private_key(_); end

  Sorbet.sig {returns(::T.untyped)}
  def extensions(); end

  Sorbet.sig do
    params(
      extensions: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extensions=(extensions); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig {returns(::T.untyped)}
  def issuer(); end

  Sorbet.sig do
    params(
      issuer: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def issuer=(issuer); end

  Sorbet.sig {returns(::T.untyped)}
  def not_after(); end

  Sorbet.sig do
    params(
      not_after: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def not_after=(not_after); end

  Sorbet.sig {returns(::T.untyped)}
  def not_before(); end

  Sorbet.sig do
    params(
      not_before: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def not_before=(not_before); end

  Sorbet.sig do
    params(
      q: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def pretty_print(q); end

  Sorbet.sig {returns(::T.untyped)}
  def public_key(); end

  Sorbet.sig do
    params(
      public_key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def public_key=(public_key); end

  Sorbet.sig {returns(::T.untyped)}
  def serial(); end

  Sorbet.sig do
    params(
      serial: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def serial=(serial); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign(_, _1); end

  Sorbet.sig {returns(::T.untyped)}
  def signature_algorithm(); end

  Sorbet.sig {returns(::T.untyped)}
  def subject(); end

  Sorbet.sig do
    params(
      subject: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subject=(subject); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_pem(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_text(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(_); end

  Sorbet.sig {returns(::T.untyped)}
  def version(); end

  Sorbet.sig do
    params(
      version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def version=(version); end
end

class OpenSSL::X509::CertificateError < OpenSSL::OpenSSLError
end

class OpenSSL::X509::Extension
  Sorbet.sig do
    params(
      critical: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def critical=(critical); end

  Sorbet.sig {returns(::T.untyped)}
  def critical?(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def oid(); end

  Sorbet.sig do
    params(
      oid: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def oid=(oid); end

  Sorbet.sig {returns(::T.untyped)}
  def to_a(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_h(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def value=(value); end
end

class OpenSSL::X509::ExtensionError < OpenSSL::OpenSSLError
end

class OpenSSL::X509::ExtensionFactory
  Sorbet.sig {returns(::T.untyped)}
  def config(); end

  Sorbet.sig do
    params(
      config: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def config=(config); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def create_ext(*_); end

  Sorbet.sig do
    params(
      ary: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def create_ext_from_array(ary); end

  Sorbet.sig do
    params(
      hash: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def create_ext_from_hash(hash); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def create_ext_from_string(str); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def create_extension(*arg); end

  Sorbet.sig {returns(::T.untyped)}
  def crl(); end

  Sorbet.sig do
    params(
      crl: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def crl=(crl); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def issuer_certificate(); end

  Sorbet.sig do
    params(
      issuer_certificate: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def issuer_certificate=(issuer_certificate); end

  Sorbet.sig {returns(::T.untyped)}
  def subject_certificate(); end

  Sorbet.sig do
    params(
      subject_certificate: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subject_certificate=(subject_certificate); end

  Sorbet.sig {returns(::T.untyped)}
  def subject_request(); end

  Sorbet.sig do
    params(
      subject_request: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subject_request=(subject_request); end
end

class OpenSSL::X509::Name
  include ::Comparable
  COMPAT = ::T.let(nil, ::T.untyped)
  DEFAULT_OBJECT_TYPE = ::T.let(nil, ::T.untyped)
  MULTILINE = ::T.let(nil, ::T.untyped)
  OBJECT_TYPE_TEMPLATE = ::T.let(nil, ::T.untyped)
  ONELINE = ::T.let(nil, ::T.untyped)
  RFC2253 = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <=>(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_entry(*_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cmp(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def eql?(_); end

  Sorbet.sig {returns(::T.untyped)}
  def hash(); end

  Sorbet.sig {returns(::T.untyped)}
  def hash_old(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig do
    params(
      q: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def pretty_print(q); end

  Sorbet.sig {returns(::T.untyped)}
  def to_a(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def to_s(*_); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
      template: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(str, template=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
      template: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse_openssl(str, template=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
      template: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse_rfc2253(str, template=T.unsafe(nil)); end
end

module OpenSSL::X509::Name::RFC2253DN
  AttributeType = ::T.let(nil, ::T.untyped)
  AttributeValue = ::T.let(nil, ::T.untyped)
  HexChar = ::T.let(nil, ::T.untyped)
  HexPair = ::T.let(nil, ::T.untyped)
  HexString = ::T.let(nil, ::T.untyped)
  Pair = ::T.let(nil, ::T.untyped)
  QuoteChar = ::T.let(nil, ::T.untyped)
  Special = ::T.let(nil, ::T.untyped)
  StringChar = ::T.let(nil, ::T.untyped)
  TypeAndValue = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.expand_hexstring(str); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.expand_pair(str); end

  Sorbet.sig do
    params(
      str1: ::T.untyped,
      str2: ::T.untyped,
      str3: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.expand_value(str1, str2, str3); end

  Sorbet.sig do
    params(
      dn: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.scan(dn); end
end

class OpenSSL::X509::NameError < OpenSSL::OpenSSLError
end

class OpenSSL::X509::Request
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_attribute(_); end

  Sorbet.sig {returns(::T.untyped)}
  def attributes(); end

  Sorbet.sig do
    params(
      attributes: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attributes=(attributes); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def public_key(); end

  Sorbet.sig do
    params(
      public_key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def public_key=(public_key); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign(_, _1); end

  Sorbet.sig {returns(::T.untyped)}
  def signature_algorithm(); end

  Sorbet.sig {returns(::T.untyped)}
  def subject(); end

  Sorbet.sig do
    params(
      subject: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subject=(subject); end

  Sorbet.sig {returns(::T.untyped)}
  def to_der(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_pem(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_text(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(_); end

  Sorbet.sig {returns(::T.untyped)}
  def version(); end

  Sorbet.sig do
    params(
      version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def version=(version); end
end

class OpenSSL::X509::RequestError < OpenSSL::OpenSSLError
end

class OpenSSL::X509::Revoked
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_extension(_); end

  Sorbet.sig {returns(::T.untyped)}
  def extensions(); end

  Sorbet.sig do
    params(
      extensions: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extensions=(extensions); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def serial(); end

  Sorbet.sig do
    params(
      serial: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def serial=(serial); end

  Sorbet.sig {returns(::T.untyped)}
  def time(); end

  Sorbet.sig do
    params(
      time: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def time=(time); end
end

class OpenSSL::X509::RevokedError < OpenSSL::OpenSSLError
end

class OpenSSL::X509::Store
  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_cert(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_crl(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_file(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_path(_); end

  Sorbet.sig {returns(::T.untyped)}
  def chain(); end

  Sorbet.sig {returns(::T.untyped)}
  def error(); end

  Sorbet.sig {returns(::T.untyped)}
  def error_string(); end

  Sorbet.sig do
    params(
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def flags=(flags); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig do
    params(
      purpose: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def purpose=(purpose); end

  Sorbet.sig {returns(::T.untyped)}
  def set_default_paths(); end

  Sorbet.sig do
    params(
      time: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def time=(time); end

  Sorbet.sig do
    params(
      trust: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def trust=(trust); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(*_); end

  Sorbet.sig {returns(::T.untyped)}
  def verify_callback(); end

  Sorbet.sig do
    params(
      verify_callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_callback=(verify_callback); end
end

class OpenSSL::X509::StoreContext
  Sorbet.sig {returns(::T.untyped)}
  def chain(); end

  Sorbet.sig {returns(::T.untyped)}
  def cleanup(); end

  Sorbet.sig {returns(::T.untyped)}
  def current_cert(); end

  Sorbet.sig {returns(::T.untyped)}
  def current_crl(); end

  Sorbet.sig {returns(::T.untyped)}
  def error(); end

  Sorbet.sig do
    params(
      error: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def error=(error); end

  Sorbet.sig {returns(::T.untyped)}
  def error_depth(); end

  Sorbet.sig {returns(::T.untyped)}
  def error_string(); end

  Sorbet.sig do
    params(
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def flags=(flags); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig do
    params(
      purpose: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def purpose=(purpose); end

  Sorbet.sig do
    params(
      time: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def time=(time); end

  Sorbet.sig do
    params(
      trust: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def trust=(trust); end

  Sorbet.sig {returns(::T.untyped)}
  def verify(); end
end

class OpenSSL::X509::StoreError < OpenSSL::OpenSSLError
end
