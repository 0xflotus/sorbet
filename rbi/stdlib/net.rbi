# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   scripts/bin/remote-script sorbet/shim_generation/gems.rb -r net

# typed: true

module Net
end

class Net::BufferedIO
  BUFSIZE = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <<(str); end

  Sorbet.sig {returns(::T.untyped)}
  def close(); end

  Sorbet.sig {returns(::T.untyped)}
  def closed?(); end

  Sorbet.sig {returns(::T.untyped)}
  def continue_timeout(); end

  Sorbet.sig do
    params(
      continue_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def continue_timeout=(continue_timeout); end

  Sorbet.sig {returns(::T.untyped)}
  def debug_output(); end

  Sorbet.sig do
    params(
      debug_output: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def debug_output=(debug_output); end

  Sorbet.sig {returns(::T.untyped)}
  def eof?(); end

  Sorbet.sig do
    params(
      io: ::T.untyped,
      read_timeout: ::T.untyped,
      continue_timeout: ::T.untyped,
      debug_output: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(io, read_timeout: T.unsafe(nil), continue_timeout: T.unsafe(nil), debug_output: T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig {returns(::T.untyped)}
  def io(); end

  Sorbet.sig do
    params(
      len: ::T.untyped,
      dest: ::T.untyped,
      ignore_eof: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(len, dest=T.unsafe(nil), ignore_eof=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      dest: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_all(dest=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def read_timeout(); end

  Sorbet.sig do
    params(
      read_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(read_timeout); end

  Sorbet.sig {returns(::T.untyped)}
  def readline(); end

  Sorbet.sig do
    params(
      terminator: ::T.untyped,
      ignore_eof: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readuntil(terminator, ignore_eof=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(str); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def writeline(str); end
end

module Net::DNS
  include ::Net::DNS::QueryClasses
  include ::Net::DNS::QueryTypes
  include ::Logger::Severity
  HFIXEDSZ = ::T.let(nil, ::T.untyped)
  INT16SZ = ::T.let(nil, ::T.untyped)
  INT32SZ = ::T.let(nil, ::T.untyped)
  PACKETSZ = ::T.let(nil, ::T.untyped)
  QFIXEDSZ = ::T.let(nil, ::T.untyped)
  RRFIXEDSZ = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)

end

class Net::DNS::Header
  IQUERY = ::T.let(nil, ::T.untyped)
  OPARR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  STATUS = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def aa=(val); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ad=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def anCount(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def anCount=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def arCount(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def arCount=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def auth?(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cd=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def checking?(); end

  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig {returns(::T.untyped)}
  def error?(); end

  Sorbet.sig {returns(::T.untyped)}
  def format(); end

  Sorbet.sig {returns(::T.untyped)}
  def id(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def id=(val); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(arg=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig {returns(::T.untyped)}
  def nsCount(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def nsCount=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def opCode(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def opCode=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def opCode_str(); end

  Sorbet.sig {returns(::T.untyped)}
  def qdCount(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def qdCount=(val); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def qr=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def query?(); end

  Sorbet.sig {returns(::T.untyped)}
  def rCode(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rCode=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def rCode_str(); end

  Sorbet.sig {returns(::T.untyped)}
  def r_available?(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ra=(val); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rd=(val); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def recursive=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def recursive?(); end

  Sorbet.sig {returns(::T.untyped)}
  def response?(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def tc=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def truncated?(); end

  Sorbet.sig {returns(::T.untyped)}
  def verified?(); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(arg); end
end

class Net::DNS::Header::Error < StandardError
end

class Net::DNS::Header::RCode
  FORMAT = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NOTIMPLEMENTED = ::T.let(nil, ::T.untyped)
  RCodeErrorString = ::T.let(nil, ::T.untyped)
  RCodeType = ::T.let(nil, ::T.untyped)
  REFUSED = ::T.let(nil, ::T.untyped)
  SERVER = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def code(); end

  Sorbet.sig {returns(::T.untyped)}
  def explanation(); end

  Sorbet.sig do
    params(
      code: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(code); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end
end

class Net::DNS::Header::WrongCountError < ArgumentError
end

class Net::DNS::Header::WrongOpcodeError < ArgumentError
end

class Net::DNS::Header::WrongRecursiveError < ArgumentError
end

module Net::DNS::Names
  INT16SZ = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      name: ::T.untyped,
      offset: ::T.untyped,
      compnames: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dn_comp(name, offset, compnames); end

  Sorbet.sig do
    params(
      packet: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dn_expand(packet, offset); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def names_array(name); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def pack_name(name); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def valid?(name); end
end

class Net::DNS::Names::Error < StandardError
end

class Net::DNS::Names::ExpandError < Net::DNS::Names::Error
end

class Net::DNS::Packet
  include ::Net::DNS::Names
  Sorbet.sig {returns(::T.untyped)}
  def additional(); end

  Sorbet.sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def additional=(object); end

  Sorbet.sig {returns(::T.untyped)}
  def answer(); end

  Sorbet.sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def answer=(object); end

  Sorbet.sig {returns(::T.untyped)}
  def answerfrom(); end

  Sorbet.sig {returns(::T.untyped)}
  def answersize(); end

  Sorbet.sig {returns(::T.untyped)}
  def authority(); end

  Sorbet.sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authority=(object); end

  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig {returns(::T.untyped)}
  def data_comp(); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_address(&block); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_cname(&block); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_mx(&block); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_nameserver(&block); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_ptr(&block); end

  Sorbet.sig {returns(::T.untyped)}
  def header(); end

  Sorbet.sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def header=(object); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      type: ::T.untyped,
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(name, type=T.unsafe(nil), cls=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig {returns(::T.untyped)}
  def nxdomain?(); end

  Sorbet.sig {returns(::T.untyped)}
  def query?(); end

  Sorbet.sig {returns(::T.untyped)}
  def question(); end

  Sorbet.sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def question=(object); end

  Sorbet.sig {returns(::T.untyped)}
  def size(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def truncated?(); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(*args); end
end

class Net::DNS::Packet::Error < StandardError
end

class Net::DNS::Packet::PacketError < Net::DNS::Packet::Error
end

module Net::DNS::QueryClasses
  ANY = ::T.let(nil, ::T.untyped)
  CH = ::T.let(nil, ::T.untyped)
  HS = ::T.let(nil, ::T.untyped)
  IN = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)

end

module Net::DNS::QueryTypes
  A = ::T.let(nil, ::T.untyped)
  AAAA = ::T.let(nil, ::T.untyped)
  AFSDB = ::T.let(nil, ::T.untyped)
  ANY = ::T.let(nil, ::T.untyped)
  ATMA = ::T.let(nil, ::T.untyped)
  AXFR = ::T.let(nil, ::T.untyped)
  CERT = ::T.let(nil, ::T.untyped)
  CNAME = ::T.let(nil, ::T.untyped)
  DNAME = ::T.let(nil, ::T.untyped)
  DNSKEY = ::T.let(nil, ::T.untyped)
  DS = ::T.let(nil, ::T.untyped)
  EID = ::T.let(nil, ::T.untyped)
  GID = ::T.let(nil, ::T.untyped)
  GPOS = ::T.let(nil, ::T.untyped)
  HINFO = ::T.let(nil, ::T.untyped)
  ISDN = ::T.let(nil, ::T.untyped)
  IXFR = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  KX = ::T.let(nil, ::T.untyped)
  LOC = ::T.let(nil, ::T.untyped)
  MAILA = ::T.let(nil, ::T.untyped)
  MAILB = ::T.let(nil, ::T.untyped)
  MB = ::T.let(nil, ::T.untyped)
  MD = ::T.let(nil, ::T.untyped)
  MF = ::T.let(nil, ::T.untyped)
  MG = ::T.let(nil, ::T.untyped)
  MINFO = ::T.let(nil, ::T.untyped)
  MR = ::T.let(nil, ::T.untyped)
  MX = ::T.let(nil, ::T.untyped)
  NAPTR = ::T.let(nil, ::T.untyped)
  NIMLOC = ::T.let(nil, ::T.untyped)
  NS = ::T.let(nil, ::T.untyped)
  NSAP = ::T.let(nil, ::T.untyped)
  NSAPPTR = ::T.let(nil, ::T.untyped)
  NSEC = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NXT = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  PTR = ::T.let(nil, ::T.untyped)
  PX = ::T.let(nil, ::T.untyped)
  RP = ::T.let(nil, ::T.untyped)
  RRSIG = ::T.let(nil, ::T.untyped)
  RT = ::T.let(nil, ::T.untyped)
  SIG = ::T.let(nil, ::T.untyped)
  SIGZERO = ::T.let(nil, ::T.untyped)
  SOA = ::T.let(nil, ::T.untyped)
  SRV = ::T.let(nil, ::T.untyped)
  SSHFP = ::T.let(nil, ::T.untyped)
  TKEY = ::T.let(nil, ::T.untyped)
  TSIG = ::T.let(nil, ::T.untyped)
  TXT = ::T.let(nil, ::T.untyped)
  UID = ::T.let(nil, ::T.untyped)
  UINFO = ::T.let(nil, ::T.untyped)
  UNSPEC = ::T.let(nil, ::T.untyped)
  WKS = ::T.let(nil, ::T.untyped)
  X25 = ::T.let(nil, ::T.untyped)

end

class Net::DNS::Question
  include ::Net::DNS::Names
  Sorbet.sig {returns(::T.untyped)}
  def comp_data(); end

  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      type: ::T.untyped,
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(name, type=T.unsafe(nil), cls=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig {returns(::T.untyped)}
  def qClass(); end

  Sorbet.sig {returns(::T.untyped)}
  def qName(); end

  Sorbet.sig {returns(::T.untyped)}
  def qType(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(arg); end
end

class Net::DNS::Question::Error < StandardError
end

class Net::DNS::Question::NameInvalid < Net::DNS::Question::Error
end

class Net::DNS::RR
  include ::Net::DNS::Names
  RRFIXEDSZ = ::T.let(nil, ::T.untyped)
  RR_REGEXP = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def cls(); end

  Sorbet.sig do
    params(
      offset: ::T.untyped,
      compnames: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def comp_data(offset, compnames); end

  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(arg); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig {returns(::T.untyped)}
  def name(); end

  Sorbet.sig {returns(::T.untyped)}
  def rdata(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_a(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def ttl(); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*args); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(data); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse_packet(data, offset); end
end

class Net::DNS::RR::A < Net::DNS::RR
  Sorbet.sig {returns(::T.untyped)}
  def address(); end

  Sorbet.sig do
    params(
      string_or_ipaddr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def address=(string_or_ipaddr); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::AAAA < Net::DNS::RR
  Sorbet.sig {returns(::T.untyped)}
  def address(); end

  Sorbet.sig do
    params(
      string_or_ipaddr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def address=(string_or_ipaddr); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::CNAME < Net::DNS::RR
  Sorbet.sig {returns(::T.untyped)}
  def cname(); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::Classes
  CLASSES = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(cls); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_i(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default(); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.default=(str); end

  Sorbet.sig {returns(::T.untyped)}
  def self.regexp(); end

  Sorbet.sig do
    params(
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.valid?(cls); end
end

class Net::DNS::RR::DataError < Net::DNS::RR::Error
end

class Net::DNS::RR::Error < StandardError
end

class Net::DNS::RR::HINFO < Net::DNS::RR
  Sorbet.sig {returns(::T.untyped)}
  def cpu(); end

  Sorbet.sig {returns(::T.untyped)}
  def os(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_a(); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::MR < Net::DNS::RR
  Sorbet.sig {returns(::T.untyped)}
  def newname(); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::MX < Net::DNS::RR
  Sorbet.sig {returns(::T.untyped)}
  def exchange(); end

  Sorbet.sig {returns(::T.untyped)}
  def preference(); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::NS < Net::DNS::RR
  Sorbet.sig {returns(::T.untyped)}
  def nsdname(); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::PTR < Net::DNS::RR
  Sorbet.sig {returns(::T.untyped)}
  def ptr(); end

  Sorbet.sig {returns(::T.untyped)}
  def ptrdname(); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::SOA < Net::DNS::RR
  Sorbet.sig {returns(::T.untyped)}
  def expire(); end

  Sorbet.sig {returns(::T.untyped)}
  def minimum(); end

  Sorbet.sig {returns(::T.untyped)}
  def mname(); end

  Sorbet.sig {returns(::T.untyped)}
  def refresh(); end

  Sorbet.sig {returns(::T.untyped)}
  def retry(); end

  Sorbet.sig {returns(::T.untyped)}
  def rname(); end

  Sorbet.sig {returns(::T.untyped)}
  def serial(); end
end

class Net::DNS::RR::SRV < Net::DNS::RR
  Sorbet.sig {returns(::T.untyped)}
  def host(); end

  Sorbet.sig {returns(::T.untyped)}
  def port(); end

  Sorbet.sig {returns(::T.untyped)}
  def priority(); end

  Sorbet.sig {returns(::T.untyped)}
  def weight(); end
end

class Net::DNS::RR::TXT < Net::DNS::RR
  Sorbet.sig {returns(::T.untyped)}
  def txt(); end
end

class Net::DNS::RR::Types
  TYPES = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(type); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_i(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_str(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default(); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.default=(str); end

  Sorbet.sig {returns(::T.untyped)}
  def self.regexp(); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.to_str(type); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.valid?(type); end
end

class Net::DNS::Resolver
  Defaults = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      name: ::T.untyped,
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def axfr(name, cls=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def defname(); end

  Sorbet.sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def defname=(bool); end

  Sorbet.sig {returns(::T.untyped)}
  def defname?(); end

  Sorbet.sig {returns(::T.untyped)}
  def dns_search(); end

  Sorbet.sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dns_search=(bool); end

  Sorbet.sig {returns(::T.untyped)}
  def dnsrch(); end

  Sorbet.sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dnsrch=(bool); end

  Sorbet.sig {returns(::T.untyped)}
  def domain(); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def domain=(name); end

  Sorbet.sig {returns(::T.untyped)}
  def ignore_truncated(); end

  Sorbet.sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ignore_truncated=(bool); end

  Sorbet.sig {returns(::T.untyped)}
  def ignore_truncated?(); end

  Sorbet.sig do
    params(
      config: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(config=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig do
    params(
      log: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def log_file=(log); end

  Sorbet.sig do
    params(
      level: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def log_level=(level); end

  Sorbet.sig do
    params(
      logger: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def logger=(logger); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mx(name, cls=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def nameserver(); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def nameserver=(arg); end

  Sorbet.sig {returns(::T.untyped)}
  def nameservers(); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def nameservers=(arg); end

  Sorbet.sig {returns(::T.untyped)}
  def packet_size(); end

  Sorbet.sig {returns(::T.untyped)}
  def port(); end

  Sorbet.sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def port=(num); end

  Sorbet.sig {returns(::T.untyped)}
  def print(); end

  Sorbet.sig do
    params(
      argument: ::T.untyped,
      type: ::T.untyped,
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def query(argument, type=T.unsafe(nil), cls=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def recurse(); end

  Sorbet.sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def recurse=(bool); end

  Sorbet.sig {returns(::T.untyped)}
  def recursive(); end

  Sorbet.sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def recursive=(bool); end

  Sorbet.sig {returns(::T.untyped)}
  def recursive?(); end

  Sorbet.sig {returns(::T.untyped)}
  def retrans(); end

  Sorbet.sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retrans=(num); end

  Sorbet.sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retry=(num); end

  Sorbet.sig {returns(::T.untyped)}
  def retry_interval(); end

  Sorbet.sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retry_interval=(num); end

  Sorbet.sig {returns(::T.untyped)}
  def retry_number(); end

  Sorbet.sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retry_number=(num); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      type: ::T.untyped,
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def search(name, type=T.unsafe(nil), cls=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def searchlist(); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def searchlist=(arg); end

  Sorbet.sig {returns(::T.untyped)}
  def source_address(); end

  Sorbet.sig do
    params(
      addr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def source_address=(addr); end

  Sorbet.sig {returns(::T.untyped)}
  def source_address_inet6(); end

  Sorbet.sig {returns(::T.untyped)}
  def source_port(); end

  Sorbet.sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def source_port=(num); end

  Sorbet.sig {returns(::T.untyped)}
  def srcaddr(); end

  Sorbet.sig do
    params(
      addr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def srcaddr=(addr); end

  Sorbet.sig {returns(::T.untyped)}
  def srcport(); end

  Sorbet.sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def srcport=(num); end

  Sorbet.sig {returns(::T.untyped)}
  def state(); end

  Sorbet.sig {returns(::T.untyped)}
  def tcp_timeout(); end

  Sorbet.sig do
    params(
      secs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def tcp_timeout=(secs); end

  Sorbet.sig {returns(::T.untyped)}
  def udp_timeout(); end

  Sorbet.sig do
    params(
      secs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def udp_timeout=(secs); end

  Sorbet.sig {returns(::T.untyped)}
  def use_tcp(); end

  Sorbet.sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def use_tcp=(bool); end

  Sorbet.sig {returns(::T.untyped)}
  def use_tcp?(); end

  Sorbet.sig {returns(::T.untyped)}
  def usevc(); end

  Sorbet.sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def usevc=(bool); end

  Sorbet.sig {returns(::T.untyped)}
  def self.platform_windows?(); end

  Sorbet.sig do
    params(
      params: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.start(*params); end
end

class Net::DNS::Resolver::DnsTimeout
  Sorbet.sig do
    params(
      seconds: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(seconds); end

  Sorbet.sig {returns(::T.untyped)}
  def pretty_to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def seconds(); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def timeout(&block); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end
end

class Net::DNS::Resolver::Error < StandardError
end

class Net::DNS::Resolver::NoResponseError < Net::DNS::Resolver::Error
end

class Net::DNS::Resolver::TcpTimeout < Net::DNS::Resolver::DnsTimeout
  Sorbet.sig do
    params(
      seconds: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(seconds); end
end

class Net::DNS::Resolver::UdpTimeout < Net::DNS::Resolver::DnsTimeout
  Sorbet.sig do
    params(
      seconds: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(seconds); end
end

class Net::FTP < Net::Protocol
  include ::OpenSSL::SSL
  include ::OpenSSL
  include ::MonitorMixin
  CASE_DEPENDENT_PARSER = ::T.let(nil, ::T.untyped)
  CASE_INDEPENDENT_PARSER = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  DECIMAL_PARSER = ::T.let(nil, ::T.untyped)
  DEFAULT_BLOCKSIZE = ::T.let(nil, ::T.untyped)
  FACT_PARSERS = ::T.let(nil, ::T.untyped)
  FTP_PORT = ::T.let(nil, ::T.untyped)
  OCTAL_PARSER = ::T.let(nil, ::T.untyped)
  TIME_PARSER = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def abort(); end

  Sorbet.sig do
    params(
      account: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def acct(account); end

  Sorbet.sig {returns(::T.untyped)}
  def binary(); end

  Sorbet.sig do
    params(
      newmode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def binary=(newmode); end

  Sorbet.sig do
    params(
      dirname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def chdir(dirname); end

  Sorbet.sig {returns(::T.untyped)}
  def close(); end

  Sorbet.sig {returns(::T.untyped)}
  def closed?(); end

  Sorbet.sig do
    params(
      host: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connect(host, port=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def debug_mode(); end

  Sorbet.sig do
    params(
      debug_mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def debug_mode=(debug_mode); end

  Sorbet.sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delete(filename); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dir(*args, &block); end

  Sorbet.sig do
    params(
      remotefile: ::T.untyped,
      localfile: ::T.untyped,
      blocksize: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def get(remotefile, localfile=T.unsafe(nil), blocksize=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      remotefile: ::T.untyped,
      localfile: ::T.untyped,
      blocksize: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def getbinaryfile(remotefile, localfile=T.unsafe(nil), blocksize=T.unsafe(nil), &block); end

  Sorbet.sig {returns(::T.untyped)}
  def getdir(); end

  Sorbet.sig do
    params(
      remotefile: ::T.untyped,
      localfile: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def gettextfile(remotefile, localfile=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def help(arg=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      host: ::T.untyped,
      user_or_options: ::T.untyped,
      passwd: ::T.untyped,
      acct: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(host=T.unsafe(nil), user_or_options=T.unsafe(nil), passwd=T.unsafe(nil), acct=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def last_response(); end

  Sorbet.sig {returns(::T.untyped)}
  def last_response_code(); end

  Sorbet.sig {returns(::T.untyped)}
  def lastresp(); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def list(*args, &block); end

  Sorbet.sig do
    params(
      user: ::T.untyped,
      passwd: ::T.untyped,
      acct: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def login(user=T.unsafe(nil), passwd=T.unsafe(nil), acct=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ls(*args, &block); end

  Sorbet.sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mdtm(filename); end

  Sorbet.sig do
    params(
      dirname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mkdir(dirname); end

  Sorbet.sig do
    params(
      pathname: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mlsd(pathname=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      pathname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mlst(pathname=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      filename: ::T.untyped,
      local: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mtime(filename, local=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      dir: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def nlst(dir=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def noop(); end

  Sorbet.sig {returns(::T.untyped)}
  def open_timeout(); end

  Sorbet.sig do
    params(
      open_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_timeout=(open_timeout); end

  Sorbet.sig {returns(::T.untyped)}
  def passive(); end

  Sorbet.sig do
    params(
      passive: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def passive=(passive); end

  Sorbet.sig do
    params(
      localfile: ::T.untyped,
      remotefile: ::T.untyped,
      blocksize: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def put(localfile, remotefile=T.unsafe(nil), blocksize=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      localfile: ::T.untyped,
      remotefile: ::T.untyped,
      blocksize: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def putbinaryfile(localfile, remotefile=T.unsafe(nil), blocksize=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      localfile: ::T.untyped,
      remotefile: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def puttextfile(localfile, remotefile=T.unsafe(nil), &block); end

  Sorbet.sig {returns(::T.untyped)}
  def pwd(); end

  Sorbet.sig {returns(::T.untyped)}
  def quit(); end

  Sorbet.sig {returns(::T.untyped)}
  def read_timeout(); end

  Sorbet.sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(sec); end

  Sorbet.sig do
    params(
      fromname: ::T.untyped,
      toname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(fromname, toname); end

  Sorbet.sig {returns(::T.untyped)}
  def resume(); end

  Sorbet.sig do
    params(
      resume: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def resume=(resume); end

  Sorbet.sig do
    params(
      cmd: ::T.untyped,
      blocksize: ::T.untyped,
      rest_offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retrbinary(cmd, blocksize, rest_offset=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      cmd: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retrlines(cmd); end

  Sorbet.sig {returns(::T.untyped)}
  def return_code(); end

  Sorbet.sig do
    params(
      s: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def return_code=(s); end

  Sorbet.sig do
    params(
      dirname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rmdir(dirname); end

  Sorbet.sig do
    params(
      cmd: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sendcmd(cmd); end

  Sorbet.sig do
    params(
      sock: ::T.untyped,
      get_greeting: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_socket(sock, get_greeting=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def site(arg); end

  Sorbet.sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size(filename); end

  Sorbet.sig {returns(::T.untyped)}
  def ssl_handshake_timeout(); end

  Sorbet.sig do
    params(
      ssl_handshake_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_handshake_timeout=(ssl_handshake_timeout); end

  Sorbet.sig do
    params(
      pathname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def status(pathname=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      cmd: ::T.untyped,
      file: ::T.untyped,
      blocksize: ::T.untyped,
      rest_offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def storbinary(cmd, file, blocksize, rest_offset=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      cmd: ::T.untyped,
      file: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def storlines(cmd, file); end

  Sorbet.sig {returns(::T.untyped)}
  def system(); end

  Sorbet.sig do
    params(
      cmd: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def voidcmd(cmd); end

  Sorbet.sig {returns(::T.untyped)}
  def welcome(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default_passive(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.default_passive=(value); end

  Sorbet.sig do
    params(
      host: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.open(host, *args); end
end

class Net::FTP::BufferedSSLSocket < Net::FTP::BufferedSocket
  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*args); end

  Sorbet.sig do
    params(
      mesg: ::T.untyped,
      flags: ::T.untyped,
      dest: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send(mesg, flags, dest=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def shutdown(*args); end
end

class Net::FTP::BufferedSocket < Net::BufferedIO
  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def addr(*args); end

  Sorbet.sig {returns(::T.untyped)}
  def gets(); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local_address(*args); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def peeraddr(*args); end

  Sorbet.sig do
    params(
      len: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(len=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def readline(); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remote_address(*args); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send(*args); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def shutdown(*args); end
end

class Net::FTP::MLSxEntry
  Sorbet.sig {returns(::T.untyped)}
  def appendable?(); end

  Sorbet.sig {returns(::T.untyped)}
  def charset(); end

  Sorbet.sig {returns(::T.untyped)}
  def creatable?(); end

  Sorbet.sig {returns(::T.untyped)}
  def create(); end

  Sorbet.sig {returns(::T.untyped)}
  def deletable?(); end

  Sorbet.sig {returns(::T.untyped)}
  def directory?(); end

  Sorbet.sig {returns(::T.untyped)}
  def directory_makable?(); end

  Sorbet.sig {returns(::T.untyped)}
  def enterable?(); end

  Sorbet.sig {returns(::T.untyped)}
  def facts(); end

  Sorbet.sig {returns(::T.untyped)}
  def file?(); end

  Sorbet.sig do
    params(
      facts: ::T.untyped,
      pathname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(facts, pathname); end

  Sorbet.sig {returns(::T.untyped)}
  def lang(); end

  Sorbet.sig {returns(::T.untyped)}
  def listable?(); end

  Sorbet.sig {returns(::T.untyped)}
  def media_type(); end

  Sorbet.sig {returns(::T.untyped)}
  def modify(); end

  Sorbet.sig {returns(::T.untyped)}
  def pathname(); end

  Sorbet.sig {returns(::T.untyped)}
  def perm(); end

  Sorbet.sig {returns(::T.untyped)}
  def purgeable?(); end

  Sorbet.sig {returns(::T.untyped)}
  def readable?(); end

  Sorbet.sig {returns(::T.untyped)}
  def renamable?(); end

  Sorbet.sig {returns(::T.untyped)}
  def size(); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end

  Sorbet.sig {returns(::T.untyped)}
  def unique(); end

  Sorbet.sig {returns(::T.untyped)}
  def writable?(); end
end

class Net::FTP::NullSocket
  Sorbet.sig {returns(::T.untyped)}
  def close(); end

  Sorbet.sig {returns(::T.untyped)}
  def closed?(); end

  Sorbet.sig do
    params(
      mid: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def method_missing(mid, *args); end

  Sorbet.sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(sec); end
end

class Net::FTPConnectionError < Net::FTPError
end

class Net::FTPError < StandardError
end

class Net::FTPPermError < Net::FTPError
end

class Net::FTPProtoError < Net::FTPError
end

class Net::FTPReplyError < Net::FTPError
end

class Net::FTPTempError < Net::FTPError
end

class Net::HTTP < Net::Protocol
  HAVE_ZLIB = ::T.let(nil, ::T.untyped)
  HTTPVersion = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS_ = ::T.let(nil, ::T.untyped)
  Revision = ::T.let(nil, ::T.untyped)
  SSL_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SSL_IVNAMES = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def active?(); end

  Sorbet.sig {returns(::T.untyped)}
  def address(); end

  Sorbet.sig {returns(::T.untyped)}
  def ca_file(); end

  Sorbet.sig do
    params(
      ca_file: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ca_file=(ca_file); end

  Sorbet.sig {returns(::T.untyped)}
  def ca_path(); end

  Sorbet.sig do
    params(
      ca_path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ca_path=(ca_path); end

  Sorbet.sig {returns(::T.untyped)}
  def cert(); end

  Sorbet.sig do
    params(
      cert: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cert=(cert); end

  Sorbet.sig {returns(::T.untyped)}
  def cert_store(); end

  Sorbet.sig do
    params(
      cert_store: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cert_store=(cert_store); end

  Sorbet.sig {returns(::T.untyped)}
  def ciphers(); end

  Sorbet.sig do
    params(
      ciphers: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ciphers=(ciphers); end

  Sorbet.sig {returns(::T.untyped)}
  def close_on_empty_response(); end

  Sorbet.sig do
    params(
      close_on_empty_response: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def close_on_empty_response=(close_on_empty_response); end

  Sorbet.sig {returns(::T.untyped)}
  def continue_timeout(); end

  Sorbet.sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def continue_timeout=(sec); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def copy(path, initheader=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delete(path, initheader=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def finish(); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      dest: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def get(path, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def get2(path, initheader=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def head(path, initheader=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def head2(path, initheader=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(address, port=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig {returns(::T.untyped)}
  def keep_alive_timeout(); end

  Sorbet.sig do
    params(
      keep_alive_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def keep_alive_timeout=(keep_alive_timeout); end

  Sorbet.sig {returns(::T.untyped)}
  def key(); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key=(key); end

  Sorbet.sig {returns(::T.untyped)}
  def local_host(); end

  Sorbet.sig do
    params(
      local_host: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local_host=(local_host); end

  Sorbet.sig {returns(::T.untyped)}
  def local_port(); end

  Sorbet.sig do
    params(
      local_port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local_port=(local_port); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lock(path, body, initheader=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mkcol(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def move(path, initheader=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def open_timeout(); end

  Sorbet.sig do
    params(
      open_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_timeout=(open_timeout); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def options(path, initheader=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      dest: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def patch(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  Sorbet.sig {returns(::T.untyped)}
  def peer_cert(); end

  Sorbet.sig {returns(::T.untyped)}
  def port(); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      dest: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def post(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def post2(path, data, initheader=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def propfind(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proppatch(path, body, initheader=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def proxy?(); end

  Sorbet.sig {returns(::T.untyped)}
  def proxy_address(); end

  Sorbet.sig do
    params(
      proxy_address: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_address=(proxy_address); end

  Sorbet.sig do
    params(
      proxy_from_env: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_from_env=(proxy_from_env); end

  Sorbet.sig {returns(::T.untyped)}
  def proxy_from_env?(); end

  Sorbet.sig {returns(::T.untyped)}
  def proxy_pass(); end

  Sorbet.sig do
    params(
      proxy_pass: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_pass=(proxy_pass); end

  Sorbet.sig {returns(::T.untyped)}
  def proxy_port(); end

  Sorbet.sig do
    params(
      proxy_port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_port=(proxy_port); end

  Sorbet.sig {returns(::T.untyped)}
  def proxy_uri(); end

  Sorbet.sig {returns(::T.untyped)}
  def proxy_user(); end

  Sorbet.sig do
    params(
      proxy_user: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_user=(proxy_user); end

  Sorbet.sig {returns(::T.untyped)}
  def proxyaddr(); end

  Sorbet.sig {returns(::T.untyped)}
  def proxyport(); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def put(path, data, initheader=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def put2(path, data, initheader=T.unsafe(nil), &block); end

  Sorbet.sig {returns(::T.untyped)}
  def read_timeout(); end

  Sorbet.sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(sec); end

  Sorbet.sig do
    params(
      req: ::T.untyped,
      body: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request(req, body=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_get(path, initheader=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_head(path, initheader=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_post(path, data, initheader=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_put(path, data, initheader=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      path: ::T.untyped,
      data: ::T.untyped,
      header: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_request(name, path, data=T.unsafe(nil), header=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      output: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_debug_output(output); end

  Sorbet.sig {returns(::T.untyped)}
  def ssl_timeout(); end

  Sorbet.sig do
    params(
      ssl_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_timeout=(ssl_timeout); end

  Sorbet.sig {returns(::T.untyped)}
  def ssl_version(); end

  Sorbet.sig do
    params(
      ssl_version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_version=(ssl_version); end

  Sorbet.sig {returns(::T.untyped)}
  def start(); end

  Sorbet.sig {returns(::T.untyped)}
  def started?(); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def trace(path, initheader=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      req: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def transport_request(req); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unlock(path, body, initheader=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      flag: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def use_ssl=(flag); end

  Sorbet.sig {returns(::T.untyped)}
  def use_ssl?(); end

  Sorbet.sig {returns(::T.untyped)}
  def verify_callback(); end

  Sorbet.sig do
    params(
      verify_callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_callback=(verify_callback); end

  Sorbet.sig {returns(::T.untyped)}
  def verify_depth(); end

  Sorbet.sig do
    params(
      verify_depth: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_depth=(verify_depth); end

  Sorbet.sig {returns(::T.untyped)}
  def verify_mode(); end

  Sorbet.sig do
    params(
      verify_mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_mode=(verify_mode); end

  Sorbet.sig do
    params(
      p_addr: ::T.untyped,
      p_port: ::T.untyped,
      p_user: ::T.untyped,
      p_pass: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.Proxy(p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default_port(); end

  Sorbet.sig do
    params(
      uri_or_host: ::T.untyped,
      path: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get(uri_or_host, path=T.unsafe(nil), port=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      uri_or_host: ::T.untyped,
      path: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get_print(uri_or_host, path=T.unsafe(nil), port=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      uri_or_host: ::T.untyped,
      path: ::T.untyped,
      port: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get_response(uri_or_host, path=T.unsafe(nil), port=T.unsafe(nil), &block); end

  Sorbet.sig {returns(::T.untyped)}
  def self.http_default_port(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.https_default_port(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.is_version_1_1?(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.is_version_1_2?(); end

  Sorbet.sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
      p_addr: ::T.untyped,
      p_port: ::T.untyped,
      p_user: ::T.untyped,
      p_pass: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(address, port=T.unsafe(nil), p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.newobj(*_); end

  Sorbet.sig do
    params(
      url: ::T.untyped,
      data: ::T.untyped,
      header: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.post(url, data, header=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      url: ::T.untyped,
      params: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.post_form(url, params); end

  Sorbet.sig {returns(::T.untyped)}
  def self.proxy_address(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.proxy_class?(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.proxy_pass(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.proxy_port(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.proxy_user(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.socket_type(); end

  Sorbet.sig do
    params(
      address: ::T.untyped,
      arg: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.start(address, *arg, &block); end

  Sorbet.sig {returns(::T.untyped)}
  def self.version_1_1?(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.version_1_2(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.version_1_2?(); end
end

class Net::HTTP::Copy < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Delete < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::DigestAuth
  include ::MonitorMixin
  VERSION = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      uri: ::T.untyped,
      www_authenticate: ::T.untyped,
      method: ::T.untyped,
      iis: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_header(uri, www_authenticate, method, iis=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      ignored: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(ignored=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def make_cnonce(); end

  Sorbet.sig {returns(::T.untyped)}
  def next_nonce(); end
end

class Net::HTTP::DigestAuth::Error < RuntimeError
end

class Net::HTTP::Get < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Head < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Lock < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Mkcol < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Move < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Options < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Patch < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Persistent
  EPOCH = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  RETRIED_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def ca_file(); end

  Sorbet.sig do
    params(
      file: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ca_file=(file); end

  Sorbet.sig do
    params(
      req: ::T.untyped,
      retried_on_ruby_2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def can_retry?(req, retried_on_ruby_2=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def cert(); end

  Sorbet.sig do
    params(
      certificate: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cert=(certificate); end

  Sorbet.sig {returns(::T.untyped)}
  def cert_store(); end

  Sorbet.sig do
    params(
      store: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cert_store=(store); end

  Sorbet.sig {returns(::T.untyped)}
  def certificate(); end

  Sorbet.sig do
    params(
      certificate: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def certificate=(certificate); end

  Sorbet.sig do
    params(
      generation: ::T.untyped,
      thread: ::T.untyped,
      generation_key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cleanup(generation, thread=T.unsafe(nil), generation_key=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      header: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connection_close?(header); end

  Sorbet.sig do
    params(
      uri: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connection_for(uri); end

  Sorbet.sig do
    params(
      header: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connection_keep_alive?(header); end

  Sorbet.sig {returns(::T.untyped)}
  def debug_output(); end

  Sorbet.sig do
    params(
      debug_output: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def debug_output=(debug_output); end

  Sorbet.sig do
    params(
      connection: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def error_message(connection); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def escape(str); end

  Sorbet.sig do
    params(
      connection: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def expired?(connection); end

  Sorbet.sig do
    params(
      connection: ::T.untyped,
      thread: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def finish(connection, thread=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def generation(); end

  Sorbet.sig {returns(::T.untyped)}
  def generation_key(); end

  Sorbet.sig {returns(::T.untyped)}
  def headers(); end

  Sorbet.sig {returns(::T.untyped)}
  def http_class(); end

  Sorbet.sig do
    params(
      uri: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def http_version(uri); end

  Sorbet.sig {returns(::T.untyped)}
  def http_versions(); end

  Sorbet.sig do
    params(
      req: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def idempotent?(req); end

  Sorbet.sig {returns(::T.untyped)}
  def idle_timeout(); end

  Sorbet.sig do
    params(
      idle_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def idle_timeout=(idle_timeout); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      proxy: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(name=T.unsafe(nil), proxy=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def keep_alive(); end

  Sorbet.sig do
    params(
      keep_alive: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def keep_alive=(keep_alive); end

  Sorbet.sig {returns(::T.untyped)}
  def key(); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key=(key); end

  Sorbet.sig {returns(::T.untyped)}
  def max_age(); end

  Sorbet.sig {returns(::T.untyped)}
  def max_requests(); end

  Sorbet.sig do
    params(
      max_requests: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def max_requests=(max_requests); end

  Sorbet.sig {returns(::T.untyped)}
  def name(); end

  Sorbet.sig {returns(::T.untyped)}
  def no_proxy(); end

  Sorbet.sig do
    params(
      uri: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def normalize_uri(uri); end

  Sorbet.sig {returns(::T.untyped)}
  def open_timeout(); end

  Sorbet.sig do
    params(
      open_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_timeout=(open_timeout); end

  Sorbet.sig {returns(::T.untyped)}
  def override_headers(); end

  Sorbet.sig do
    params(
      uri: ::T.untyped,
      requests: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def pipeline(uri, requests, &block); end

  Sorbet.sig {returns(::T.untyped)}
  def private_key(); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def private_key=(key); end

  Sorbet.sig do
    params(
      proxy: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy=(proxy); end

  Sorbet.sig do
    params(
      host: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_bypass?(host, port); end

  Sorbet.sig {returns(::T.untyped)}
  def proxy_from_env(); end

  Sorbet.sig {returns(::T.untyped)}
  def proxy_uri(); end

  Sorbet.sig {returns(::T.untyped)}
  def read_timeout(); end

  Sorbet.sig do
    params(
      read_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(read_timeout); end

  Sorbet.sig {returns(::T.untyped)}
  def reconnect(); end

  Sorbet.sig {returns(::T.untyped)}
  def reconnect_ssl(); end

  Sorbet.sig do
    params(
      uri: ::T.untyped,
      req: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request(uri, req=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      exception: ::T.untyped,
      req: ::T.untyped,
      connection: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_failed(exception, req, connection); end

  Sorbet.sig {returns(::T.untyped)}
  def request_key(); end

  Sorbet.sig do
    params(
      req_or_uri: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_setup(req_or_uri); end

  Sorbet.sig do
    params(
      connection: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def reset(connection); end

  Sorbet.sig {returns(::T.untyped)}
  def retry_change_requests(); end

  Sorbet.sig do
    params(
      retry_change_requests: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retry_change_requests=(retry_change_requests); end

  Sorbet.sig {returns(::T.untyped)}
  def reuse_ssl_sessions(); end

  Sorbet.sig do
    params(
      reuse_ssl_sessions: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def reuse_ssl_sessions=(reuse_ssl_sessions); end

  Sorbet.sig do
    params(
      thread: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def shutdown(thread=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def shutdown_in_all_threads(); end

  Sorbet.sig {returns(::T.untyped)}
  def socket_options(); end

  Sorbet.sig do
    params(
      connection: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl(connection); end

  Sorbet.sig do
    params(
      generation: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_cleanup(generation); end

  Sorbet.sig {returns(::T.untyped)}
  def ssl_generation(); end

  Sorbet.sig {returns(::T.untyped)}
  def ssl_generation_key(); end

  Sorbet.sig {returns(::T.untyped)}
  def ssl_version(); end

  Sorbet.sig do
    params(
      ssl_version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_version=(ssl_version); end

  Sorbet.sig do
    params(
      connection: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def start(connection); end

  Sorbet.sig {returns(::T.untyped)}
  def timeout_key(); end

  Sorbet.sig {returns(::T.untyped)}
  def verify_callback(); end

  Sorbet.sig do
    params(
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_callback=(callback); end

  Sorbet.sig {returns(::T.untyped)}
  def verify_mode(); end

  Sorbet.sig do
    params(
      verify_mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_mode=(verify_mode); end

  Sorbet.sig do
    params(
      uri: ::T.untyped,
      max: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.detect_idle_timeout(uri, max=T.unsafe(nil)); end
end

class Net::HTTP::Persistent::Error < StandardError
end

class Net::HTTP::Persistent::SSLReuse < Net::HTTP
  Sorbet.sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(address, port=T.unsafe(nil)); end
end

class Net::HTTP::Post < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Propfind < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Proppatch < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

module Net::HTTP::ProxyDelta
end

class Net::HTTP::Put < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Trace < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Unlock < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPAccepted < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPBadGateway < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPBadRequest < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPBadResponse < StandardError
end

class Net::HTTPClientError < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPConflict < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPContinue < Net::HTTPInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPCreated < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPError < Net::ProtocolError
  include ::Net::HTTPExceptions
end

module Net::HTTPExceptions
  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig do
    params(
      msg: ::T.untyped,
      res: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(msg, res); end

  Sorbet.sig {returns(::T.untyped)}
  def response(); end
end

class Net::HTTPExpectationFailed < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPFailedDependency < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPFatalError < Net::ProtoFatalError
  include ::Net::HTTPExceptions
end

class Net::HTTPForbidden < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPFound < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPGatewayTimeOut < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPGenericRequest
  include ::Net::HTTPHeader
  Sorbet.sig do
    params(
      key: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(key, val); end

  Sorbet.sig {returns(::T.untyped)}
  def body(); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def body=(str); end

  Sorbet.sig {returns(::T.untyped)}
  def body_exist?(); end

  Sorbet.sig {returns(::T.untyped)}
  def body_stream(); end

  Sorbet.sig do
    params(
      input: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def body_stream=(input); end

  Sorbet.sig {returns(::T.untyped)}
  def decode_content(); end

  Sorbet.sig do
    params(
      sock: ::T.untyped,
      ver: ::T.untyped,
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def exec(sock, ver, path); end

  Sorbet.sig do
    params(
      m: ::T.untyped,
      reqbody: ::T.untyped,
      resbody: ::T.untyped,
      uri_or_path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(m, reqbody, resbody, uri_or_path, initheader=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig {returns(::T.untyped)}
  def method(); end

  Sorbet.sig {returns(::T.untyped)}
  def path(); end

  Sorbet.sig {returns(::T.untyped)}
  def request_body_permitted?(); end

  Sorbet.sig {returns(::T.untyped)}
  def response_body_permitted?(); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_body_internal(str); end

  Sorbet.sig do
    params(
      addr: ::T.untyped,
      port: ::T.untyped,
      ssl: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def update_uri(addr, port, ssl); end

  Sorbet.sig {returns(::T.untyped)}
  def uri(); end
end

class Net::HTTPGenericRequest::Chunker
  Sorbet.sig {returns(::T.untyped)}
  def finish(); end

  Sorbet.sig do
    params(
      sock: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(sock); end

  Sorbet.sig do
    params(
      buf: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(buf); end
end

class Net::HTTPGone < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

module Net::HTTPHeader
  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](key); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(key, val); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_field(key, val); end

  Sorbet.sig do
    params(
      account: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def basic_auth(account, password); end

  Sorbet.sig {returns(::T.untyped)}
  def canonical_each(); end

  Sorbet.sig {returns(::T.untyped)}
  def chunked?(); end

  Sorbet.sig {returns(::T.untyped)}
  def connection_close?(); end

  Sorbet.sig {returns(::T.untyped)}
  def connection_keep_alive?(); end

  Sorbet.sig {returns(::T.untyped)}
  def content_length(); end

  Sorbet.sig do
    params(
      len: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_length=(len); end

  Sorbet.sig {returns(::T.untyped)}
  def content_range(); end

  Sorbet.sig {returns(::T.untyped)}
  def content_type(); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
      params: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_type=(type, params=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delete(key); end

  Sorbet.sig {returns(::T.untyped)}
  def each(); end

  Sorbet.sig {returns(::T.untyped)}
  def each_capitalized(); end

  Sorbet.sig {returns(::T.untyped)}
  def each_capitalized_name(); end

  Sorbet.sig {returns(::T.untyped)}
  def each_header(); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_key(&block); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_name(&block); end

  Sorbet.sig {returns(::T.untyped)}
  def each_value(); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
      args: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fetch(key, *args, &block); end

  Sorbet.sig do
    params(
      params: ::T.untyped,
      sep: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def form_data=(params, sep=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def get_fields(key); end

  Sorbet.sig do
    params(
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize_http_header(initheader); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key?(key); end

  Sorbet.sig {returns(::T.untyped)}
  def length(); end

  Sorbet.sig {returns(::T.untyped)}
  def main_type(); end

  Sorbet.sig do
    params(
      account: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_basic_auth(account, password); end

  Sorbet.sig {returns(::T.untyped)}
  def range(); end

  Sorbet.sig do
    params(
      r: ::T.untyped,
      e: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def range=(r, e=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def range_length(); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
      params: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_content_type(type, params=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      params: ::T.untyped,
      enctype: ::T.untyped,
      formopt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_form(params, enctype=T.unsafe(nil), formopt=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      params: ::T.untyped,
      sep: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_form_data(params, sep=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      r: ::T.untyped,
      e: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_range(r, e=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def size(); end

  Sorbet.sig {returns(::T.untyped)}
  def sub_type(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_hash(); end

  Sorbet.sig {returns(::T.untyped)}
  def type_params(); end
end

class Net::HTTPHeaderSyntaxError < StandardError
end

class Net::HTTPIMUsed < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPInformation < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPInsufficientStorage < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPInternalServerError < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPLengthRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPLocked < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPMethodNotAllowed < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPMovedPermanently < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPMultiStatus < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPMultipleChoices < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNetworkAuthenticationRequired < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNoContent < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNonAuthoritativeInformation < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNotAcceptable < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNotFound < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNotImplemented < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNotModified < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPOK < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPPartialContent < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPPaymentRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPPermanentRedirect < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPPreconditionFailed < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPPreconditionRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPProxyAuthenticationRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPRedirection < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPRequest < Net::HTTPGenericRequest
  Sorbet.sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(path, initheader=T.unsafe(nil)); end
end

class Net::HTTPRequestEntityTooLarge < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPRequestHeaderFieldsTooLarge < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPRequestTimeOut < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPRequestURITooLong < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPRequestedRangeNotSatisfiable < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPResetContent < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPResponse
  include ::Net::HTTPHeader
  CODE_CLASS_TO_OBJ = ::T.let(nil, ::T.untyped)
  CODE_TO_OBJ = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def body(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def body=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def code(); end

  Sorbet.sig {returns(::T.untyped)}
  def code_type(); end

  Sorbet.sig {returns(::T.untyped)}
  def decode_content(); end

  Sorbet.sig do
    params(
      decode_content: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def decode_content=(decode_content); end

  Sorbet.sig {returns(::T.untyped)}
  def entity(); end

  Sorbet.sig {returns(::T.untyped)}
  def error!(); end

  Sorbet.sig {returns(::T.untyped)}
  def error_type(); end

  Sorbet.sig {returns(::T.untyped)}
  def header(); end

  Sorbet.sig {returns(::T.untyped)}
  def http_version(); end

  Sorbet.sig do
    params(
      httpv: ::T.untyped,
      code: ::T.untyped,
      msg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(httpv, code, msg); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig {returns(::T.untyped)}
  def message(); end

  Sorbet.sig {returns(::T.untyped)}
  def msg(); end

  Sorbet.sig do
    params(
      dest: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_body(dest=T.unsafe(nil), &block); end

  Sorbet.sig {returns(::T.untyped)}
  def read_header(); end

  Sorbet.sig do
    params(
      sock: ::T.untyped,
      reqmethodallowbody: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def reading_body(sock, reqmethodallowbody); end

  Sorbet.sig {returns(::T.untyped)}
  def response(); end

  Sorbet.sig {returns(::T.untyped)}
  def uri(); end

  Sorbet.sig do
    params(
      uri: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uri=(uri); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.body_permitted?(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.exception_type(); end

  Sorbet.sig do
    params(
      sock: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.read_new(sock); end
end

class Net::HTTPResponse::Inflater
  Sorbet.sig {returns(::T.untyped)}
  def finish(); end

  Sorbet.sig do
    params(
      dest: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def inflate_adapter(dest); end

  Sorbet.sig do
    params(
      socket: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(socket); end

  Sorbet.sig do
    params(
      clen: ::T.untyped,
      dest: ::T.untyped,
      ignore_eof: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(clen, dest, ignore_eof=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      dest: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_all(dest); end
end

class Net::HTTPRetriableError < Net::ProtoRetriableError
  include ::Net::HTTPExceptions
end

class Net::HTTPSeeOther < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPServerError < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPServerException < Net::ProtoServerError
  include ::Net::HTTPExceptions
end

class Net::HTTPServiceUnavailable < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPSuccess < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPSwitchProtocol < Net::HTTPInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPTemporaryRedirect < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPTooManyRequests < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUnauthorized < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUnavailableForLegalReasons < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUnknownResponse < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUnprocessableEntity < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUnsupportedMediaType < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUpgradeRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUseProxy < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPVersionNotSupported < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::IMAP
  include ::OpenSSL::SSL
  include ::OpenSSL
  include ::MonitorMixin
  ANSWERED = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  DATE_MONTH = ::T.let(nil, ::T.untyped)
  DELETED = ::T.let(nil, ::T.untyped)
  DRAFT = ::T.let(nil, ::T.untyped)
  FLAGGED = ::T.let(nil, ::T.untyped)
  MARKED = ::T.let(nil, ::T.untyped)
  NOINFERIORS = ::T.let(nil, ::T.untyped)
  NOSELECT = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  RECENT = ::T.let(nil, ::T.untyped)
  SEEN = ::T.let(nil, ::T.untyped)
  SSL_PORT = ::T.let(nil, ::T.untyped)
  UNMARKED = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      handler: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_response_handler(handler=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
      message: ::T.untyped,
      flags: ::T.untyped,
      date_time: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def append(mailbox, message, flags=T.unsafe(nil), date_time=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      auth_type: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(auth_type, *args); end

  Sorbet.sig {returns(::T.untyped)}
  def capability(); end

  Sorbet.sig {returns(::T.untyped)}
  def check(); end

  Sorbet.sig {returns(::T.untyped)}
  def client_thread(); end

  Sorbet.sig do
    params(
      client_thread: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def client_thread=(client_thread); end

  Sorbet.sig {returns(::T.untyped)}
  def close(); end

  Sorbet.sig do
    params(
      set: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def copy(set, mailbox); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def create(mailbox); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delete(mailbox); end

  Sorbet.sig {returns(::T.untyped)}
  def disconnect(); end

  Sorbet.sig {returns(::T.untyped)}
  def disconnected?(); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def examine(mailbox); end

  Sorbet.sig {returns(::T.untyped)}
  def expunge(); end

  Sorbet.sig do
    params(
      set: ::T.untyped,
      attr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fetch(set, attr); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def getacl(mailbox); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def getquota(mailbox); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def getquotaroot(mailbox); end

  Sorbet.sig {returns(::T.untyped)}
  def greeting(); end

  Sorbet.sig do
    params(
      timeout: ::T.untyped,
      response_handler: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def idle(timeout=T.unsafe(nil), &response_handler); end

  Sorbet.sig {returns(::T.untyped)}
  def idle_done(); end

  Sorbet.sig do
    params(
      host: ::T.untyped,
      port_or_options: ::T.untyped,
      usessl: ::T.untyped,
      certs: ::T.untyped,
      verify: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(host, port_or_options=T.unsafe(nil), usessl=T.unsafe(nil), certs=T.unsafe(nil), verify=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      refname: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def list(refname, mailbox); end

  Sorbet.sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def login(user, password); end

  Sorbet.sig {returns(::T.untyped)}
  def logout(); end

  Sorbet.sig do
    params(
      refname: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lsub(refname, mailbox); end

  Sorbet.sig do
    params(
      set: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def move(set, mailbox); end

  Sorbet.sig {returns(::T.untyped)}
  def noop(); end

  Sorbet.sig do
    params(
      handler: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remove_response_handler(handler); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
      newname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(mailbox, newname); end

  Sorbet.sig {returns(::T.untyped)}
  def response_handlers(); end

  Sorbet.sig {returns(::T.untyped)}
  def responses(); end

  Sorbet.sig do
    params(
      keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def search(keys, charset=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def select(mailbox); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
      user: ::T.untyped,
      rights: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def setacl(mailbox, user, rights); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
      quota: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def setquota(mailbox, quota); end

  Sorbet.sig do
    params(
      sort_keys: ::T.untyped,
      search_keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sort(sort_keys, search_keys, charset); end

  Sorbet.sig do
    params(
      options: ::T.untyped,
      verify: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def starttls(options=T.unsafe(nil), verify=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
      attr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def status(mailbox, attr); end

  Sorbet.sig do
    params(
      set: ::T.untyped,
      attr: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def store(set, attr, flags); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subscribe(mailbox); end

  Sorbet.sig do
    params(
      algorithm: ::T.untyped,
      search_keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def thread(algorithm, search_keys, charset); end

  Sorbet.sig do
    params(
      set: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_copy(set, mailbox); end

  Sorbet.sig do
    params(
      set: ::T.untyped,
      attr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_fetch(set, attr); end

  Sorbet.sig do
    params(
      set: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_move(set, mailbox); end

  Sorbet.sig do
    params(
      keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_search(keys, charset=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      sort_keys: ::T.untyped,
      search_keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_sort(sort_keys, search_keys, charset); end

  Sorbet.sig do
    params(
      set: ::T.untyped,
      attr: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_store(set, attr, flags); end

  Sorbet.sig do
    params(
      algorithm: ::T.untyped,
      search_keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_thread(algorithm, search_keys, charset); end

  Sorbet.sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unsubscribe(mailbox); end

  Sorbet.sig do
    params(
      refname: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def xlist(refname, mailbox); end

  Sorbet.sig do
    params(
      auth_type: ::T.untyped,
      authenticator: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.add_authenticator(auth_type, authenticator); end

  Sorbet.sig {returns(::T.untyped)}
  def self.debug(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.debug=(val); end

  Sorbet.sig do
    params(
      s: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.decode_utf7(s); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default_imap_port(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default_imaps_port(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default_port(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default_ssl_port(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default_tls_port(); end

  Sorbet.sig do
    params(
      s: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.encode_utf7(s); end

  Sorbet.sig do
    params(
      time: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.format_date(time); end

  Sorbet.sig do
    params(
      time: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.format_datetime(time); end

  Sorbet.sig {returns(::T.untyped)}
  def self.max_flag_count(); end

  Sorbet.sig do
    params(
      count: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.max_flag_count=(count); end
end

class Net::IMAP::Address < Struct
  Sorbet.sig {returns(::T.untyped)}
  def host(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def host=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def mailbox(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def name(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def route(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def route=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::Atom
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  Sorbet.sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  Sorbet.sig {returns(::T.untyped)}
  def validate(); end
end

class Net::IMAP::BadResponseError < Net::IMAP::ResponseError
end

class Net::IMAP::BodyTypeAttachment
  Sorbet.sig {returns(::T.untyped)}
  def media_type(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def multipart?(); end

  Sorbet.sig {returns(::T.untyped)}
  def param(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def subtype(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

class Net::IMAP::BodyTypeBasic
  Sorbet.sig {returns(::T.untyped)}
  def content_id(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_id=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def description(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def description=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def disposition(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disposition=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def encoding(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def encoding=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def extension(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extension=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def language(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def language=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def md5(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def md5=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def media_subtype(); end

  Sorbet.sig {returns(::T.untyped)}
  def media_type(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def multipart?(); end

  Sorbet.sig {returns(::T.untyped)}
  def param(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def size(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def subtype(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

class Net::IMAP::BodyTypeExtension
  Sorbet.sig {returns(::T.untyped)}
  def content_id(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_id=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def description(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def description=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def encoding(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def encoding=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def media_type(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def multipart?(); end

  Sorbet.sig {returns(::T.untyped)}
  def params(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def params=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def size(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def subtype(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

class Net::IMAP::BodyTypeMessage
  Sorbet.sig {returns(::T.untyped)}
  def body(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def body=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def content_id(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_id=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def description(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def description=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def disposition(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disposition=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def encoding(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def encoding=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def envelope(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def envelope=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def extension(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extension=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def language(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def language=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def lines(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lines=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def md5(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def md5=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def media_subtype(); end

  Sorbet.sig {returns(::T.untyped)}
  def media_type(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def multipart?(); end

  Sorbet.sig {returns(::T.untyped)}
  def param(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def size(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def subtype(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

class Net::IMAP::BodyTypeMultipart
  Sorbet.sig {returns(::T.untyped)}
  def disposition(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disposition=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def extension(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extension=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def language(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def language=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def media_subtype(); end

  Sorbet.sig {returns(::T.untyped)}
  def media_type(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def multipart?(); end

  Sorbet.sig {returns(::T.untyped)}
  def param(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def parts(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parts=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def subtype(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

class Net::IMAP::BodyTypeText
  Sorbet.sig {returns(::T.untyped)}
  def content_id(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_id=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def description(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def description=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def disposition(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disposition=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def encoding(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def encoding=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def extension(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extension=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def language(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def language=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def lines(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lines=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def md5(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def md5=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def media_subtype(); end

  Sorbet.sig {returns(::T.untyped)}
  def media_type(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def multipart?(); end

  Sorbet.sig {returns(::T.untyped)}
  def param(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def size(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def subtype(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

class Net::IMAP::ByeResponseError < Net::IMAP::ResponseError
end

class Net::IMAP::ContentDisposition < Struct
  Sorbet.sig {returns(::T.untyped)}
  def dsp_type(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dsp_type=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def param(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::ContinuationRequest < Struct
  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def raw_data(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def raw_data=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::CramMD5Authenticator
  Sorbet.sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(user, password); end

  Sorbet.sig do
    params(
      challenge: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(challenge); end
end

class Net::IMAP::DataFormatError < Net::IMAP::Error
end

class Net::IMAP::DigestMD5Authenticator
  STAGE_ONE = ::T.let(nil, ::T.untyped)
  STAGE_TWO = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
      authname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(user, password, authname=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      challenge: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(challenge); end
end

class Net::IMAP::Envelope < Struct
  Sorbet.sig {returns(::T.untyped)}
  def bcc(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def bcc=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def cc(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cc=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def date(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def date=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def from(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def from=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def in_reply_to(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def in_reply_to=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def message_id(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def message_id=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def reply_to(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def reply_to=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def sender(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sender=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def subject(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subject=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def to(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def to=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::Error < StandardError
end

class Net::IMAP::FetchData < Struct
  Sorbet.sig {returns(::T.untyped)}
  def attr(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attr=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def seqno(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def seqno=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::FlagCountError < Net::IMAP::Error
end

class Net::IMAP::Literal
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  Sorbet.sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  Sorbet.sig {returns(::T.untyped)}
  def validate(); end
end

class Net::IMAP::LoginAuthenticator
  STATE_PASSWORD = ::T.let(nil, ::T.untyped)
  STATE_USER = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(user, password); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(data); end
end

class Net::IMAP::MailboxACLItem < Struct
  Sorbet.sig {returns(::T.untyped)}
  def mailbox(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def rights(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rights=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def user(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def user=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::MailboxList < Struct
  Sorbet.sig {returns(::T.untyped)}
  def attr(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attr=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def delim(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delim=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def name(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::MailboxQuota < Struct
  Sorbet.sig {returns(::T.untyped)}
  def mailbox(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def quota(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def quota=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def usage(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def usage=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::MailboxQuotaRoot < Struct
  Sorbet.sig {returns(::T.untyped)}
  def mailbox(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def quotaroots(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def quotaroots=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::MessageSet
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  Sorbet.sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  Sorbet.sig {returns(::T.untyped)}
  def validate(); end
end

class Net::IMAP::NoResponseError < Net::IMAP::ResponseError
end

module Net::IMAP::NumValidator
  Sorbet.sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ensure_number(num); end

  Sorbet.sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ensure_nz_number(num); end

  Sorbet.sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.valid_number?(num); end

  Sorbet.sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.valid_nz_number?(num); end
end

class Net::IMAP::PlainAuthenticator
  Sorbet.sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(user, password); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(data); end
end

class Net::IMAP::QuotedString
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  Sorbet.sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  Sorbet.sig {returns(::T.untyped)}
  def validate(); end
end

class Net::IMAP::RawData
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  Sorbet.sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  Sorbet.sig {returns(::T.untyped)}
  def validate(); end
end

class Net::IMAP::ResponseCode < Struct
  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def name(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::ResponseError < Net::IMAP::Error
  Sorbet.sig do
    params(
      response: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(response); end

  Sorbet.sig {returns(::T.untyped)}
  def response(); end

  Sorbet.sig do
    params(
      response: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def response=(response); end
end

class Net::IMAP::ResponseParseError < Net::IMAP::Error
end

class Net::IMAP::ResponseParser
  ADDRESS_REGEXP = ::T.let(nil, ::T.untyped)
  ATOM_TOKENS = ::T.let(nil, ::T.untyped)
  BEG_REGEXP = ::T.let(nil, ::T.untyped)
  CTEXT_REGEXP = ::T.let(nil, ::T.untyped)
  DATA_REGEXP = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CTEXT = ::T.let(nil, ::T.untyped)
  EXPR_DATA = ::T.let(nil, ::T.untyped)
  EXPR_RTEXT = ::T.let(nil, ::T.untyped)
  EXPR_TEXT = ::T.let(nil, ::T.untyped)
  FLAG_REGEXP = ::T.let(nil, ::T.untyped)
  RTEXT_REGEXP = ::T.let(nil, ::T.untyped)
  STRING_TOKENS = ::T.let(nil, ::T.untyped)
  TEXT_REGEXP = ::T.let(nil, ::T.untyped)
  T_ATOM = ::T.let(nil, ::T.untyped)
  T_BSLASH = ::T.let(nil, ::T.untyped)
  T_CRLF = ::T.let(nil, ::T.untyped)
  T_EOF = ::T.let(nil, ::T.untyped)
  T_LBRA = ::T.let(nil, ::T.untyped)
  T_LITERAL = ::T.let(nil, ::T.untyped)
  T_LPAR = ::T.let(nil, ::T.untyped)
  T_NIL = ::T.let(nil, ::T.untyped)
  T_NUMBER = ::T.let(nil, ::T.untyped)
  T_PERCENT = ::T.let(nil, ::T.untyped)
  T_PLUS = ::T.let(nil, ::T.untyped)
  T_QUOTED = ::T.let(nil, ::T.untyped)
  T_RBRA = ::T.let(nil, ::T.untyped)
  T_RPAR = ::T.let(nil, ::T.untyped)
  T_SPACE = ::T.let(nil, ::T.untyped)
  T_STAR = ::T.let(nil, ::T.untyped)
  T_TEXT = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def initialize(); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str); end
end

class Net::IMAP::ResponseParser::Token < Struct
  Sorbet.sig {returns(::T.untyped)}
  def symbol(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def symbol=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def value=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::ResponseText < Struct
  Sorbet.sig {returns(::T.untyped)}
  def code(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def code=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def text(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def text=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::StatusData < Struct
  Sorbet.sig {returns(::T.untyped)}
  def attr(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attr=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def mailbox(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::TaggedResponse < Struct
  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def name(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def raw_data(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def raw_data=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def tag(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def tag=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::ThreadMember < Struct
  Sorbet.sig {returns(::T.untyped)}
  def children(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def children=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def seqno(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def seqno=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::UntaggedResponse < Struct
  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def name(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def raw_data(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def raw_data=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::InternetMessageIO < Net::BufferedIO
  Sorbet.sig {returns(::T.untyped)}
  def each_list_item(); end

  Sorbet.sig {returns(::T.untyped)}
  def each_message_chunk(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  Sorbet.sig do
    params(
      src: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_message(src); end

  Sorbet.sig do
    params(
      src: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_message_0(src); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_message_by_block(&block); end
end

module Net::NTLM
  BLOB_SIGN = ::T.let(nil, ::T.untyped)
  DEFAULT_FLAGS = ::T.let(nil, ::T.untyped)
  FLAGS = ::T.let(nil, ::T.untyped)
  FLAG_KEYS = ::T.let(nil, ::T.untyped)
  LM_MAGIC = ::T.let(nil, ::T.untyped)
  MAX64 = ::T.let(nil, ::T.untyped)
  SSP_SIGN = ::T.let(nil, ::T.untyped)
  TIME_OFFSET = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      plain: ::T.untyped,
      keys: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.apply_des(plain, keys); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.gen_keys(str); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.is_ntlm_hash?(data); end

  Sorbet.sig do
    params(
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.lm_hash(password); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.lm_response(arg); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.lmv2_response(arg, opt=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ntlm2_session(arg, opt=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      password: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ntlm_hash(password, opt=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ntlm_response(arg); end

  Sorbet.sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
      target: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ntlmv2_hash(user, password, target, opt=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ntlmv2_response(arg, opt=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.pack_int64le(val); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.split7(str); end
end

class Net::NTLM::Blob < Net::NTLM::FieldSet
  Sorbet.sig {returns(::T.untyped)}
  def blob_signature(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def blob_signature=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def challenge(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def challenge=(val); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def reserved(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def reserved=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def target_info(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def target_info=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def timestamp(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def timestamp=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def unknown1(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unknown1=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def unknown2(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unknown2=(val); end
end

class Net::NTLM::ChannelBinding
  Sorbet.sig {returns(::T.untyped)}
  def acceptor_address_length(); end

  Sorbet.sig {returns(::T.untyped)}
  def acceptor_addrtype(); end

  Sorbet.sig {returns(::T.untyped)}
  def application_data(); end

  Sorbet.sig {returns(::T.untyped)}
  def channel(); end

  Sorbet.sig {returns(::T.untyped)}
  def channel_binding_token(); end

  Sorbet.sig {returns(::T.untyped)}
  def channel_hash(); end

  Sorbet.sig {returns(::T.untyped)}
  def gss_channel_bindings_struct(); end

  Sorbet.sig do
    params(
      outer_channel: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(outer_channel); end

  Sorbet.sig {returns(::T.untyped)}
  def initiator_address_length(); end

  Sorbet.sig {returns(::T.untyped)}
  def initiator_addtype(); end

  Sorbet.sig {returns(::T.untyped)}
  def unique_prefix(); end

  Sorbet.sig do
    params(
      outer_channel: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.create(outer_channel); end
end

class Net::NTLM::Client
  DEFAULT_FLAGS = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def domain(); end

  Sorbet.sig {returns(::T.untyped)}
  def flags(); end

  Sorbet.sig do
    params(
      resp: ::T.untyped,
      channel_binding: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def init_context(resp=T.unsafe(nil), channel_binding=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      username: ::T.untyped,
      password: ::T.untyped,
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(username, password, opts=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def password(); end

  Sorbet.sig {returns(::T.untyped)}
  def session(); end

  Sorbet.sig {returns(::T.untyped)}
  def session_key(); end

  Sorbet.sig {returns(::T.untyped)}
  def username(); end

  Sorbet.sig {returns(::T.untyped)}
  def workstation(); end
end

class Net::NTLM::Client::Session
  CLIENT_TO_SERVER_SEALING = ::T.let(nil, ::T.untyped)
  CLIENT_TO_SERVER_SIGNING = ::T.let(nil, ::T.untyped)
  MAX64 = ::T.let(nil, ::T.untyped)
  SERVER_TO_CLIENT_SEALING = ::T.let(nil, ::T.untyped)
  SERVER_TO_CLIENT_SIGNING = ::T.let(nil, ::T.untyped)
  TIME_OFFSET = ::T.let(nil, ::T.untyped)
  VERSION_MAGIC = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def authenticate!(); end

  Sorbet.sig {returns(::T.untyped)}
  def challenge_message(); end

  Sorbet.sig {returns(::T.untyped)}
  def channel_binding(); end

  Sorbet.sig {returns(::T.untyped)}
  def client(); end

  Sorbet.sig {returns(::T.untyped)}
  def exported_session_key(); end

  Sorbet.sig do
    params(
      client: ::T.untyped,
      challenge_message: ::T.untyped,
      channel_binding: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(client, challenge_message, channel_binding=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      message: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def seal_message(message); end

  Sorbet.sig do
    params(
      message: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign_message(message); end

  Sorbet.sig do
    params(
      emessage: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unseal_message(emessage); end

  Sorbet.sig do
    params(
      signature: ::T.untyped,
      message: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_signature(signature, message); end
end

class Net::NTLM::EncodeUtil
  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.decode_utf16le(str); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.encode_utf16le(str); end
end

class Net::NTLM::Field
  Sorbet.sig {returns(::T.untyped)}
  def active(); end

  Sorbet.sig do
    params(
      active: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def active=(active); end

  Sorbet.sig do
    params(
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(opts); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def serialize(); end

  Sorbet.sig {returns(::T.untyped)}
  def size(); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def value=(value); end
end

class Net::NTLM::FieldSet
  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](name); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(name, val); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disable(name); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable(name); end

  Sorbet.sig {returns(::T.untyped)}
  def has_disabled_fields?(); end

  Sorbet.sig {returns(::T.untyped)}
  def initialize(); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def serialize(); end

  Sorbet.sig {returns(::T.untyped)}
  def size(); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.int16LE(name, opts); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.int32LE(name, opts); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.int64LE(name, opts); end

  Sorbet.sig {returns(::T.untyped)}
  def self.names(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.opts(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.prototypes(); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.security_buffer(name, opts); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.string(name, opts); end

  Sorbet.sig {returns(::T.untyped)}
  def self.types(); end
end

class Net::NTLM::Int16LE < Net::NTLM::Field
  Sorbet.sig do
    params(
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(opt); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def serialize(); end
end

class Net::NTLM::Int32LE < Net::NTLM::Field
  Sorbet.sig do
    params(
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(opt); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def serialize(); end
end

class Net::NTLM::Int64LE < Net::NTLM::Field
  Sorbet.sig do
    params(
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(opt); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def serialize(); end
end

class Net::NTLM::InvalidTargetDataError < Net::NTLM::NtlmError
  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig do
    params(
      msg: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(msg, data); end
end

class Net::NTLM::Message < Net::NTLM::FieldSet
  Sorbet.sig {returns(::T.untyped)}
  def data_edge(); end

  Sorbet.sig {returns(::T.untyped)}
  def data_size(); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def decode64(str); end

  Sorbet.sig {returns(::T.untyped)}
  def deflag(); end

  Sorbet.sig {returns(::T.untyped)}
  def dump_flags(); end

  Sorbet.sig {returns(::T.untyped)}
  def encode64(); end

  Sorbet.sig do
    params(
      flag: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def has_flag?(flag); end

  Sorbet.sig {returns(::T.untyped)}
  def head_size(); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str); end

  Sorbet.sig {returns(::T.untyped)}
  def security_buffers(); end

  Sorbet.sig {returns(::T.untyped)}
  def serialize(); end

  Sorbet.sig do
    params(
      flag: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_flag(flag); end

  Sorbet.sig {returns(::T.untyped)}
  def size(); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.decode64(str); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(str); end
end

class Net::NTLM::Message::Type0 < Net::NTLM::Message
  Sorbet.sig {returns(::T.untyped)}
  def sign(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(val); end
end

class Net::NTLM::Message::Type1 < Net::NTLM::Message
  Sorbet.sig {returns(::T.untyped)}
  def domain(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def domain=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def flag(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def flag=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def os_version(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def os_version=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def sign(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def workstation(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def workstation=(val); end
end

class Net::NTLM::Message::Type2 < Net::NTLM::Message
  Sorbet.sig {returns(::T.untyped)}
  def challenge(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def challenge=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def context(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def context=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def flag(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def flag=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def os_version(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def os_version=(val); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def response(arg, opt=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def sign(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def target_info(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def target_info=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def target_name(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def target_name=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(val); end
end

class Net::NTLM::Message::Type3 < Net::NTLM::Message
  Sorbet.sig do
    params(
      server_challenge: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def blank_password?(server_challenge); end

  Sorbet.sig {returns(::T.untyped)}
  def domain(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def domain=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def flag(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def flag=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def lm_response(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lm_response=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def ntlm_response(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ntlm_response=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def ntlm_version(); end

  Sorbet.sig {returns(::T.untyped)}
  def os_version(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def os_version=(val); end

  Sorbet.sig do
    params(
      password: ::T.untyped,
      server_challenge: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def password?(password, server_challenge); end

  Sorbet.sig {returns(::T.untyped)}
  def session_key(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def session_key=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def sign(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def user(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def user=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def workstation(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def workstation=(val); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.create(arg, opt=T.unsafe(nil)); end
end

class Net::NTLM::NtlmError < StandardError
end

class Net::NTLM::SecurityBuffer < Net::NTLM::FieldSet
  Sorbet.sig {returns(::T.untyped)}
  def active(); end

  Sorbet.sig do
    params(
      active: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def active=(active); end

  Sorbet.sig {returns(::T.untyped)}
  def allocated(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def allocated=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def data_size(); end

  Sorbet.sig do
    params(
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(opts=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def length(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def length=(val); end

  Sorbet.sig {returns(::T.untyped)}
  def offset(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def offset=(val); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def serialize(); end

  Sorbet.sig {returns(::T.untyped)}
  def value(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def value=(val); end
end

class Net::NTLM::String < Net::NTLM::Field
  Sorbet.sig do
    params(
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(opts); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def serialize(); end

  Sorbet.sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def value=(val); end
end

class Net::NTLM::TargetInfo
  MSV_AV_CHANNEL_BINDINGS = ::T.let(nil, ::T.untyped)
  MSV_AV_DNS_COMPUTER_NAME = ::T.let(nil, ::T.untyped)
  MSV_AV_DNS_DOMAIN_NAME = ::T.let(nil, ::T.untyped)
  MSV_AV_DNS_TREE_NAME = ::T.let(nil, ::T.untyped)
  MSV_AV_EOL = ::T.let(nil, ::T.untyped)
  MSV_AV_FLAGS = ::T.let(nil, ::T.untyped)
  MSV_AV_NB_COMPUTER_NAME = ::T.let(nil, ::T.untyped)
  MSV_AV_NB_DOMAIN_NAME = ::T.let(nil, ::T.untyped)
  MSV_AV_SINGLE_HOST = ::T.let(nil, ::T.untyped)
  MSV_AV_TARGET_NAME = ::T.let(nil, ::T.untyped)
  MSV_AV_TIMESTAMP = ::T.let(nil, ::T.untyped)
  VALID_PAIR_ID = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def av_pairs(); end

  Sorbet.sig do
    params(
      av_pair_sequence: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(av_pair_sequence); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end
end

module Net::NetPrivate
end

class Net::OpenTimeout < Timeout::Error
end

class Net::ProtoAuthError < Net::ProtocolError
end

class Net::ProtoCommandError < Net::ProtocolError
end

class Net::ProtoFatalError < Net::ProtocolError
end

class Net::ProtoRetriableError < Net::ProtocolError
end

class Net::ProtoServerError < Net::ProtocolError
end

class Net::ProtoSyntaxError < Net::ProtocolError
end

class Net::ProtoUnknownError < Net::ProtocolError
end

class Net::Protocol
  Sorbet.sig do
    params(
      name: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.protocol_param(name, val); end
end

class Net::ProtocolError < StandardError
end

class Net::ReadAdapter
  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <<(str); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(block); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end
end

class Net::ReadTimeout < Timeout::Error
end

module Net::SFTP
  Sorbet.sig do
    params(
      host: ::T.untyped,
      user: ::T.untyped,
      options: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.start(host, user, options=T.unsafe(nil), &block); end
end

module Net::SFTP::Constants
end

module Net::SFTP::Constants::ACE
end

module Net::SFTP::Constants::ACE::Flag
  DIRECTORY_INHERIT = ::T.let(nil, ::T.untyped)
  FAILED_ACCESS = ::T.let(nil, ::T.untyped)
  FILE_INHERIT = ::T.let(nil, ::T.untyped)
  IDENTIFIER_GROUP = ::T.let(nil, ::T.untyped)
  INHERIT_ONLY = ::T.let(nil, ::T.untyped)
  NO_PROPAGATE_INHERIT = ::T.let(nil, ::T.untyped)
  SUCCESSFUL_ACCESS = ::T.let(nil, ::T.untyped)

end

module Net::SFTP::Constants::ACE::Mask
  ADD_FILE = ::T.let(nil, ::T.untyped)
  ADD_SUBDIRECTORY = ::T.let(nil, ::T.untyped)
  APPEND_DATA = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  DELETE_CHILD = ::T.let(nil, ::T.untyped)
  EXECUTE = ::T.let(nil, ::T.untyped)
  LIST_DIRECTORY = ::T.let(nil, ::T.untyped)
  READ_ACL = ::T.let(nil, ::T.untyped)
  READ_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  READ_DATA = ::T.let(nil, ::T.untyped)
  READ_NAMED_ATTRS = ::T.let(nil, ::T.untyped)
  SYNCHRONIZE = ::T.let(nil, ::T.untyped)
  WRITE_ACL = ::T.let(nil, ::T.untyped)
  WRITE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  WRITE_DATA = ::T.let(nil, ::T.untyped)
  WRITE_NAMED_ATTRS = ::T.let(nil, ::T.untyped)
  WRITE_OWNER = ::T.let(nil, ::T.untyped)

end

module Net::SFTP::Constants::ACE::Type
  ACCESS_ALLOWED = ::T.let(nil, ::T.untyped)
  ACCESS_DENIED = ::T.let(nil, ::T.untyped)
  SYSTEM_ALARM = ::T.let(nil, ::T.untyped)
  SYSTEM_AUDIT = ::T.let(nil, ::T.untyped)

end

module Net::SFTP::Constants::LockTypes
  ADVISORY = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  READ = ::T.let(nil, ::T.untyped)
  WRITE = ::T.let(nil, ::T.untyped)

end

module Net::SFTP::Constants::OpenFlags
end

module Net::SFTP::Constants::OpenFlags::FV1
  APPEND = ::T.let(nil, ::T.untyped)
  CREAT = ::T.let(nil, ::T.untyped)
  EXCL = ::T.let(nil, ::T.untyped)
  READ = ::T.let(nil, ::T.untyped)
  TRUNC = ::T.let(nil, ::T.untyped)
  WRITE = ::T.let(nil, ::T.untyped)

end

module Net::SFTP::Constants::OpenFlags::FV5
  APPEND_DATA = ::T.let(nil, ::T.untyped)
  APPEND_DATA_ATOMIC = ::T.let(nil, ::T.untyped)
  CREATE_NEW = ::T.let(nil, ::T.untyped)
  CREATE_TRUNCATE = ::T.let(nil, ::T.untyped)
  DELETE_LOCK = ::T.let(nil, ::T.untyped)
  OPEN_EXISTING = ::T.let(nil, ::T.untyped)
  OPEN_OR_CREATE = ::T.let(nil, ::T.untyped)
  READ_LOCK = ::T.let(nil, ::T.untyped)
  TEXT_MODE = ::T.let(nil, ::T.untyped)
  TRUNCATE_EXISTING = ::T.let(nil, ::T.untyped)
  WRITE_LOCK = ::T.let(nil, ::T.untyped)

end

module Net::SFTP::Constants::OpenFlags::FV6
  ACCESS_AUDIT_ALARM_INFO = ::T.let(nil, ::T.untyped)
  ACCESS_BACKUP = ::T.let(nil, ::T.untyped)
  ADVISORY_LOCK = ::T.let(nil, ::T.untyped)
  BACKUP_STREAM = ::T.let(nil, ::T.untyped)
  DELETE_ON_CLOSE = ::T.let(nil, ::T.untyped)
  NOFOLLOW = ::T.let(nil, ::T.untyped)
  OVERRIDE_OWNER = ::T.let(nil, ::T.untyped)

end

module Net::SFTP::Constants::PacketTypes
  FXP_ATTRS = ::T.let(nil, ::T.untyped)
  FXP_BLOCK = ::T.let(nil, ::T.untyped)
  FXP_CLOSE = ::T.let(nil, ::T.untyped)
  FXP_DATA = ::T.let(nil, ::T.untyped)
  FXP_EXTENDED = ::T.let(nil, ::T.untyped)
  FXP_EXTENDED_REPLY = ::T.let(nil, ::T.untyped)
  FXP_FSETSTAT = ::T.let(nil, ::T.untyped)
  FXP_FSTAT = ::T.let(nil, ::T.untyped)
  FXP_HANDLE = ::T.let(nil, ::T.untyped)
  FXP_INIT = ::T.let(nil, ::T.untyped)
  FXP_LINK = ::T.let(nil, ::T.untyped)
  FXP_LSTAT = ::T.let(nil, ::T.untyped)
  FXP_MKDIR = ::T.let(nil, ::T.untyped)
  FXP_NAME = ::T.let(nil, ::T.untyped)
  FXP_OPEN = ::T.let(nil, ::T.untyped)
  FXP_OPENDIR = ::T.let(nil, ::T.untyped)
  FXP_READ = ::T.let(nil, ::T.untyped)
  FXP_READDIR = ::T.let(nil, ::T.untyped)
  FXP_READLINK = ::T.let(nil, ::T.untyped)
  FXP_REALPATH = ::T.let(nil, ::T.untyped)
  FXP_REMOVE = ::T.let(nil, ::T.untyped)
  FXP_RENAME = ::T.let(nil, ::T.untyped)
  FXP_RMDIR = ::T.let(nil, ::T.untyped)
  FXP_SETSTAT = ::T.let(nil, ::T.untyped)
  FXP_STAT = ::T.let(nil, ::T.untyped)
  FXP_STATUS = ::T.let(nil, ::T.untyped)
  FXP_SYMLINK = ::T.let(nil, ::T.untyped)
  FXP_UNBLOCK = ::T.let(nil, ::T.untyped)
  FXP_VERSION = ::T.let(nil, ::T.untyped)
  FXP_WRITE = ::T.let(nil, ::T.untyped)

end

module Net::SFTP::Constants::RenameFlags
  ATOMIC = ::T.let(nil, ::T.untyped)
  NATIVE = ::T.let(nil, ::T.untyped)
  OVERWRITE = ::T.let(nil, ::T.untyped)

end

module Net::SFTP::Constants::StatusCodes
  FX_BAD_MESSAGE = ::T.let(nil, ::T.untyped)
  FX_CONNECTION_LOST = ::T.let(nil, ::T.untyped)
  FX_DIR_NOT_EMPTY = ::T.let(nil, ::T.untyped)
  FX_EOF = ::T.let(nil, ::T.untyped)
  FX_FAILURE = ::T.let(nil, ::T.untyped)
  FX_FILE_ALREADY_EXISTS = ::T.let(nil, ::T.untyped)
  FX_INVALID_FILENAME = ::T.let(nil, ::T.untyped)
  FX_INVALID_HANDLE = ::T.let(nil, ::T.untyped)
  FX_LINK_LOOP = ::T.let(nil, ::T.untyped)
  FX_LOCK_CONFlICT = ::T.let(nil, ::T.untyped)
  FX_NOT_A_DIRECTORY = ::T.let(nil, ::T.untyped)
  FX_NO_CONNECTION = ::T.let(nil, ::T.untyped)
  FX_NO_MEDIA = ::T.let(nil, ::T.untyped)
  FX_NO_SPACE_ON_FILESYSTEM = ::T.let(nil, ::T.untyped)
  FX_NO_SUCH_FILE = ::T.let(nil, ::T.untyped)
  FX_NO_SUCH_PATH = ::T.let(nil, ::T.untyped)
  FX_OK = ::T.let(nil, ::T.untyped)
  FX_OP_UNSUPPORTED = ::T.let(nil, ::T.untyped)
  FX_PERMISSION_DENIED = ::T.let(nil, ::T.untyped)
  FX_QUOTA_EXCEEDED = ::T.let(nil, ::T.untyped)
  FX_UNKNOWN_PRINCIPLE = ::T.let(nil, ::T.untyped)
  FX_WRITE_PROTECT = ::T.let(nil, ::T.untyped)

end

class Net::SFTP::Exception < RuntimeError
end

module Net::SFTP::Operations
end

class Net::SFTP::Operations::Dir
  Sorbet.sig do
    params(
      path: ::T.untyped,
      pattern: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](path, pattern); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def entries(path); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def foreach(path); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      pattern: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def glob(path, pattern, flags=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      sftp: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(sftp); end

  Sorbet.sig {returns(::T.untyped)}
  def sftp(); end
end

class Net::SFTP::Operations::Download
  include ::Net::SSH::Loggable
  DEFAULT_READ_SIZE = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](name); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(name, value); end

  Sorbet.sig {returns(::T.untyped)}
  def abort!(); end

  Sorbet.sig {returns(::T.untyped)}
  def active?(); end

  Sorbet.sig do
    params(
      sftp: ::T.untyped,
      local: ::T.untyped,
      remote: ::T.untyped,
      options: ::T.untyped,
      progress: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(sftp, local, remote, options=T.unsafe(nil), &progress); end

  Sorbet.sig {returns(::T.untyped)}
  def local(); end

  Sorbet.sig {returns(::T.untyped)}
  def options(); end

  Sorbet.sig {returns(::T.untyped)}
  def properties(); end

  Sorbet.sig {returns(::T.untyped)}
  def recursive?(); end

  Sorbet.sig {returns(::T.untyped)}
  def remote(); end

  Sorbet.sig {returns(::T.untyped)}
  def sftp(); end

  Sorbet.sig {returns(::T.untyped)}
  def wait(); end
end

class Net::SFTP::Operations::Download::Entry < Struct
  Sorbet.sig {returns(::T.untyped)}
  def directory(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def directory=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def handle(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def handle=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def local(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def offset(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def offset=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def remote(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remote=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def sink(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sink=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def size(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::SFTP::Operations::File
  Sorbet.sig {returns(::T.untyped)}
  def close(); end

  Sorbet.sig {returns(::T.untyped)}
  def eof?(); end

  Sorbet.sig do
    params(
      sep_string: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def gets(sep_string=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def handle(); end

  Sorbet.sig do
    params(
      sftp: ::T.untyped,
      handle: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(sftp, handle); end

  Sorbet.sig {returns(::T.untyped)}
  def pos(); end

  Sorbet.sig do
    params(
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def pos=(offset); end

  Sorbet.sig do
    params(
      items: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def print(*items); end

  Sorbet.sig do
    params(
      items: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def puts(*items); end

  Sorbet.sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(n=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      sep_string: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readline(sep_string=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def sftp(); end

  Sorbet.sig {returns(::T.untyped)}
  def stat(); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(data); end
end

class Net::SFTP::Operations::FileFactory
  Sorbet.sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def directory?(path); end

  Sorbet.sig do
    params(
      sftp: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(sftp); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      flags: ::T.untyped,
      mode: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open(name, flags=T.unsafe(nil), mode=T.unsafe(nil), &block); end

  Sorbet.sig {returns(::T.untyped)}
  def sftp(); end
end

class Net::SFTP::Operations::Upload
  include ::Net::SSH::Loggable
  DEFAULT_READ_SIZE = ::T.let(nil, ::T.untyped)
  RECURSIVE_READERS = ::T.let(nil, ::T.untyped)
  SINGLE_FILE_READERS = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](name); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(name, value); end

  Sorbet.sig {returns(::T.untyped)}
  def abort!(); end

  Sorbet.sig {returns(::T.untyped)}
  def active?(); end

  Sorbet.sig do
    params(
      sftp: ::T.untyped,
      local: ::T.untyped,
      remote: ::T.untyped,
      options: ::T.untyped,
      progress: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(sftp, local, remote, options=T.unsafe(nil), &progress); end

  Sorbet.sig {returns(::T.untyped)}
  def local(); end

  Sorbet.sig {returns(::T.untyped)}
  def options(); end

  Sorbet.sig {returns(::T.untyped)}
  def properties(); end

  Sorbet.sig {returns(::T.untyped)}
  def recursive?(); end

  Sorbet.sig {returns(::T.untyped)}
  def remote(); end

  Sorbet.sig {returns(::T.untyped)}
  def sftp(); end

  Sorbet.sig {returns(::T.untyped)}
  def wait(); end
end

class Net::SFTP::Operations::Upload::LiveFile < Struct
  Sorbet.sig {returns(::T.untyped)}
  def handle(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def handle=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def io(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def io=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def local(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def remote(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remote=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def size(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::SFTP::Packet < Net::SSH::Buffer
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end
end

module Net::SFTP::Protocol
  Sorbet.sig do
    params(
      session: ::T.untyped,
      version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load(session, version); end
end

class Net::SFTP::Protocol::Base
  include ::Net::SFTP::Constants::PacketTypes
  include ::Net::SFTP::Constants
  include ::Net::SSH::Loggable
  Sorbet.sig do
    params(
      session: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session); end

  Sorbet.sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(packet); end

  Sorbet.sig {returns(::T.untyped)}
  def session(); end
end

module Net::SFTP::Protocol::V01
end

class Net::SFTP::Protocol::V01::Attributes
  F_ACMODTIME = ::T.let(nil, ::T.untyped)
  F_EXTENDED = ::T.let(nil, ::T.untyped)
  F_PERMISSIONS = ::T.let(nil, ::T.untyped)
  F_SIZE = ::T.let(nil, ::T.untyped)
  F_UIDGID = ::T.let(nil, ::T.untyped)
  T_BLOCK_DEVICE = ::T.let(nil, ::T.untyped)
  T_CHAR_DEVICE = ::T.let(nil, ::T.untyped)
  T_DIRECTORY = ::T.let(nil, ::T.untyped)
  T_FIFO = ::T.let(nil, ::T.untyped)
  T_REGULAR = ::T.let(nil, ::T.untyped)
  T_SOCKET = ::T.let(nil, ::T.untyped)
  T_SPECIAL = ::T.let(nil, ::T.untyped)
  T_SYMLINK = ::T.let(nil, ::T.untyped)
  T_UNKNOWN = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def atime(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def atime=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def attributes(); end

  Sorbet.sig {returns(::T.untyped)}
  def directory?(); end

  Sorbet.sig {returns(::T.untyped)}
  def extended(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extended=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def file?(); end

  Sorbet.sig {returns(::T.untyped)}
  def gid(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def gid=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def group(); end

  Sorbet.sig do
    params(
      attributes: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(attributes=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def mtime(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mtime=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def owner(); end

  Sorbet.sig {returns(::T.untyped)}
  def permissions(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def permissions=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def size(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def symbolic_type(); end

  Sorbet.sig {returns(::T.untyped)}
  def symlink?(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end

  Sorbet.sig {returns(::T.untyped)}
  def uid(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid=(value); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.attr_accessor(name); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.attr_writer(name); end

  Sorbet.sig {returns(::T.untyped)}
  def self.elements(); end

  Sorbet.sig do
    params(
      buffer: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.from_buffer(buffer); end
end

class Net::SFTP::Protocol::V01::Base < Net::SFTP::Protocol::Base
  include ::Net::SFTP::Constants::OpenFlags
  Sorbet.sig {returns(::T.untyped)}
  def attribute_factory(); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      mask: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def block(handle, offset, length, mask); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def close(handle); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      attrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fsetstat(handle, attrs); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fstat(handle, flags=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def link(*args); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lstat(path, flags=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      attrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mkdir(path, attrs); end

  Sorbet.sig {returns(::T.untyped)}
  def name_factory(); end

  Sorbet.sig do
    params(
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def normalize_open_flags(flags); end

  Sorbet.sig do
    params(
      operation: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def not_implemented!(operation); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open(path, flags, options); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def opendir(path); end

  Sorbet.sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse_attrs_packet(packet); end

  Sorbet.sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse_data_packet(packet); end

  Sorbet.sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse_handle_packet(packet); end

  Sorbet.sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse_name_packet(packet); end

  Sorbet.sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse_status_packet(packet); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(handle, offset, length); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readdir(handle); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readlink(path); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def realpath(path); end

  Sorbet.sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remove(filename); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      new_name: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(name, new_name, flags=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rmdir(path); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      attrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def setstat(path, attrs); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def stat(path, flags=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      target: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def symlink(path, target); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unblock(handle, offset, length); end

  Sorbet.sig {returns(::T.untyped)}
  def version(); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(handle, offset, data); end
end

class Net::SFTP::Protocol::V01::Name
  Sorbet.sig {returns(::T.untyped)}
  def attributes(); end

  Sorbet.sig {returns(::T.untyped)}
  def directory?(); end

  Sorbet.sig {returns(::T.untyped)}
  def file?(); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      longname: ::T.untyped,
      attributes: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(name, longname, attributes); end

  Sorbet.sig {returns(::T.untyped)}
  def longname(); end

  Sorbet.sig {returns(::T.untyped)}
  def name(); end

  Sorbet.sig {returns(::T.untyped)}
  def symlink?(); end
end

module Net::SFTP::Protocol::V02
end

class Net::SFTP::Protocol::V02::Base < Net::SFTP::Protocol::V01::Base
  Sorbet.sig do
    params(
      name: ::T.untyped,
      new_name: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(name, new_name, flags=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def version(); end
end

module Net::SFTP::Protocol::V03
end

class Net::SFTP::Protocol::V03::Base < Net::SFTP::Protocol::V02::Base
  Sorbet.sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readlink(path); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      target: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def symlink(path, target); end

  Sorbet.sig {returns(::T.untyped)}
  def version(); end
end

module Net::SFTP::Protocol::V04
end

class Net::SFTP::Protocol::V04::Attributes < Net::SFTP::Protocol::V01::Attributes
  F_ACCESSTIME = ::T.let(nil, ::T.untyped)
  F_ACL = ::T.let(nil, ::T.untyped)
  F_CREATETIME = ::T.let(nil, ::T.untyped)
  F_MODIFYTIME = ::T.let(nil, ::T.untyped)
  F_OWNERGROUP = ::T.let(nil, ::T.untyped)
  F_SUBSECOND_TIMES = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def acl(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def acl=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def atime_nseconds(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def atime_nseconds=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def createtime(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def createtime=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def createtime_nseconds(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def createtime_nseconds=(value); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def group=(value); end

  Sorbet.sig do
    params(
      attributes: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(attributes=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def mtime_nseconds(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mtime_nseconds=(value); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def owner=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def self.elements(); end
end

class Net::SFTP::Protocol::V04::Attributes::ACL < Struct
  Sorbet.sig {returns(::T.untyped)}
  def flag(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def flag=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def mask(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mask=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def who(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def who=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::SFTP::Protocol::V04::Base < Net::SFTP::Protocol::V03::Base
  DEFAULT_FLAGS = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def attribute_factory(); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fstat(handle, flags=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lstat(path, flags=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def name_factory(); end

  Sorbet.sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse_name_packet(packet); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def stat(path, flags=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def version(); end
end

class Net::SFTP::Protocol::V04::Name
  Sorbet.sig {returns(::T.untyped)}
  def attributes(); end

  Sorbet.sig {returns(::T.untyped)}
  def directory?(); end

  Sorbet.sig {returns(::T.untyped)}
  def file?(); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      attributes: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(name, attributes); end

  Sorbet.sig {returns(::T.untyped)}
  def longname(); end

  Sorbet.sig {returns(::T.untyped)}
  def name(); end

  Sorbet.sig {returns(::T.untyped)}
  def symlink?(); end
end

module Net::SFTP::Protocol::V05
end

class Net::SFTP::Protocol::V05::Base < Net::SFTP::Protocol::V04::Base
  Sorbet.sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open(path, flags, options); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      new_name: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(name, new_name, flags=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def version(); end
end

module Net::SFTP::Protocol::V06
end

class Net::SFTP::Protocol::V06::Attributes < Net::SFTP::Protocol::V04::Attributes
  F_ALLOCATION_SIZE = ::T.let(nil, ::T.untyped)
  F_BITS = ::T.let(nil, ::T.untyped)
  F_CTIME = ::T.let(nil, ::T.untyped)
  F_LINK_COUNT = ::T.let(nil, ::T.untyped)
  F_MIME_TYPE = ::T.let(nil, ::T.untyped)
  F_TEXT_HINT = ::T.let(nil, ::T.untyped)
  F_UNTRANSLATED_NAME = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def allocation_size(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def allocation_size=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def attrib_bits(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attrib_bits=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def attrib_bits_valid(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attrib_bits_valid=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def ctime(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ctime=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def ctime_nseconds(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ctime_nseconds=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def link_count(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def link_count=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def mime_type(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mime_type=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def text_hint(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def text_hint=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def untranslated_name(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def untranslated_name=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def self.elements(); end
end

class Net::SFTP::Protocol::V06::Base < Net::SFTP::Protocol::V05::Base
  Sorbet.sig {returns(::T.untyped)}
  def attribute_factory(); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      mask: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def block(handle, offset, length, mask); end

  Sorbet.sig do
    params(
      new_link_path: ::T.untyped,
      existing_path: ::T.untyped,
      symlink: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def link(new_link_path, existing_path, symlink); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      target: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def symlink(path, target); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unblock(handle, offset, length); end

  Sorbet.sig {returns(::T.untyped)}
  def version(); end
end

class Net::SFTP::Request
  include ::Net::SFTP::Constants::PacketTypes
  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](key); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(key, value); end

  Sorbet.sig {returns(::T.untyped)}
  def callback(); end

  Sorbet.sig {returns(::T.untyped)}
  def id(); end

  Sorbet.sig do
    params(
      session: ::T.untyped,
      type: ::T.untyped,
      id: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session, type, id, &callback); end

  Sorbet.sig {returns(::T.untyped)}
  def pending?(); end

  Sorbet.sig {returns(::T.untyped)}
  def properties(); end

  Sorbet.sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def respond_to(packet); end

  Sorbet.sig {returns(::T.untyped)}
  def response(); end

  Sorbet.sig {returns(::T.untyped)}
  def session(); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end

  Sorbet.sig {returns(::T.untyped)}
  def wait(); end
end

class Net::SFTP::Response
  include ::Net::SFTP::Constants::StatusCodes
  MAP = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](key); end

  Sorbet.sig {returns(::T.untyped)}
  def code(); end

  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig {returns(::T.untyped)}
  def eof?(); end

  Sorbet.sig do
    params(
      request: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(request, data=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def message(); end

  Sorbet.sig {returns(::T.untyped)}
  def ok?(); end

  Sorbet.sig {returns(::T.untyped)}
  def request(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_str(); end
end

class Net::SFTP::Session
  include ::Net::SFTP::Constants::PacketTypes
  include ::Net::SSH::Loggable
  HIGHEST_PROTOCOL_VERSION_SUPPORTED = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      mask: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def block(handle, offset, length, mask, &callback); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      mask: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def block!(handle, offset, length, mask, &callback); end

  Sorbet.sig {returns(::T.untyped)}
  def channel(); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def close(handle, &callback); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def close!(handle, &callback); end

  Sorbet.sig {returns(::T.untyped)}
  def close_channel(); end

  Sorbet.sig {returns(::T.untyped)}
  def closed?(); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connect(&block); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connect!(&block); end

  Sorbet.sig {returns(::T.untyped)}
  def dir(); end

  Sorbet.sig do
    params(
      remote: ::T.untyped,
      local: ::T.untyped,
      options: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def download(remote, local, options=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      remote: ::T.untyped,
      local: ::T.untyped,
      options: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def download!(remote, local=T.unsafe(nil), options=T.unsafe(nil), &block); end

  Sorbet.sig {returns(::T.untyped)}
  def file(); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      attrs: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fsetstat(handle, attrs, &callback); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      attrs: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fsetstat!(handle, attrs, &callback); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fstat(handle, flags=T.unsafe(nil), &callback); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fstat!(handle, flags=T.unsafe(nil), &callback); end

  Sorbet.sig do
    params(
      session: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session, &block); end

  Sorbet.sig do
    params(
      new_link_path: ::T.untyped,
      existing_path: ::T.untyped,
      symlink: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def link(new_link_path, existing_path, symlink=T.unsafe(nil), &callback); end

  Sorbet.sig do
    params(
      new_link_path: ::T.untyped,
      existing_path: ::T.untyped,
      symlink: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def link!(new_link_path, existing_path, symlink=T.unsafe(nil), &callback); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def loop(&block); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lstat(path, flags=T.unsafe(nil), &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lstat!(path, flags=T.unsafe(nil), &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      attrs: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mkdir(path, attrs=T.unsafe(nil), &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      attrs: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mkdir!(path, attrs=T.unsafe(nil), &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      options: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open(path, flags=T.unsafe(nil), options=T.unsafe(nil), &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      options: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open!(path, flags=T.unsafe(nil), options=T.unsafe(nil), &callback); end

  Sorbet.sig {returns(::T.untyped)}
  def open?(); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def opendir(path, &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def opendir!(path, &callback); end

  Sorbet.sig {returns(::T.untyped)}
  def opening?(); end

  Sorbet.sig {returns(::T.untyped)}
  def pending_requests(); end

  Sorbet.sig {returns(::T.untyped)}
  def protocol(); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(handle, offset, length, &callback); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read!(handle, offset, length, &callback); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readdir(handle, &callback); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readdir!(handle, &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readlink(path, &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readlink!(path, &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def realpath(path, &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def realpath!(path, &callback); end

  Sorbet.sig do
    params(
      filename: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remove(filename, &callback); end

  Sorbet.sig do
    params(
      filename: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remove!(filename, &callback); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      new_name: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(name, new_name, flags=T.unsafe(nil), &callback); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      new_name: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename!(name, new_name, flags=T.unsafe(nil), &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rmdir(path, &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rmdir!(path, &callback); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_packet(type, *args); end

  Sorbet.sig {returns(::T.untyped)}
  def session(); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      attrs: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def setstat(path, attrs, &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      attrs: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def setstat!(path, attrs, &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def stat(path, flags=T.unsafe(nil), &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def stat!(path, flags=T.unsafe(nil), &callback); end

  Sorbet.sig {returns(::T.untyped)}
  def state(); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      target: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def symlink(path, target, &callback); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      target: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def symlink!(path, target, &callback); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unblock(handle, offset, length, &callback); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unblock!(handle, offset, length, &callback); end

  Sorbet.sig do
    params(
      local: ::T.untyped,
      remote: ::T.untyped,
      options: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def upload(local, remote=T.unsafe(nil), options=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      local: ::T.untyped,
      remote: ::T.untyped,
      options: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def upload!(local, remote=T.unsafe(nil), options=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      data: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(handle, offset, data, &callback); end

  Sorbet.sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      data: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write!(handle, offset, data, &callback); end
end

class Net::SFTP::StatusException < Net::SFTP::Exception
  Sorbet.sig {returns(::T.untyped)}
  def code(); end

  Sorbet.sig {returns(::T.untyped)}
  def description(); end

  Sorbet.sig do
    params(
      response: ::T.untyped,
      text: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(response, text=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def message(); end

  Sorbet.sig {returns(::T.untyped)}
  def response(); end

  Sorbet.sig {returns(::T.untyped)}
  def text(); end
end

class Net::SMTP < Net::Protocol
  CRAM_BUFSIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_AUTH_TYPE = ::T.let(nil, ::T.untyped)
  IMASK = ::T.let(nil, ::T.untyped)
  OMASK = ::T.let(nil, ::T.untyped)
  Revision = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def address(); end

  Sorbet.sig do
    params(
      user: ::T.untyped,
      secret: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_cram_md5(user, secret); end

  Sorbet.sig do
    params(
      user: ::T.untyped,
      secret: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_login(user, secret); end

  Sorbet.sig do
    params(
      user: ::T.untyped,
      secret: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_plain(user, secret); end

  Sorbet.sig do
    params(
      user: ::T.untyped,
      secret: ::T.untyped,
      authtype: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(user, secret, authtype=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def capable_auth_types(); end

  Sorbet.sig {returns(::T.untyped)}
  def capable_cram_md5_auth?(); end

  Sorbet.sig {returns(::T.untyped)}
  def capable_login_auth?(); end

  Sorbet.sig {returns(::T.untyped)}
  def capable_plain_auth?(); end

  Sorbet.sig {returns(::T.untyped)}
  def capable_starttls?(); end

  Sorbet.sig do
    params(
      msgstr: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data(msgstr=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def debug_output=(arg); end

  Sorbet.sig {returns(::T.untyped)}
  def disable_ssl(); end

  Sorbet.sig {returns(::T.untyped)}
  def disable_starttls(); end

  Sorbet.sig {returns(::T.untyped)}
  def disable_tls(); end

  Sorbet.sig do
    params(
      domain: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ehlo(domain); end

  Sorbet.sig do
    params(
      context: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable_ssl(context=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      context: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable_starttls(context=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      context: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable_starttls_auto(context=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      context: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable_tls(context=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def esmtp(); end

  Sorbet.sig do
    params(
      esmtp: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def esmtp=(esmtp); end

  Sorbet.sig {returns(::T.untyped)}
  def esmtp?(); end

  Sorbet.sig {returns(::T.untyped)}
  def finish(); end

  Sorbet.sig do
    params(
      domain: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def helo(domain); end

  Sorbet.sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(address, port=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig do
    params(
      from_addr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailfrom(from_addr); end

  Sorbet.sig do
    params(
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_message_stream(from_addr, *to_addrs, &block); end

  Sorbet.sig {returns(::T.untyped)}
  def open_timeout(); end

  Sorbet.sig do
    params(
      open_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_timeout=(open_timeout); end

  Sorbet.sig {returns(::T.untyped)}
  def port(); end

  Sorbet.sig {returns(::T.untyped)}
  def quit(); end

  Sorbet.sig do
    params(
      to_addr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rcptto(to_addr); end

  Sorbet.sig do
    params(
      to_addrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rcptto_list(to_addrs); end

  Sorbet.sig {returns(::T.untyped)}
  def read_timeout(); end

  Sorbet.sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(sec); end

  Sorbet.sig do
    params(
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ready(from_addr, *to_addrs, &block); end

  Sorbet.sig {returns(::T.untyped)}
  def rset(); end

  Sorbet.sig do
    params(
      msgstr: ::T.untyped,
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_mail(msgstr, from_addr, *to_addrs); end

  Sorbet.sig do
    params(
      msgstr: ::T.untyped,
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_message(msgstr, from_addr, *to_addrs); end

  Sorbet.sig do
    params(
      msgstr: ::T.untyped,
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sendmail(msgstr, from_addr, *to_addrs); end

  Sorbet.sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_debug_output(arg); end

  Sorbet.sig {returns(::T.untyped)}
  def ssl?(); end

  Sorbet.sig do
    params(
      helo: ::T.untyped,
      user: ::T.untyped,
      secret: ::T.untyped,
      authtype: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def start(helo=T.unsafe(nil), user=T.unsafe(nil), secret=T.unsafe(nil), authtype=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def started?(); end

  Sorbet.sig {returns(::T.untyped)}
  def starttls(); end

  Sorbet.sig {returns(::T.untyped)}
  def starttls?(); end

  Sorbet.sig {returns(::T.untyped)}
  def starttls_always?(); end

  Sorbet.sig {returns(::T.untyped)}
  def starttls_auto?(); end

  Sorbet.sig {returns(::T.untyped)}
  def tls?(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default_port(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default_ssl_context(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default_ssl_port(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default_submission_port(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.default_tls_port(); end

  Sorbet.sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
      helo: ::T.untyped,
      user: ::T.untyped,
      secret: ::T.untyped,
      authtype: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.start(address, port=T.unsafe(nil), helo=T.unsafe(nil), user=T.unsafe(nil), secret=T.unsafe(nil), authtype=T.unsafe(nil), &block); end
end

class Net::SMTP::Response
  Sorbet.sig {returns(::T.untyped)}
  def capabilities(); end

  Sorbet.sig {returns(::T.untyped)}
  def continue?(); end

  Sorbet.sig {returns(::T.untyped)}
  def cram_md5_challenge(); end

  Sorbet.sig {returns(::T.untyped)}
  def exception_class(); end

  Sorbet.sig do
    params(
      status: ::T.untyped,
      string: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(status, string); end

  Sorbet.sig {returns(::T.untyped)}
  def message(); end

  Sorbet.sig {returns(::T.untyped)}
  def status(); end

  Sorbet.sig {returns(::T.untyped)}
  def status_type_char(); end

  Sorbet.sig {returns(::T.untyped)}
  def string(); end

  Sorbet.sig {returns(::T.untyped)}
  def success?(); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(str); end
end

class Net::SMTPAuthenticationError < Net::ProtoAuthError
  include ::Net::SMTPError
end

module Net::SMTPError
end

class Net::SMTPFatalError < Net::ProtoFatalError
  include ::Net::SMTPError
end

class Net::SMTPServerBusy < Net::ProtoServerError
  include ::Net::SMTPError
end

class Net::SMTPSyntaxError < Net::ProtoSyntaxError
  include ::Net::SMTPError
end

class Net::SMTPUnknownError < Net::ProtoUnknownError
  include ::Net::SMTPError
end

class Net::SMTPUnsupportedCommand < Net::ProtocolError
  include ::Net::SMTPError
end

module Net::SSH
  VALID_OPTIONS = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      host: ::T.untyped,
      use_ssh_config: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.configuration_for(host, use_ssh_config=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      host: ::T.untyped,
      user: ::T.untyped,
      options: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.start(host, user, options=T.unsafe(nil), &block); end
end

module Net::SSH::Authentication
  PLATFORM = ::T.let(nil, ::T.untyped)

end

class Net::SSH::Authentication::Agent
  include ::Net::SSH::Loggable
  SSH2_AGENT_FAILURE = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_IDENTITIES_ANSWER = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_REQUEST_IDENTITIES = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_REQUEST_VERSION = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_SIGN_REQUEST = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_SIGN_RESPONSE = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_VERSION_RESPONSE = ::T.let(nil, ::T.untyped)
  SSH_AGENT_FAILURE = ::T.let(nil, ::T.untyped)
  SSH_AGENT_REQUEST_RSA_IDENTITIES = ::T.let(nil, ::T.untyped)
  SSH_AGENT_RSA_IDENTITIES_ANSWER1 = ::T.let(nil, ::T.untyped)
  SSH_AGENT_RSA_IDENTITIES_ANSWER2 = ::T.let(nil, ::T.untyped)
  SSH_COM_AGENT2_FAILURE = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def close(); end

  Sorbet.sig {returns(::T.untyped)}
  def connect!(); end

  Sorbet.sig {returns(::T.untyped)}
  def identities(); end

  Sorbet.sig do
    params(
      logger: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(logger=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def negotiate!(); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign(key, data); end

  Sorbet.sig {returns(::T.untyped)}
  def socket(); end

  Sorbet.sig do
    params(
      logger: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.connect(logger=T.unsafe(nil)); end
end

module Net::SSH::Authentication::Agent::Comment
  Sorbet.sig {returns(::T.untyped)}
  def comment(); end

  Sorbet.sig do
    params(
      comment: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def comment=(comment); end
end

class Net::SSH::Authentication::AgentError < Net::SSH::Exception
end

class Net::SSH::Authentication::AgentNotAvailable < Net::SSH::Authentication::AgentError
end

module Net::SSH::Authentication::Constants
  USERAUTH_BANNER = ::T.let(nil, ::T.untyped)
  USERAUTH_FAILURE = ::T.let(nil, ::T.untyped)
  USERAUTH_METHOD_RANGE = ::T.let(nil, ::T.untyped)
  USERAUTH_PASSWD_CHANGEREQ = ::T.let(nil, ::T.untyped)
  USERAUTH_PK_OK = ::T.let(nil, ::T.untyped)
  USERAUTH_REQUEST = ::T.let(nil, ::T.untyped)
  USERAUTH_SUCCESS = ::T.let(nil, ::T.untyped)

end

class Net::SSH::Authentication::DisallowedMethod < Net::SSH::Exception
end

class Net::SSH::Authentication::KeyManager
  include ::Net::SSH::Loggable
  Sorbet.sig do
    params(
      key_file: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add(key_file); end

  Sorbet.sig do
    params(
      key_data_: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_key_data(key_data_); end

  Sorbet.sig {returns(::T.untyped)}
  def agent(); end

  Sorbet.sig {returns(::T.untyped)}
  def clear!(); end

  Sorbet.sig {returns(::T.untyped)}
  def each_identity(); end

  Sorbet.sig {returns(::T.untyped)}
  def finish(); end

  Sorbet.sig do
    params(
      logger: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(logger, options=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def key_data(); end

  Sorbet.sig {returns(::T.untyped)}
  def key_files(); end

  Sorbet.sig {returns(::T.untyped)}
  def known_identities(); end

  Sorbet.sig {returns(::T.untyped)}
  def options(); end

  Sorbet.sig do
    params(
      identity: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign(identity, data); end

  Sorbet.sig do
    params(
      use_agent: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def use_agent=(use_agent); end

  Sorbet.sig {returns(::T.untyped)}
  def use_agent?(); end
end

class Net::SSH::Authentication::KeyManagerError < Net::SSH::Exception
end

module Net::SSH::Authentication::Methods
end

class Net::SSH::Authentication::Methods::Abstract
  include ::Net::SSH::Authentication::Constants
  include ::Net::SSH::Loggable
  Sorbet.sig do
    params(
      session: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session, options=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def key_manager(); end

  Sorbet.sig do
    params(
      msg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_message(msg); end

  Sorbet.sig {returns(::T.untyped)}
  def session(); end

  Sorbet.sig {returns(::T.untyped)}
  def session_id(); end

  Sorbet.sig do
    params(
      username: ::T.untyped,
      next_service: ::T.untyped,
      auth_method: ::T.untyped,
      others: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def userauth_request(username, next_service, auth_method, *others); end
end

class Net::SSH::Authentication::Methods::Hostbased < Net::SSH::Authentication::Methods::Abstract
  Sorbet.sig do
    params(
      next_service: ::T.untyped,
      username: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(next_service, username, password=T.unsafe(nil)); end
end

class Net::SSH::Authentication::Methods::KeyboardInteractive < Net::SSH::Authentication::Methods::Abstract
  include ::Net::SSH::PromptMethods::Highline
  USERAUTH_INFO_REQUEST = ::T.let(nil, ::T.untyped)
  USERAUTH_INFO_RESPONSE = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      next_service: ::T.untyped,
      username: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(next_service, username, password=T.unsafe(nil)); end
end

class Net::SSH::Authentication::Methods::Password < Net::SSH::Authentication::Methods::Abstract
  Sorbet.sig do
    params(
      next_service: ::T.untyped,
      username: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(next_service, username, password=T.unsafe(nil)); end
end

class Net::SSH::Authentication::Methods::Publickey < Net::SSH::Authentication::Methods::Abstract
  Sorbet.sig do
    params(
      next_service: ::T.untyped,
      username: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(next_service, username, password=T.unsafe(nil)); end
end

class Net::SSH::Authentication::Session
  include ::Net::SSH::Transport::Constants
  include ::Net::SSH::Authentication::Constants
  include ::Net::SSH::Loggable
  Sorbet.sig {returns(::T.untyped)}
  def allowed_auth_methods(); end

  Sorbet.sig {returns(::T.untyped)}
  def auth_methods(); end

  Sorbet.sig do
    params(
      next_service: ::T.untyped,
      username: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(next_service, username, password=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def expect_message(type); end

  Sorbet.sig do
    params(
      transport: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(transport, options=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def next_message(); end

  Sorbet.sig {returns(::T.untyped)}
  def options(); end

  Sorbet.sig {returns(::T.untyped)}
  def transport(); end
end

class Net::SSH::AuthenticationFailed < Net::SSH::Exception
end

class Net::SSH::Buffer
  Sorbet.sig do
    params(
      buffer: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ==(buffer); end

  Sorbet.sig do
    params(
      text: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def append(text); end

  Sorbet.sig {returns(::T.untyped)}
  def available(); end

  Sorbet.sig {returns(::T.untyped)}
  def clear!(); end

  Sorbet.sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def consume!(n=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def content(); end

  Sorbet.sig {returns(::T.untyped)}
  def empty?(); end

  Sorbet.sig {returns(::T.untyped)}
  def eof?(); end

  Sorbet.sig do
    params(
      content: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(content=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def length(); end

  Sorbet.sig {returns(::T.untyped)}
  def position(); end

  Sorbet.sig do
    params(
      position: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def position=(position); end

  Sorbet.sig do
    params(
      count: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(count=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      count: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read!(count=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def read_bignum(); end

  Sorbet.sig {returns(::T.untyped)}
  def read_bool(); end

  Sorbet.sig {returns(::T.untyped)}
  def read_buffer(); end

  Sorbet.sig {returns(::T.untyped)}
  def read_byte(); end

  Sorbet.sig {returns(::T.untyped)}
  def read_int64(); end

  Sorbet.sig {returns(::T.untyped)}
  def read_key(); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_keyblob(type); end

  Sorbet.sig {returns(::T.untyped)}
  def read_long(); end

  Sorbet.sig {returns(::T.untyped)}
  def read_string(); end

  Sorbet.sig do
    params(
      pattern: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_to(pattern); end

  Sorbet.sig {returns(::T.untyped)}
  def remainder_as_buffer(); end

  Sorbet.sig {returns(::T.untyped)}
  def reset!(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(*data); end

  Sorbet.sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_bignum(*n); end

  Sorbet.sig do
    params(
      b: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_bool(*b); end

  Sorbet.sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_byte(*n); end

  Sorbet.sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_int64(*n); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_key(*key); end

  Sorbet.sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_long(*n); end

  Sorbet.sig do
    params(
      text: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_string(*text); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.from(*args); end
end

module Net::SSH::BufferedIo
  include ::Net::SSH::Loggable
  Sorbet.sig {returns(::T.untyped)}
  def available(); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enqueue(data); end

  Sorbet.sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fill(n=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def pending_write?(); end

  Sorbet.sig do
    params(
      length: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_available(length=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def read_buffer(); end

  Sorbet.sig {returns(::T.untyped)}
  def send_pending(); end

  Sorbet.sig {returns(::T.untyped)}
  def wait_for_pending_sends(); end

  Sorbet.sig {returns(::T.untyped)}
  def write_buffer(); end

  Sorbet.sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.extended(object); end
end

class Net::SSH::ChannelOpenFailed < Net::SSH::Exception
  Sorbet.sig {returns(::T.untyped)}
  def code(); end

  Sorbet.sig do
    params(
      code: ::T.untyped,
      reason: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(code, reason); end

  Sorbet.sig {returns(::T.untyped)}
  def reason(); end
end

class Net::SSH::ChannelRequestFailed < Net::SSH::Exception
end

class Net::SSH::Compat
  Sorbet.sig do
    params(
      params: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.io_select(*params); end
end

class Net::SSH::Config
  Sorbet.sig {returns(::T.untyped)}
  def self.default_files(); end

  Sorbet.sig do
    params(
      host: ::T.untyped,
      files: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.for(host, files=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      path: ::T.untyped,
      host: ::T.untyped,
      settings: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load(path, host, settings=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      settings: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.translate(settings); end
end

module Net::SSH::Connection
end

class Net::SSH::Connection::Channel
  include ::Net::SSH::Connection::Constants
  include ::Net::SSH::Loggable
  VALID_PTY_OPTIONS = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](name); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(name, value); end

  Sorbet.sig {returns(::T.untyped)}
  def active?(); end

  Sorbet.sig {returns(::T.untyped)}
  def close(); end

  Sorbet.sig {returns(::T.untyped)}
  def closing?(); end

  Sorbet.sig {returns(::T.untyped)}
  def connection(); end

  Sorbet.sig {returns(::T.untyped)}
  def do_close(); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def do_data(data); end

  Sorbet.sig {returns(::T.untyped)}
  def do_eof(); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def do_extended_data(type, data); end

  Sorbet.sig {returns(::T.untyped)}
  def do_failure(); end

  Sorbet.sig do
    params(
      remote_id: ::T.untyped,
      max_window: ::T.untyped,
      max_packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def do_open_confirmation(remote_id, max_window, max_packet); end

  Sorbet.sig do
    params(
      reason_code: ::T.untyped,
      description: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def do_open_failed(reason_code, description); end

  Sorbet.sig do
    params(
      request: ::T.untyped,
      want_reply: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def do_request(request, want_reply, data); end

  Sorbet.sig {returns(::T.untyped)}
  def do_success(); end

  Sorbet.sig do
    params(
      bytes: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def do_window_adjust(bytes); end

  Sorbet.sig {returns(::T.untyped)}
  def enqueue_pending_output(); end

  Sorbet.sig do
    params(
      variable_name: ::T.untyped,
      variable_value: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def env(variable_name, variable_value, &block); end

  Sorbet.sig {returns(::T.untyped)}
  def eof!(); end

  Sorbet.sig {returns(::T.untyped)}
  def eof?(); end

  Sorbet.sig do
    params(
      command: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def exec(command, &block); end

  Sorbet.sig do
    params(
      connection: ::T.untyped,
      type: ::T.untyped,
      local_id: ::T.untyped,
      max_pkt_size: ::T.untyped,
      max_win_size: ::T.untyped,
      on_confirm_open: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(connection, type, local_id, max_pkt_size=T.unsafe(nil), max_win_size=T.unsafe(nil), &on_confirm_open); end

  Sorbet.sig {returns(::T.untyped)}
  def local_id(); end

  Sorbet.sig {returns(::T.untyped)}
  def local_maximum_packet_size(); end

  Sorbet.sig {returns(::T.untyped)}
  def local_maximum_window_size(); end

  Sorbet.sig {returns(::T.untyped)}
  def local_window_size(); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_close(&block); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_data(&block); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_eof(&block); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_extended_data(&block); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_open_failed(&block); end

  Sorbet.sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_process(&block); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_request(type, &block); end

  Sorbet.sig {returns(::T.untyped)}
  def output(); end

  Sorbet.sig {returns(::T.untyped)}
  def pending_requests(); end

  Sorbet.sig {returns(::T.untyped)}
  def process(); end

  Sorbet.sig {returns(::T.untyped)}
  def properties(); end

  Sorbet.sig {returns(::T.untyped)}
  def remote_id(); end

  Sorbet.sig {returns(::T.untyped)}
  def remote_maximum_packet_size(); end

  Sorbet.sig {returns(::T.untyped)}
  def remote_maximum_window_size(); end

  Sorbet.sig {returns(::T.untyped)}
  def remote_window_size(); end

  Sorbet.sig do
    params(
      opts: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_pty(opts=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      request_name: ::T.untyped,
      data: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_channel_request(request_name, *data, &callback); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(data); end

  Sorbet.sig do
    params(
      subsystem: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subsystem(subsystem, &block); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end

  Sorbet.sig {returns(::T.untyped)}
  def wait(); end
end

module Net::SSH::Connection::Constants
  CHANNEL_CLOSE = ::T.let(nil, ::T.untyped)
  CHANNEL_DATA = ::T.let(nil, ::T.untyped)
  CHANNEL_EOF = ::T.let(nil, ::T.untyped)
  CHANNEL_EXTENDED_DATA = ::T.let(nil, ::T.untyped)
  CHANNEL_FAILURE = ::T.let(nil, ::T.untyped)
  CHANNEL_OPEN = ::T.let(nil, ::T.untyped)
  CHANNEL_OPEN_CONFIRMATION = ::T.let(nil, ::T.untyped)
  CHANNEL_OPEN_FAILURE = ::T.let(nil, ::T.untyped)
  CHANNEL_REQUEST = ::T.let(nil, ::T.untyped)
  CHANNEL_SUCCESS = ::T.let(nil, ::T.untyped)
  CHANNEL_WINDOW_ADJUST = ::T.let(nil, ::T.untyped)
  GLOBAL_REQUEST = ::T.let(nil, ::T.untyped)
  REQUEST_FAILURE = ::T.let(nil, ::T.untyped)
  REQUEST_SUCCESS = ::T.let(nil, ::T.untyped)

end

class Net::SSH::Connection::Session
  include ::Net::SSH::Connection::Constants
  include ::Net::SSH::Loggable
  MAP = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](key); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(key, value); end

  Sorbet.sig do
    params(
      include_invisible: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def busy?(include_invisible=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def channel_open_handlers(); end

  Sorbet.sig {returns(::T.untyped)}
  def channels(); end

  Sorbet.sig {returns(::T.untyped)}
  def close(); end

  Sorbet.sig {returns(::T.untyped)}
  def closed?(); end

  Sorbet.sig do
    params(
      command: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def exec(command, &block); end

  Sorbet.sig do
    params(
      command: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def exec!(command, &block); end

  Sorbet.sig {returns(::T.untyped)}
  def forward(); end

  Sorbet.sig {returns(::T.untyped)}
  def host(); end

  Sorbet.sig do
    params(
      transport: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(transport, options=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      io: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def listen_to(io, &callback); end

  Sorbet.sig {returns(::T.untyped)}
  def listeners(); end

  Sorbet.sig do
    params(
      wait: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def loop(wait=T.unsafe(nil), &block); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_global_request(type, &block); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_open_channel(type, &block); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
      extra: ::T.untyped,
      on_confirm: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_channel(type=T.unsafe(nil), *extra, &on_confirm); end

  Sorbet.sig {returns(::T.untyped)}
  def options(); end

  Sorbet.sig {returns(::T.untyped)}
  def pending_requests(); end

  Sorbet.sig do
    params(
      readers: ::T.untyped,
      writers: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def postprocess(readers, writers); end

  Sorbet.sig {returns(::T.untyped)}
  def preprocess(); end

  Sorbet.sig do
    params(
      wait: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(wait=T.unsafe(nil), &block); end

  Sorbet.sig {returns(::T.untyped)}
  def properties(); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
      extra: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_global_request(type, *extra, &callback); end

  Sorbet.sig do
    params(
      message: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_message(message); end

  Sorbet.sig do
    params(
      wait: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sftp(wait=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def shutdown!(); end

  Sorbet.sig do
    params(
      io: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def stop_listening_to(io); end

  Sorbet.sig {returns(::T.untyped)}
  def transport(); end
end

class Net::SSH::Connection::Session::NilChannel
  Sorbet.sig do
    params(
      session: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session); end

  Sorbet.sig do
    params(
      sym: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def method_missing(sym, *args); end
end

module Net::SSH::Connection::Term
  CS7 = ::T.let(nil, ::T.untyped)
  CS8 = ::T.let(nil, ::T.untyped)
  ECHO = ::T.let(nil, ::T.untyped)
  ECHOCTL = ::T.let(nil, ::T.untyped)
  ECHOE = ::T.let(nil, ::T.untyped)
  ECHOK = ::T.let(nil, ::T.untyped)
  ECHOKE = ::T.let(nil, ::T.untyped)
  ECHONL = ::T.let(nil, ::T.untyped)
  ICANON = ::T.let(nil, ::T.untyped)
  ICRNL = ::T.let(nil, ::T.untyped)
  IEXTEN = ::T.let(nil, ::T.untyped)
  IGNCR = ::T.let(nil, ::T.untyped)
  IGNPAR = ::T.let(nil, ::T.untyped)
  IMAXBEL = ::T.let(nil, ::T.untyped)
  INCLR = ::T.let(nil, ::T.untyped)
  INPCK = ::T.let(nil, ::T.untyped)
  ISIG = ::T.let(nil, ::T.untyped)
  ISTRIP = ::T.let(nil, ::T.untyped)
  IUCLC = ::T.let(nil, ::T.untyped)
  IXANY = ::T.let(nil, ::T.untyped)
  IXOFF = ::T.let(nil, ::T.untyped)
  IXON = ::T.let(nil, ::T.untyped)
  NOFLSH = ::T.let(nil, ::T.untyped)
  OCRNL = ::T.let(nil, ::T.untyped)
  OLCUC = ::T.let(nil, ::T.untyped)
  ONLCR = ::T.let(nil, ::T.untyped)
  ONLRET = ::T.let(nil, ::T.untyped)
  ONOCR = ::T.let(nil, ::T.untyped)
  OPOST = ::T.let(nil, ::T.untyped)
  PARENB = ::T.let(nil, ::T.untyped)
  PARMRK = ::T.let(nil, ::T.untyped)
  PARODD = ::T.let(nil, ::T.untyped)
  PENDIN = ::T.let(nil, ::T.untyped)
  TOSTOP = ::T.let(nil, ::T.untyped)
  TTY_OP_ISPEED = ::T.let(nil, ::T.untyped)
  TTY_OP_OSPEED = ::T.let(nil, ::T.untyped)
  VDISCARD = ::T.let(nil, ::T.untyped)
  VDSUSP = ::T.let(nil, ::T.untyped)
  VEOF = ::T.let(nil, ::T.untyped)
  VEOL = ::T.let(nil, ::T.untyped)
  VEOL2 = ::T.let(nil, ::T.untyped)
  VERASE = ::T.let(nil, ::T.untyped)
  VFLUSH = ::T.let(nil, ::T.untyped)
  VINTR = ::T.let(nil, ::T.untyped)
  VKILL = ::T.let(nil, ::T.untyped)
  VLNEXT = ::T.let(nil, ::T.untyped)
  VQUIT = ::T.let(nil, ::T.untyped)
  VREPRINT = ::T.let(nil, ::T.untyped)
  VSTART = ::T.let(nil, ::T.untyped)
  VSTATUS = ::T.let(nil, ::T.untyped)
  VSTOP = ::T.let(nil, ::T.untyped)
  VSUSP = ::T.let(nil, ::T.untyped)
  VSWITCH = ::T.let(nil, ::T.untyped)
  VWERASE = ::T.let(nil, ::T.untyped)
  XCASE = ::T.let(nil, ::T.untyped)

end

class Net::SSH::ConnectionTimeout < Net::SSH::Exception
end

class Net::SSH::Disconnect < Net::SSH::Exception
end

class Net::SSH::Exception < RuntimeError
end

module Net::SSH::ForwardedBufferedIo
  Sorbet.sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fill(n=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def send_pending(); end
end

class Net::SSH::HostKeyError < Net::SSH::Exception
  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](key); end

  Sorbet.sig do
    params(
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def callback=(callback); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(data); end

  Sorbet.sig {returns(::T.untyped)}
  def fingerprint(); end

  Sorbet.sig {returns(::T.untyped)}
  def host(); end

  Sorbet.sig {returns(::T.untyped)}
  def ip(); end

  Sorbet.sig {returns(::T.untyped)}
  def key(); end

  Sorbet.sig {returns(::T.untyped)}
  def port(); end

  Sorbet.sig {returns(::T.untyped)}
  def remember_host!(); end
end

class Net::SSH::HostKeyMismatch < Net::SSH::HostKeyError
end

class Net::SSH::HostKeyUnknown < Net::SSH::HostKeyError
end

class Net::SSH::KeyFactory
  extend ::Net::SSH::PromptMethods::Highline
  MAP = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get(name); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
      passphrase: ::T.untyped,
      ask_passphrase: ::T.untyped,
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load_data_private_key(data, passphrase=T.unsafe(nil), ask_passphrase=T.unsafe(nil), filename=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load_data_public_key(data, filename=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      filename: ::T.untyped,
      passphrase: ::T.untyped,
      ask_passphrase: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load_private_key(filename, passphrase=T.unsafe(nil), ask_passphrase=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load_public_key(filename); end
end

class Net::SSH::KnownHosts
  SUPPORTED_TYPE = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      host: ::T.untyped,
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add(host, key); end

  Sorbet.sig do
    params(
      source: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(source); end

  Sorbet.sig do
    params(
      host: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def keys_for(host); end

  Sorbet.sig {returns(::T.untyped)}
  def source(); end

  Sorbet.sig do
    params(
      host: ::T.untyped,
      key: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.add(host, key, options=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      options: ::T.untyped,
      which: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hostfiles(options, which=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      host: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.search_for(host, options=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      files: ::T.untyped,
      host: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.search_in(files, host); end
end

module Net::SSH::Loggable
  Sorbet.sig {returns(::T.untyped)}
  def debug(); end

  Sorbet.sig {returns(::T.untyped)}
  def error(); end

  Sorbet.sig {returns(::T.untyped)}
  def fatal(); end

  Sorbet.sig {returns(::T.untyped)}
  def info(); end

  Sorbet.sig {returns(::T.untyped)}
  def logger(); end

  Sorbet.sig do
    params(
      logger: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def logger=(logger); end

  Sorbet.sig {returns(::T.untyped)}
  def lwarn(); end
end

class Net::SSH::Packet < Net::SSH::Buffer
  include ::Net::SSH::Transport::Constants
  include ::Net::SSH::Authentication::Constants
  include ::Net::SSH::Connection::Constants
  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](name); end

  Sorbet.sig do
    params(
      payload: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(payload); end

  Sorbet.sig {returns(::T.untyped)}
  def type(); end

  Sorbet.sig do
    params(
      type: ::T.untyped,
      pairs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.register(type, *pairs); end
end

module Net::SSH::PromptMethods
end

module Net::SSH::PromptMethods::Clear
  Sorbet.sig do
    params(
      prompt: ::T.untyped,
      echo: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def prompt(prompt, echo=T.unsafe(nil)); end
end

module Net::SSH::PromptMethods::Highline
  Sorbet.sig do
    params(
      prompt: ::T.untyped,
      echo: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def prompt(prompt, echo=T.unsafe(nil)); end
end

module Net::SSH::PromptMethods::Termios
  Sorbet.sig do
    params(
      prompt: ::T.untyped,
      echo: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def prompt(prompt, echo=T.unsafe(nil)); end
end

module Net::SSH::Proxy
end

class Net::SSH::Proxy::ConnectError < Net::SSH::Proxy::Error
end

class Net::SSH::Proxy::Error < Net::SSH::Exception
end

class Net::SSH::Proxy::HTTP
  Sorbet.sig do
    params(
      proxy_host: ::T.untyped,
      proxy_port: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(proxy_host, proxy_port=T.unsafe(nil), options=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      host: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open(host, port); end

  Sorbet.sig {returns(::T.untyped)}
  def options(); end

  Sorbet.sig {returns(::T.untyped)}
  def proxy_host(); end

  Sorbet.sig {returns(::T.untyped)}
  def proxy_port(); end
end

class Net::SSH::Proxy::UnauthorizedError < Net::SSH::Proxy::Error
end

module Net::SSH::Service
end

class Net::SSH::Service::Forward
  include ::Net::SSH::Loggable
  Sorbet.sig {returns(::T.untyped)}
  def active_locals(); end

  Sorbet.sig {returns(::T.untyped)}
  def active_remotes(); end

  Sorbet.sig do
    params(
      channel: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def agent(channel); end

  Sorbet.sig do
    params(
      port: ::T.untyped,
      bind_address: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cancel_local(port, bind_address=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      port: ::T.untyped,
      host: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cancel_remote(port, host=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      session: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local(*args); end

  Sorbet.sig do
    params(
      port: ::T.untyped,
      host: ::T.untyped,
      remote_port: ::T.untyped,
      remote_host: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remote(port, host, remote_port, remote_host=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      port: ::T.untyped,
      host: ::T.untyped,
      remote_port: ::T.untyped,
      remote_host: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remote_to(port, host, remote_port, remote_host=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def session(); end
end

class Net::SSH::Service::Forward::Remote < Struct
  Sorbet.sig {returns(::T.untyped)}
  def host(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def host=(_); end

  Sorbet.sig {returns(::T.untyped)}
  def port(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def port=(_); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  Sorbet.sig {returns(::T.untyped)}
  def self.members(); end

  Sorbet.sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

module Net::SSH::Transport
end

class Net::SSH::Transport::Algorithms
  include ::Net::SSH::Transport::Constants
  include ::Net::SSH::Loggable
  ALGORITHMS = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](key); end

  Sorbet.sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def accept_kexinit(packet); end

  Sorbet.sig {returns(::T.untyped)}
  def algorithms(); end

  Sorbet.sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def allow?(packet); end

  Sorbet.sig {returns(::T.untyped)}
  def compression_client(); end

  Sorbet.sig {returns(::T.untyped)}
  def compression_server(); end

  Sorbet.sig {returns(::T.untyped)}
  def encryption_client(); end

  Sorbet.sig {returns(::T.untyped)}
  def encryption_server(); end

  Sorbet.sig {returns(::T.untyped)}
  def hmac_client(); end

  Sorbet.sig {returns(::T.untyped)}
  def hmac_server(); end

  Sorbet.sig {returns(::T.untyped)}
  def host_key(); end

  Sorbet.sig do
    params(
      session: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session, options=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def initialized?(); end

  Sorbet.sig {returns(::T.untyped)}
  def kex(); end

  Sorbet.sig {returns(::T.untyped)}
  def language_client(); end

  Sorbet.sig {returns(::T.untyped)}
  def language_server(); end

  Sorbet.sig {returns(::T.untyped)}
  def options(); end

  Sorbet.sig {returns(::T.untyped)}
  def pending?(); end

  Sorbet.sig {returns(::T.untyped)}
  def rekey!(); end

  Sorbet.sig {returns(::T.untyped)}
  def session(); end

  Sorbet.sig {returns(::T.untyped)}
  def session_id(); end

  Sorbet.sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.allowed_packet?(packet); end
end

module Net::SSH::Transport::CTR
  Sorbet.sig do
    params(
      orig: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.extended(orig); end
end

class Net::SSH::Transport::CipherFactory
  KEY_LEN_OVERRIDE = ::T.let(nil, ::T.untyped)
  SSH_TO_OSSL = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      name: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get(name, options=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get_lengths(name); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.supported?(name); end
end

module Net::SSH::Transport::Constants
  DEBUG = ::T.let(nil, ::T.untyped)
  DISCONNECT = ::T.let(nil, ::T.untyped)
  IGNORE = ::T.let(nil, ::T.untyped)
  KEXDH_INIT = ::T.let(nil, ::T.untyped)
  KEXDH_REPLY = ::T.let(nil, ::T.untyped)
  KEXECDH_INIT = ::T.let(nil, ::T.untyped)
  KEXECDH_REPLY = ::T.let(nil, ::T.untyped)
  KEXINIT = ::T.let(nil, ::T.untyped)
  NEWKEYS = ::T.let(nil, ::T.untyped)
  SERVICE_ACCEPT = ::T.let(nil, ::T.untyped)
  SERVICE_REQUEST = ::T.let(nil, ::T.untyped)
  UNIMPLEMENTED = ::T.let(nil, ::T.untyped)

end

module Net::SSH::Transport::HMAC
  MAP = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      name: ::T.untyped,
      key: ::T.untyped,
      parameters: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get(name, key=T.unsafe(nil), parameters=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.key_length(name); end
end

class Net::SSH::Transport::HMAC::Abstract
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def digest(data); end

  Sorbet.sig {returns(::T.untyped)}
  def digest_class(); end

  Sorbet.sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(key=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def key(); end

  Sorbet.sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key=(value); end

  Sorbet.sig {returns(::T.untyped)}
  def key_length(); end

  Sorbet.sig {returns(::T.untyped)}
  def mac_length(); end

  Sorbet.sig do
    params(
      v: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest_class(*v); end

  Sorbet.sig do
    params(
      v: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.key_length(*v); end

  Sorbet.sig do
    params(
      v: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.mac_length(*v); end
end

class Net::SSH::Transport::HMAC::MD5 < Net::SSH::Transport::HMAC::Abstract
end

class Net::SSH::Transport::HMAC::MD5_96 < Net::SSH::Transport::HMAC::MD5
end

class Net::SSH::Transport::HMAC::None < Net::SSH::Transport::HMAC::Abstract
  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def digest(data); end
end

class Net::SSH::Transport::HMAC::RIPEMD160 < Net::SSH::Transport::HMAC::Abstract
end

class Net::SSH::Transport::HMAC::SHA1 < Net::SSH::Transport::HMAC::Abstract
end

class Net::SSH::Transport::HMAC::SHA1_96 < Net::SSH::Transport::HMAC::SHA1
end

class Net::SSH::Transport::HMAC::SHA2_256 < Net::SSH::Transport::HMAC::Abstract
end

class Net::SSH::Transport::HMAC::SHA2_256_96 < Net::SSH::Transport::HMAC::SHA2_256
end

class Net::SSH::Transport::HMAC::SHA2_512 < Net::SSH::Transport::HMAC::Abstract
end

class Net::SSH::Transport::HMAC::SHA2_512_96 < Net::SSH::Transport::HMAC::SHA2_512
end

class Net::SSH::Transport::IdentityCipher
  Sorbet.sig {returns(::T.untyped)}
  def self.block_size(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.decrypt(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.encrypt(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.final(); end

  Sorbet.sig do
    params(
      v: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.iv=(v); end

  Sorbet.sig {returns(::T.untyped)}
  def self.iv_len(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.name(); end

  Sorbet.sig {returns(::T.untyped)}
  def self.reset(); end

  Sorbet.sig do
    params(
      text: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.update(text); end
end

module Net::SSH::Transport::Kex
  MAP = ::T.let(nil, ::T.untyped)

end

class Net::SSH::Transport::Kex::DiffieHellmanGroup14SHA1 < Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1
  G = ::T.let(nil, ::T.untyped)
  P_r = ::T.let(nil, ::T.untyped)
  P_s = ::T.let(nil, ::T.untyped)

end

class Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1
  include ::Net::SSH::Transport::Constants
  include ::Net::SSH::Loggable
  G = ::T.let(nil, ::T.untyped)
  P_r = ::T.let(nil, ::T.untyped)
  P_s = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def algorithms(); end

  Sorbet.sig {returns(::T.untyped)}
  def connection(); end

  Sorbet.sig {returns(::T.untyped)}
  def data(); end

  Sorbet.sig {returns(::T.untyped)}
  def dh(); end

  Sorbet.sig {returns(::T.untyped)}
  def digester(); end

  Sorbet.sig {returns(::T.untyped)}
  def exchange_keys(); end

  Sorbet.sig {returns(::T.untyped)}
  def g(); end

  Sorbet.sig do
    params(
      algorithms: ::T.untyped,
      connection: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(algorithms, connection, data); end

  Sorbet.sig {returns(::T.untyped)}
  def p(); end
end

class Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA1 < Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1
  KEXDH_GEX_GROUP = ::T.let(nil, ::T.untyped)
  KEXDH_GEX_INIT = ::T.let(nil, ::T.untyped)
  KEXDH_GEX_REPLY = ::T.let(nil, ::T.untyped)
  KEXDH_GEX_REQUEST = ::T.let(nil, ::T.untyped)
  MAXIMUM_BITS = ::T.let(nil, ::T.untyped)
  MINIMUM_BITS = ::T.let(nil, ::T.untyped)

end

class Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA256 < Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA1
  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*args); end
end

class Net::SSH::Transport::Kex::EcdhSHA2NistP256 < Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1
  Sorbet.sig {returns(::T.untyped)}
  def curve_name(); end

  Sorbet.sig {returns(::T.untyped)}
  def digester(); end

  Sorbet.sig {returns(::T.untyped)}
  def ecdh(); end

  Sorbet.sig do
    params(
      algorithms: ::T.untyped,
      connection: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(algorithms, connection, data); end
end

class Net::SSH::Transport::Kex::EcdhSHA2NistP384 < Net::SSH::Transport::Kex::EcdhSHA2NistP256
  Sorbet.sig {returns(::T.untyped)}
  def curve_name(); end

  Sorbet.sig {returns(::T.untyped)}
  def digester(); end
end

class Net::SSH::Transport::Kex::EcdhSHA2NistP521 < Net::SSH::Transport::Kex::EcdhSHA2NistP256
  Sorbet.sig {returns(::T.untyped)}
  def curve_name(); end

  Sorbet.sig {returns(::T.untyped)}
  def digester(); end
end

module Net::SSH::Transport::KeyExpander
  Sorbet.sig do
    params(
      bytes: ::T.untyped,
      start: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.expand_key(bytes, start, options=T.unsafe(nil)); end
end

module Net::SSH::Transport::PacketStream
  include ::Net::SSH::BufferedIo
  include ::Net::SSH::Loggable
  Sorbet.sig {returns(::T.untyped)}
  def available_for_read?(); end

  Sorbet.sig {returns(::T.untyped)}
  def cleanup(); end

  Sorbet.sig {returns(::T.untyped)}
  def client(); end

  Sorbet.sig {returns(::T.untyped)}
  def client_name(); end

  Sorbet.sig do
    params(
      payload: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enqueue_packet(payload); end

  Sorbet.sig {returns(::T.untyped)}
  def hints(); end

  Sorbet.sig {returns(::T.untyped)}
  def if_needs_rekey?(); end

  Sorbet.sig {returns(::T.untyped)}
  def initialize_ssh(); end

  Sorbet.sig do
    params(
      mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def next_packet(mode=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def peer_ip(); end

  Sorbet.sig {returns(::T.untyped)}
  def poll_next_packet(); end

  Sorbet.sig do
    params(
      payload: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_packet(payload); end

  Sorbet.sig {returns(::T.untyped)}
  def server(); end

  Sorbet.sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.extended(object); end
end

class Net::SSH::Transport::ServerVersion
  include ::Net::SSH::Loggable
  PROTO_VERSION = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def header(); end

  Sorbet.sig do
    params(
      socket: ::T.untyped,
      logger: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(socket, logger); end

  Sorbet.sig {returns(::T.untyped)}
  def version(); end
end

class Net::SSH::Transport::Session
  include ::Net::SSH::Transport::Constants
  include ::Net::SSH::Loggable
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)

  Sorbet.sig {returns(::T.untyped)}
  def algorithms(); end

  Sorbet.sig {returns(::T.untyped)}
  def close(); end

  Sorbet.sig {returns(::T.untyped)}
  def closed?(); end

  Sorbet.sig do
    params(
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def configure_client(options=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def configure_server(options=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      message: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enqueue_message(message); end

  Sorbet.sig do
    params(
      which: ::T.untyped,
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def hint(which, value=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def host(); end

  Sorbet.sig {returns(::T.untyped)}
  def host_as_string(); end

  Sorbet.sig {returns(::T.untyped)}
  def host_key_verifier(); end

  Sorbet.sig do
    params(
      host: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(host, options=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def next_message(); end

  Sorbet.sig {returns(::T.untyped)}
  def options(); end

  Sorbet.sig {returns(::T.untyped)}
  def peer(); end

  Sorbet.sig do
    params(
      mode: ::T.untyped,
      consume_queue: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def poll_message(mode=T.unsafe(nil), consume_queue=T.unsafe(nil)); end

  Sorbet.sig {returns(::T.untyped)}
  def port(); end

  Sorbet.sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def push(packet); end

  Sorbet.sig {returns(::T.untyped)}
  def queue(); end

  Sorbet.sig {returns(::T.untyped)}
  def rekey!(); end

  Sorbet.sig {returns(::T.untyped)}
  def rekey_as_needed(); end

  Sorbet.sig do
    params(
      message: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_message(message); end

  Sorbet.sig {returns(::T.untyped)}
  def server_version(); end

  Sorbet.sig do
    params(
      service: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def service_request(service); end

  Sorbet.sig {returns(::T.untyped)}
  def shutdown!(); end

  Sorbet.sig {returns(::T.untyped)}
  def socket(); end

  Sorbet.sig {returns(::T.untyped)}
  def wait(); end
end

class Net::SSH::Transport::State
  Sorbet.sig {returns(::T.untyped)}
  def block_size(); end

  Sorbet.sig {returns(::T.untyped)}
  def blocks(); end

  Sorbet.sig {returns(::T.untyped)}
  def cipher(); end

  Sorbet.sig {returns(::T.untyped)}
  def cleanup(); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def compress(data); end

  Sorbet.sig {returns(::T.untyped)}
  def compression(); end

  Sorbet.sig {returns(::T.untyped)}
  def compression?(); end

  Sorbet.sig {returns(::T.untyped)}
  def compression_level(); end

  Sorbet.sig {returns(::T.untyped)}
  def compressor(); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def decompress(data); end

  Sorbet.sig {returns(::T.untyped)}
  def decompressor(); end

  Sorbet.sig {returns(::T.untyped)}
  def final_cipher(); end

  Sorbet.sig {returns(::T.untyped)}
  def hmac(); end

  Sorbet.sig do
    params(
      packet_length: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def increment(packet_length); end

  Sorbet.sig do
    params(
      socket: ::T.untyped,
      role: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(socket, role); end

  Sorbet.sig {returns(::T.untyped)}
  def max_blocks(); end

  Sorbet.sig do
    params(
      max_blocks: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def max_blocks=(max_blocks); end

  Sorbet.sig {returns(::T.untyped)}
  def max_packets(); end

  Sorbet.sig do
    params(
      max_packets: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def max_packets=(max_packets); end

  Sorbet.sig {returns(::T.untyped)}
  def needs_rekey?(); end

  Sorbet.sig {returns(::T.untyped)}
  def packets(); end

  Sorbet.sig {returns(::T.untyped)}
  def rekey_limit(); end

  Sorbet.sig do
    params(
      rekey_limit: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rekey_limit=(rekey_limit); end

  Sorbet.sig {returns(::T.untyped)}
  def reset!(); end

  Sorbet.sig {returns(::T.untyped)}
  def role(); end

  Sorbet.sig {returns(::T.untyped)}
  def sequence_number(); end

  Sorbet.sig do
    params(
      values: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set(values); end

  Sorbet.sig {returns(::T.untyped)}
  def socket(); end

  Sorbet.sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def update_cipher(data); end
end

module Net::SSH::Verifiers
end

class Net::SSH::Verifiers::Lenient < Net::SSH::Verifiers::Strict
  Sorbet.sig do
    params(
      arguments: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(arguments); end
end

class Net::SSH::Verifiers::Null
  Sorbet.sig do
    params(
      arguments: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(arguments); end
end

class Net::SSH::Verifiers::Secure
  Sorbet.sig do
    params(
      arguments: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(arguments); end
end

class Net::SSH::Verifiers::Strict < Net::SSH::Verifiers::Secure
  Sorbet.sig do
    params(
      arguments: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(arguments); end
end

class Net::SSH::Version
  include ::Comparable
  CURRENT = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)

  Sorbet.sig do
    params(
      version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <=>(version); end

  Sorbet.sig do
    params(
      major: ::T.untyped,
      minor: ::T.untyped,
      tiny: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(major, minor, tiny); end

  Sorbet.sig {returns(::T.untyped)}
  def major(); end

  Sorbet.sig {returns(::T.untyped)}
  def minor(); end

  Sorbet.sig {returns(::T.untyped)}
  def tiny(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_i(); end

  Sorbet.sig {returns(::T.untyped)}
  def to_s(); end

  Sorbet.sig do
    params(
      major: ::T.untyped,
      minor: ::T.untyped,
      tiny: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](major, minor, tiny); end
end

class Net::WriteAdapter
  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <<(str); end

  Sorbet.sig do
    params(
      socket: ::T.untyped,
      method: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(socket, method); end

  Sorbet.sig {returns(::T.untyped)}
  def inspect(); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def print(str); end

  Sorbet.sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def printf(*args); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def puts(str=T.unsafe(nil)); end

  Sorbet.sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(str); end
end
